{"meta":{"title":"Harvie Blog","subtitle":"Fright For Better Day","description":"IT Blog","author":"Harvie Yao","url":"https://harviealwayshere.github.io"},"pages":[{"title":"about","date":"2018-01-30T09:37:04.000Z","updated":"2018-01-30T09:37:04.587Z","comments":true,"path":"about/index.html","permalink":"https://harviealwayshere.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"Redis(四)Redis-PHP实战","slug":"redis4","date":"2018-03-06T01:22:31.000Z","updated":"2018-03-07T09:49:11.304Z","comments":true,"path":"2018/03/06/redis4/","link":"","permalink":"https://harviealwayshere.github.io/2018/03/06/redis4/","excerpt":"","text":"使用PHP操作Redis进行简单的项目开发 简单的字符串缓存分别使用set/hSet方法将对象用json_encode解析成json字符串以String/Hash的数据类型存储在Redis缓存中，并用get/hGet取出数据，用json_decode解码后var_dump输出对象1234567891011121314151617181920212223242526272829303132333435363738&lt;?php$redis = new Redis();$redis-&gt;connect(&apos;39.108.210.229&apos;,6379);$strCacheKey = &apos;stringCacheTest&apos;;//SET应用 存储String类型数据//所缓存的对象$arrCacheData = [ &apos;name&apos; =&gt; &apos;harvie&apos;, &apos;sex&apos; =&gt; &apos;male&apos;, &apos;age&apos; =&gt; &apos;22&apos;];//将对象解析成json字符串存储$redis-&gt;set($strCacheKey, json_encode($arrCacheData)); //设置缓存有效期 30S过期失效$redis-&gt;expire($strCacheKey, 30); //从缓存中取出数据 $json_data = $redis-&gt;get($strCacheKey);//将取出的json字符串解码成对象形式$data = json_decode($json_data);var_dump($data);//HSET应用 存储Hash类型数据$hashCacheKey = &apos;hashCacheTest&apos;;//所缓存的由数组组成的对象$arrWebSite = [ &apos;google&apos; =&gt; [ &apos;google.com&apos;, &apos;google.com.hk&apos; ],];//添加一个Value到Hash中$redis-&gt;hSet($hashCacheKey, &apos;google&apos;, json_encode($arrWebSite));$json_data = $redis-&gt;hGet($hashCacheKey, &apos;google&apos;);$data = json_decode($json_data);var_dump($data);在cli运行后输出为 简单队列使用lpush入队，使用lrange查看队列数据，使用rpop出队1234567891011121314151617181920212223242526&lt;?php$redis = new Redis();$redis-&gt;connect(&apos;39.108.210.229&apos;,6379);$strQueueName = &apos;queueName&apos;;//进队列$redis-&gt;lpush($strQueueName, json_encode([&apos;uid&apos; =&gt; 1,&apos;name&apos; =&gt; &apos;harvie&apos;]));$redis-&gt;lpush($strQueueName, json_encode([&apos;uid&apos; =&gt; 2,&apos;name&apos; =&gt; &apos;ryan&apos;]));$redis-&gt;lpush($strQueueName, json_encode([&apos;uid&apos; =&gt; 3,&apos;name&apos; =&gt; &apos;henry&apos;]));echo &quot;---- 进队列成功 ---- &lt;br /&gt;&lt;br /&gt;&quot;;//查看队列$strCount = $redis-&gt;lrange($strQueueName, 0, -1);echo &quot;当前队列数据为： &lt;br /&gt;&quot;;print_r($strCount);//出队列$redis-&gt;rpop($strQueueName);echo &quot;&lt;br /&gt;&lt;br /&gt; ---- 出队列成功 ---- &lt;br /&gt;&lt;br /&gt;&quot;;//查看队列$strCount = $redis-&gt;lrange($strQueueName, 0, -1);echo &quot;当前队列数据为： &lt;br /&gt;&quot;;print_r($strCount);由于linux对中文适配不好，我采用web远程访问，输入如下 订阅发布系统pub.php中使用publish推送给订阅的客户端消息1234567891011&lt;?phpini_set(&apos;default_socket_timeout&apos;, -1); //不超时$redis = new Redis();$redis-&gt;connect(&apos;39.108.210.229&apos;,6379);$strChannel = &apos;HarvieChannel&apos;;//发布 推送给订阅的客户端$redis-&gt;publish($strChannel,&quot;From &quot;.$strChannel.&quot; Channel Msg!&quot;);echo &quot;---- &#123;$strChannel&#125; ---- Channel Msg Push Success ! &lt;br/&gt;&quot;;$redis-&gt;close();sub.php中使用subscribe方法等待订阅频道的推送1234567891011121314151617181920&lt;?phpini_set(&apos;default_socket_timeout&apos;, -1); //不超时$redis = new Redis();$redis-&gt;connect(&apos;39.108.210.229&apos;,6379);$strChannel = &apos;HarvieChannel&apos;;echo &quot;Wait &#123;$strChannel&#125; Msg Push......&quot;;//订阅 使用subscribe方法接受订阅频道的消息$redis-&gt;subscribe([$strChannel], &apos;callBackFun&apos;);function callBackFun($redis, $channel, $msg)&#123; print_r([ &apos;redis&apos; =&gt; $redis, &apos;channel&apos; =&gt; $channel, &apos;msg&apos; =&gt; $msg ]);&#125;运行sub.php客户端，等待消息推送另外再打开一个终端，运行pub.php服务端推送消息此时可以看到sub.php终端中可以接收到服务器推送的消息 计数器使用INCR方法对指定的Key的Value+11234567891011121314151617&lt;?php$redis = new Redis();$redis-&gt;connect(&apos;39.108.210.229&apos;,6379);$strKey = &apos;commentsCount&apos;;//设置初始值$redis-&gt;set($strKey, 0);//使用INCR方法指定Key增加Value$redis-&gt;INCR($strKey); //+1$redis-&gt;INCR($strKey); //+1$redis-&gt;INCR($strKey); //+1$strNowCount = $redis-&gt;get($strKey);echo &quot;Now the num is &#123;$strNowCount&#125;&quot;; 排行榜使用zSet有序集合数据类型实现排行榜的自动排序，ZREVRANGE/ZRANGE方法取特定范围内从大到小/从小到大排序，可指定是否带分数1234567891011121314151617181920212223&lt;?php$redis = new Redis();$redis-&gt;connect(&apos;39.108.210.229&apos;,6379);$strKey = &apos;rankTest&apos;;//zadd向zSet集合添加数据$redis-&gt;zadd($strKey, &apos;50&apos;, json_encode([&apos;name&apos; =&gt; &apos;Tom&apos;]));$redis-&gt;zadd($strKey, &apos;70&apos;, json_encode([&apos;name&apos; =&gt; &apos;John&apos;]));$redis-&gt;zadd($strKey, &apos;90&apos;, json_encode([&apos;name&apos; =&gt; &apos;Jerry&apos;]));$redis-&gt;zadd($strKey, &apos;30&apos;, json_encode([&apos;name&apos; =&gt; &apos;Job&apos;]));$redis-&gt;zadd($strKey, &apos;100&apos;, json_encode([&apos;name&apos; =&gt; &apos;LiMing&apos;]));//ZREVRANGE取特定范围内从大到小排序的数组，最后一个参数为是否带分数显示$dataOne = $redis-&gt;ZREVRANGE($strKey, 0, -1, true);echo &quot;---- &#123;$strKey&#125;由大到小的排序 ---- &lt;br /&gt;&lt;br /&gt;&quot;;print_r($dataOne);//ZRANGE取特定范围内从小到大排序的数组，最后一个参数为是否带分数显示$dataTwo = $redis-&gt;ZRANGE($strKey, 0, -1, true);echo &quot;&lt;br /&gt;&lt;br /&gt;---- &#123;$strKey&#125;由小到大的排序 ---- &lt;br /&gt;&lt;br /&gt;&quot;;print_r($dataTwo); 字符串悲观锁确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性，以及数据库的统一性，乐观锁和悲观锁是并发控制主要采用的技术手段 悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作 实现机制：查询完数据的时候就把事务锁起来，直到提交事务 实现方式：数据库中的锁机制 实现特点：适合强一致场景，效率较低，特别是并发读的效率低 PHP+Redis实现悲观锁：利用redis中的setnx方法的原子性操作，设置一个LockKey，加锁的实质就是向redis中添加一个这个LockKey和过期时间，每次多个并发事务需要访问数据时，均先获取锁(就是用setnx方法设置LockKey字段)，只有首先设置了字段的事务才会得到锁(就是返回Ture)，进行接下来的数据处理操作，没有设置字段的事务就会阻塞直到锁过期或者获取锁的事务释放锁(就是删除LockKey字段)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?php$redis = new Redis();$redis-&gt;connect(&apos;39.108.210.229&apos;,6379);/** * 获取锁 * @param String $key 锁标识 * @param Int $expire 锁过期时间 * @return Boolean */function lock($key = &apos;&apos;, $expire = 5) &#123; //php函数无法调用外部变量 global $redis; //获取锁 $isLock = $redis-&gt;setnx($key, time()+$expire); //不能获取锁 if(!$isLock)&#123; //判断锁是否过期 $lockTime =$redis-&gt;get($key); //锁已过期，删除锁，重新获取 if (time() &gt; $lockTime) &#123; unlock($key); $isLock = $redis-&gt;setnx($key, time() + $expire); &#125; &#125; return $isLock? true : false;&#125;/** * 释放锁 * @param String $key 锁标识 * @return Boolean */function unlock($key = &apos;&apos;)&#123; //php函数无法调用外部变量 global $redis; return $redis-&gt;del($key);&#125;// 定义锁标识$key = &apos;PessimisticLock&apos;;// 获取锁$isLock = lock($key, 10);while(!$isLock)&#123; //获取锁失败 等待锁释放或者超时再获取 echo &apos;wait..&apos;; sleep(1); $isLock = lock($key, 10);&#125;//获取锁成功开始执行事务echo &apos;get lock success&lt;br&gt;&apos;;echo &apos;do sth..&lt;br&gt;&apos;;sleep(5);echo &apos;success&lt;br&gt;&apos;;unlock($key); 模拟测试：我们打开两个终端模拟并发过程，一个终端先获取锁执行事务，另一个终端获取锁失败之后每隔1s再次获取，直到第一个终端执行完事务(5s)释放锁或者锁超时(10s),这个实例里面是执行完事务就释放锁，另一个终端才开始获取到锁执行事务第一个终端获取锁开始执行事务第二个终端获取锁失败开始等待第一个终端执行完成事务释放锁第二个终端获取锁开始执行事务最后完成 字符串乐观锁乐观锁：假定不会发生并发冲突，只在提交操作时检查是否违反数据完整性 实现机制：在修改数据时将事务锁起来，通过version方式进行锁定 实现方式：使用version版本或者时间戳 实现特点：适合多读写少，并发冲突少的场景 PHP+Redis实现乐观锁：利用redis中的watch($Key)方法(watch可以监视一个KEY在事务提交exec()时是否改变，若改变则exec()会失败)，事务使用multi()开启和exec()批量提交 12345678910111213141516171819202122232425262728293031//optimisticLock.php &lt;?php$redis = new Redis();$redis-&gt;connect(&apos;39.108.210.229&apos;,6379);$strKey = &apos;optimisticLcok&apos;; //类似Mysql中的version//设置其version$redis-&gt;set($strKey,10);//watch监视Key$redis-&gt;watch($strKey);$versionNum = $redis-&gt;get($strKey);echo &quot;---- First Version:&#123;$versionNum&#125; ---- &lt;br/&gt;&lt;br/&gt;&quot;;//multi()开启事务$redis-&gt;multi(); $redis-&gt;set(&apos;ID&apos;,5);sleep(5);//第一个事务执行完准备提交时会发现版本号变了 提交失败$redis-&gt;exec();//查看此时版本号 $versionNum = $redis-&gt;get($strKey);echo &quot;---- Current Version:&#123;$versionNum&#125; ---- &lt;br/&gt;&lt;br/&gt;&quot;; //查看执行的事务设置ID是否回滚$id = $redis-&gt;get(&apos;ID&apos;);echo &quot;Set ID is :&quot;.$id.&quot;&lt;br&gt;&quot;;//当exec时候如果监视的key从调用watch后发生过变化，则整个事务会失败 12345678910&lt;?php//changeVersion.php 模拟并发程序$redis = new Redis();$redis-&gt;connect(&apos;39.108.210.229&apos;,6379);$strKey = &apos;optimisticLcok&apos;; //设置其version$redis-&gt;set($strKey,11); 先试试无并发情况直接执行可以看到版本号没改变而且事务执行设置ID成功，我们先删除所有键可以看到ID键已经清空了，然后试试有并发情况，执行事务时另一个并发程序改变了乐观锁(Version)的值可以看到若有并发程序改变了版本号，则事务并不能执行成功，ID键值设置失败了","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"php项目","slug":"php项目","permalink":"https://harviealwayshere.github.io/tags/php项目/"},{"name":"Redis","slug":"Redis","permalink":"https://harviealwayshere.github.io/tags/Redis/"}]},{"title":"webSecurity3","slug":"webSecurity3","date":"2018-03-04T11:58:41.000Z","updated":"2018-03-04T11:58:41.188Z","comments":true,"path":"2018/03/04/webSecurity3/","link":"","permalink":"https://harviealwayshere.github.io/2018/03/04/webSecurity3/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"webSecurity2","slug":"webSecurity2","date":"2018-03-04T11:58:36.000Z","updated":"2018-03-04T11:58:36.984Z","comments":true,"path":"2018/03/04/webSecurity2/","link":"","permalink":"https://harviealwayshere.github.io/2018/03/04/webSecurity2/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"WEB信息系统安全（一）概念与内涵","slug":"webSecurity1","date":"2018-03-04T11:58:31.000Z","updated":"2018-03-05T05:21:21.773Z","comments":true,"path":"2018/03/04/webSecurity1/","link":"","permalink":"https://harviealwayshere.github.io/2018/03/04/webSecurity1/","excerpt":"","text":"本系列是陈春华教授所讲授的信息系统安全课程的个人笔记 大纲 信息系统威胁 脆弱性 安全威胁 恶意代码攻击 窃听攻击 黑客攻击 风险损失(3类4性) 信息系统安全概念 基于通信保密(加密) 基于信息系统防护(被动) 基于信息保障(PDR框架/主动) 信息系统安全体系 5类安全服务 8种安全机制 5种普通安全机制 安全服务与安全机制关系 安全管理 信息系统的威胁：风险=脆弱性+威胁信息系统是开发信息资源的工具，是信息和采集、传输、存储、管理、检索、利用信息的工具的有机整体 脆弱性指信息系统本身具有薄弱环节和漏洞，表现在 1.信息属性的脆弱：易复制、易伪 2.系统结构复杂的结构性脆弱：系统功能庞大，结构复杂，安全反而是最薄弱的环节 3.攻防不对称：防御需要周全，攻击只需单点 4.网络的开放和数据库共享的脆弱：网络协议/应用 安全威胁指对于信息系统组成和功能造成某种损害的潜在可能，如对于用户密码的机密性威胁攻击：是安全威胁的具体实现，如窃听密码，主要形式有 1.恶意代码攻击：病毒、特洛伊木马、蠕虫、逻辑炸弹等 2.窃听攻击：声波、电磁波、手机、网络等窃听 3.黑客攻击：网络欺骗、拒绝服务、数据驱动漏洞、陷门等 恶意代码攻击未授权情况下，以破坏软硬件设备、窃取用户信息、干扰用户使用为目的的软件或代码 1.病毒：引起计算机故障，破坏计算机数据的程序代码，具有传染性、潜伏性、寄生性 2.蠕虫：通过网络随机找寻主机的系统漏洞进行高速繁殖自我复制的独立存在的程序代码 3.特洛伊木马：通过提供一些令人感兴趣的功能欺骗用户隐藏其恶意性功能的恶意程序 窃听攻击使用专有技术设备直接秘密窃取侦查目标的语音、图像等信息，有声波、电磁波、光缆、手机、网络窃听形式 黑客攻击 1.网络欺骗漏洞攻击：主要是对于网络协议的漏洞进行欺骗攻击，如针对以太网地址解析协议(ARP)欺骗、IP源欺骗、TCP会话劫持、DNS欺骗、Web欺骗和钓鱼网站 2.拒绝服务攻击：造成目标系统遭到破坏不能提供正常服务，如IP碎片、死亡之ping、UDP泛洪、SYN泛洪、MAC泛洪攻击 3.DDOS与僵尸网络：DOOS(Distributed Denial Of Service)为分布式拒绝服务攻击，僵尸网络(Botnet)指采用一种或多种传播手段将大量主机感染bot程序病毒从而在控制者与主机之间形成一个一对多的控制网络，DDOS是僵尸网络的一种攻击方式 风险损失信息资源损失可分为三类、四性 1.信息泄密：机密性(C,Confidentiality)损失 2.信息破坏：完整性(I,Integrity)、可用性(A,Availability)损失 3.假冒或否认：真实性(Authenticity) 信息系统安全信息系统安全可分为信息安全(内容安全) + 网络安全(网络基础设施安全) 基于通信保密的信息系统安全信息系统安全的基本概念和内涵是信息保密，采用的技术是加密(密码技术) 早期密码技术：替代密码术、换位密码术 计算机时代：密码学、数据加密标准(DES) ####基于信息系统防护的信息系统安全信息系统防护是一种被动防御的思想，目标有系统保护和信息内容保护，可分为两个阶段 1.计算机安全阶段：计算机本身的安全，如软硬件、自然灾害、病毒、数据库中的数据完整性保护 2.计算机网络安全阶段：计算机网络安全影响了信息系统的安全 基于信息保障的信息系统安全PDR(Protection-Detection-Response)：防护-检测-响应框架保障信息安全，检测是一种主动防御的思想，信息系统安全增加了可验证性和不可否认性等属性 信息系统安全体系包括两大部分： 1.安全服务：安全机制提供对付威胁的功能及其配备位置 2.安全机制：安全服务的具体实现 OSI/IEC 7498-2安全标准提出了一个建立在OSI参考模型7层协议上的信息安全体系结构标准，定义了5类安全服务，8种安全机制，5种普通安全机制，确定了安全服务于安全机制的关系，确定了安全管理 5类安全服务 1.鉴别服务：对于通信主体和数据源的鉴别，如网络层-主机地址、传输层-进程地址、应用层-人员账户 2.访问控制服务：防止非授权访问，对于访问主体与资源形成授权机制，对于用户进行访问控制 3.机密性服务：防止数据的非授权泄露，如攻击者难以通过观察业务流推断出敏感信息 4.完整性服务：对抗主动攻击，保护数据在存储、传输等过程中不被非授权修改，以提供真实准确的数据 5.抗抵赖服务：提供证据来证实通信实体的诚实性，如数据原发证明、数据交付证明 8种安全机制 安全机制与安全服务的关系 5种普通安全机制 信息系统的安全标准","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"WEB安全","slug":"WEB安全","permalink":"https://harviealwayshere.github.io/tags/WEB安全/"},{"name":"校园课程","slug":"校园课程","permalink":"https://harviealwayshere.github.io/tags/校园课程/"}]},{"title":"Redis(三)PHP操作Redis","slug":"redis3","date":"2018-03-04T07:49:05.000Z","updated":"2018-03-06T01:23:31.335Z","comments":true,"path":"2018/03/04/redis3/","link":"","permalink":"https://harviealwayshere.github.io/2018/03/04/redis3/","excerpt":"","text":"使用PHP拓展操作Redis 下载安装PHP-Redis拓展1.下载压缩文件包[https://github.com/phpredis/phpredis]2.将文件上传到服务器并解压unzip phpredis-develop.zip若出现-bash: unzip: command not found则需要安装unzip3.进入并phpize处理cd phpredis-developphpize4.指定配置文件若不知道php-config在哪里，可以使用命令查找find / -name “php-config”指定配置文件路径./configure –with-php-config=/usr/bin/php-config5.编译和安装make &amp;&amp; make install成功后会显示6.修改PHP配置文件php.ini添加.so拓展文件查找php.ini文件并进入vi编辑模式类似添加Swoole拓展一样，在底下添加extension = /usr/lib64/php/modules/redis.so7.查看是否安装成功php -m 使用PHP拓展操作Redis简单连接、授权密码、设置字符串、读取字符串测试在服务端运行该脚本可看到 修改redis_6379.conf配置文件将bind语句加上#注释掉在redis3.2后增加了保护模式，在这个模式下也不允许外网访问，需要设置成protected-mode no重启Redis [三个小时踩了一个坑]我用http://39.108.210.229/redis.php 无法访问，于是我在redis.php文件上加上ini_set(‘display_errors’,1);ini_set(‘display_startup_errors’,1);error_reporting(-1);打印出错误信息，发现错误信息为Fatal error: Uncaught Error: Class ‘Redis’ not found in /var/www/html/redis.证明找不到这个类，可是明明已将拓展添加到php.ini中了，于是我在cli下执行php -m可以看到有redis拓展，在web下访问phpinfo()，发现竟然没有redis拓展，难怪找不到Redis类于是我百度了下php -m和phpinfo()不一致，发现可能是cli加载的配置文件和web加载的php配置文件不同，于是在cli下输入which php发现与phpinfo()出现的版本相同，那看来cli下的php和web下的php是相同的，但是为什么拓展不同呢，最后才明白，因为没有重新启动httpd服务器，重新启动后phpinfo()中就有redis拓展了，访问http://39.108.210.229/redis.php 也成功打印出了数据","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"php项目","slug":"php项目","permalink":"https://harviealwayshere.github.io/tags/php项目/"},{"name":"Redis","slug":"Redis","permalink":"https://harviealwayshere.github.io/tags/Redis/"}]},{"title":"Redis(二)客户端操作(cli)","slug":"redis2","date":"2018-03-04T07:48:40.000Z","updated":"2018-03-05T09:34:13.965Z","comments":true,"path":"2018/03/04/redis2/","link":"","permalink":"https://harviealwayshere.github.io/2018/03/04/redis2/","excerpt":"","text":"在命令行通过客户端操作Redis 客户端常用命令ping: 查看服务器是否允许quit: 关闭当前连接auth: 验证密码select: 选择数据库，0-15，共16个，默认使用0flushdb: 删除当前数据库flushall: 删除所有数据库del: 删除键exists: 检查键是否存在 ping/auth测试set/get/select/flushdb/flushall测试del/exists测试 数据类型Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储 1.字符串(String)：最基本的数据类型，Key-Value结构 设置：set key value 获取：get key 2.哈希(Hash)：键值对的集合，适合存储对象 设置：hmset objectName key1 value2 key2 value 2… 获取单个对象所有信息：hgetall objectName 获取单个对象单个信息：hget objectName key 3.列表(List)：按照插入顺序排序，可以添加元素到列表头部（左边）或尾部（右边） 左侧压入数据：lpush key value1 value2… 左侧弹出数据：lpop 右侧压入数据：rpush key value1 value2… 右侧弹出数据：rpop 范围显示：lrange key start stop 显示个数：llen key 4.集合(Set)：string类型的无序集合，集合中元素时唯一的 添加数据：sadd key value1 value2… 显示数据：smembers key 显示总数：scard key 随机移除：spop key [count] 5.有序集合(Zset:SortSet)：每个元素都需要关联一个double类型的分数，redis根据分数为集合中的成员进行排序 添加数据：zadd key score value 显示数据：zrange key start stop 显示总数：zcard key 显示范围：zcount key start stop 显示序号：zrank key member 显示分数：zscore key member","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"php项目","slug":"php项目","permalink":"https://harviealwayshere.github.io/tags/php项目/"},{"name":"Redis","slug":"Redis","permalink":"https://harviealwayshere.github.io/tags/Redis/"}]},{"title":"Redis(一)安装","slug":"redis1","date":"2018-03-04T07:48:12.000Z","updated":"2018-03-05T11:31:30.520Z","comments":true,"path":"2018/03/04/redis1/","link":"","permalink":"https://harviealwayshere.github.io/2018/03/04/redis1/","excerpt":"","text":"Redis是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。 Redis特点： 1.Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。 2.Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。 3.Redis支持数据的备份，即master-slave模式(主从模式)的数据备份。 Redis在Linux下的安装与配置1.安装Redis：1.1下载安装包：在[https://redis.io/download] 中选择你想要的版本下载压缩包并上传到服务器1.2解压：tar -zxvf redis-3.2.11.tar.gz1.3移动：cp -R redis-3.2.11 /usr/local/redis1.4切换到移动后的地址：cd /usr/local/redis/redis-3.2.111.5安装：make install完成后可看到如下可进入目录下的src资源文件夹看到两个服务程序：redis-cli（客户端） redis-server（服务端） 2.配置Redis2.1测试Redis客户端(前台执行)：./redis-server 2.2添加环境变量：可全局执行命令pwd ##查看当前目录，即使需要添加的环境变量的目录vi /etc/profile ##打开环境变量配置文件export PATH=$PATH:/usr/local/redis/redis-3.2.11/src ##在最底下添加这一行source /etc/profile ##立即生效此时切换到别的目录可以看到可以使用redis命令 2.3修改Redis后台启动cd /usr/local/redis/redis-3.2.11其中的redis.conf就是配置文件cp redis.conf redis_6379.conf ##拷贝配置文件vi redis_6379.conf ##编辑新的配置文件将daemonize no =&gt; daemonize yes ##修改成以守护进程(后台)方式运行 2.4修改Redis启动脚本cd /user/local/redis/redis-3.2.11/utils其中的redis_init_script就是启动脚本cp redis_init_script redis_init_script_6379 ##拷贝启动脚本vi redis_init_script_6379 ##编辑新的启动脚本修改服务器路径、客户端路径、配置文件路径如下 2.5测试启动脚本cd /usr/local/redis/redis-3.2.11/utils./redis_init_script_6379 start ##运行启动脚本ps aux | grep redis ##查看进程 查看是否启动Redis服务成功 2.6设置开机启动vi /etc/re.local 添加/usr/local/redis/redis-3.2.11/utils/redis_init_script_6379 start 2.7使用客户端访问（测试是否启动Redis服务成功）redis-cli ##启动客户端连接Redis服务器>pingPONG ##则启动服务成功 2.8客户端连接参数redis-cli连接参数：-h 指定主机 -p 指定端口号 -a 指定密码默认情况下无密码，使用密码有两种方式1.单次生效，通过命令配置 设置密码：config set requirepass 123456 获取密码：config get requirepass 授权使用：auth 123456 2.永久生效，通过修改配置文件 vi redis_6379.conf 取消’requirepass’的注释，加上密码，如requirepass 123456 Tips:无论单次还是永久密码，启动密码后，无密码也可以连接，但无权限进行操作 3.总结3.1启动Redis服务：cd /usr/local/redis/redis-3.2.11/utils./redis_init_script_6379 start3.2停止Redis服务：redis-cli>shutdown3.2客户端连接Redis服务：redis-cli","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"php项目","slug":"php项目","permalink":"https://harviealwayshere.github.io/tags/php项目/"},{"name":"Redis","slug":"Redis","permalink":"https://harviealwayshere.github.io/tags/Redis/"}]},{"title":"数据结构与算法总结（一） 排序","slug":"suanfa1","date":"2018-03-02T09:11:07.000Z","updated":"2018-03-05T05:24:20.356Z","comments":true,"path":"2018/03/02/suanfa1/","link":"","permalink":"https://harviealwayshere.github.io/2018/03/02/suanfa1/","excerpt":"","text":"本文主要用来系统归纳并总结所遇到的算法及其实现方法 大纲 1.冒泡排序 2.插入排序 3.选择排序 4.希尔排序 5.归并排序 6.快速排序 7.堆排序 1.冒泡排序原始版本：冒泡排序思想(从小到大)： 1.比较相邻的前后两个数据，若前面的数据大于后面的数据，就交换两个数据位置 2.对数组第0个数据到N-1个数据进行一次遍历后，第N-1位置上的就为最大的数据 3.N=N-1，若N!=0则对剩下的数组执行12步，否则排序完成123456789void bubbleSort(int a[],int n)&#123; for(int i=0;i&lt;n;i++) //i表示整体遍历次数，即排好数据的个数 for(int j=1;j&lt;n-i;j++) //j表示每次的比较遍历，每完成一次i就减少j遍历的域一个，因此j只遍历到n-i if(a[j-1]&gt;a[j]) Swap(a[j-1],a[j]); &#125;//Tips：若用j与j+1比较，则内部循环为//for(int j=0;j&lt;n-i-1;j++) // if(a[j]&gt;a[j+1]) Swap(a[j],a[j+1]); 改良1：冒泡排序比较刻板，有时候已经排序好了缺还继续遍历，导致后面的多次遍历都是读取值不交换，浪费了时间，因此我们可以改良一下，设置一个标志，若有一次遍历没有发生交换，则表示排序完成 1.外层循环不再以整体遍历次数作为循环结束条件，而是以是否交换的标志作为循环结束条件 2.控制内层循环还是需要使用i作为整体循环次数，减少遍历已经排好位置的值的多余遍历1234567891011121314151617void bubbleSort(int a[],int n)&#123; bool signal=true; int i=0; //排好数据的个数 while(signal) //1. &#123; signal=false; for(int j=1;j&lt;n-i;j++) //2. if(a[j-1]&gt;a[j]) &#123; Swap(a[j-1],a[j]); signal=true; &#125; i++; //2. &#125; &#125; 改良2：若每次进行遍历时，后面部分的数组已经排好序了且都大于前面的数组，在每次遍历就只需要遍历前面的数组即可，我们可以记录最后交换的位置确定下次循环的范围，下次循环到这个位置即可1234567891011121314151617void bubbleSort(int a[],int n)&#123; int signal=n; //最后交换的位置 int i; //排好数据的个数 while(signal&gt;0) //1. &#123; i=signal; signal=0; //signal初始化为0，因为一开始交换的位置不知道 for(int j=1;j&lt;i;j++) if(a[j-1]&gt;a[j]) &#123; Swap(a[j-1],a[j]); signal=j; //记录最后交换的位置 &#125; &#125; &#125; 2.插入排序基本思想：每次将一个待排序的值插入到已排序的序列中的正确位置，直到全部记录插入完成原始版本：由小到大 1.初始时数组第一个数组成了已排序序列 2.搜索过程：将待排序的值与已排序的序列比较，找到其正确位置 3.数据后移过程：将大于待排序的值的数向后移一个单位，空出位置填入待排序的值123456789101112131415161718192021void insertSort(int a[],int n)&#123; int i,j,k; for(int i=1;i&lt;n;i++) //1.从i=1开始遍历 &#123; for(j=i-1;j&gt;=0;j--) //2.搜索过程 &#123; if(a[j]&lt;a[i]) break; &#125; if(j!=i-1) //若找到合适位置(若j=i-1则这个值已排好序) &#123; int temp=a[i]; for(k=i-1;k&gt;j;k--) //3.数据后移过程 &#123; a[k+1]=a[k]; &#125; a[j+1]=temp; &#125; &#125;&#125; 改良1：原始版本3个for循环太不清晰简洁，将搜索与数据后移过程合并可减少一个循环 1.待排序的值大于已排序序列中的最大值(最后一位)，则无需插入 2.搜索+数据后移：搜索的时候将已排序序列值与待排序的值比较，若大则往后移，直到找到比待排序的值小的值，此时直接插入其后一位即可1234567891011121314151617void insertSort(int a[],int n)&#123; int i,j; for(i=1;i&lt;n;i++) &#123; if(a[i]&lt;a[i-1]) //1.判断是否需要插入排序 &#123; int temp=a[i]; //保存待排序的值 for(j=i-1;j&gt;=0;j--) &#123; if(a[j]&gt;temp) a[j+1]=a[j]; //若已排序序列的值比待排序的值大，则后移 else break; //若已排序序列的值比待排序的值小，则停止循环 &#125; a[j+1]=temp; //直接插入其后一位 &#125; &#125;&#125; 3.选择排序基本思想：与插入排序类似，都将数据分为有序区和无序区，不同的是，插入排序是将无序区第一个元素直接插入有序区形成更大的有序区，选择排序是从无序区选择最小(大)的元素放入有序区的最后原始版本： 1.无序区最大数的下标初始化为有序区的最大数下标，便于写循环函数，若初始化为无序区第一个数下标，则循环从无序区第二个数开始 2.交换函数最好使用中间变量，因为有可能自己与自己交换,不使用中间变量需判断12345678910111213141516171819202122232425262728void selectSort(int a[],int n)&#123; int i,j,maxIndex; for(i=0;i&lt;n;i++) &#123; maxIndex=i; //1. for(j=i+1;j&lt;n;j++) &#123; if(a[j]&gt;a[maxIndex]) maxIndex=j; &#125; Swap(a[i],a[maxIndex]); &#125;&#125;void Swap(int &amp;a,int &amp;b) //2.使用中间变量无需判断&#123; int c=a; a=b; b=c;&#125;void Swap(int $a,int &amp;b) //2.不使用中间变量需判断&#123; if (a != b) &#123; a ^= b; b ^= a; a ^= b; &#125; &#125; 4.希尔排序基本思想：实质是分组插入排序，先将待排序元素分割成若干个子序列(相隔某个增量)，分别进行插入排序，然后依次缩小增量再进行排序，最后对全体元素进行插入排序，由于此时序列的有序程度已经很高了，因此效率较高原始版本： 1.计算步长：通常是数组长度/2 2.确定分组个数：从0到一个步长的元素个数为分组个数，这些元素都是分组中的第一个元素 3.每个分组进行插入排序(两个for循环)123456789101112131415161718192021222324void shellSort(int a[],int n)&#123; int i,j,gap,k; for(gap=n/2;gap&gt;0;gap=gap/2) //1.计算步长 &#123; for(i=0;i&lt;gap;i++) //2.确定分组个数 &#123; for(j=i+gap;j&lt;n;j=j+gap) //3.每个分组进行插入排序 &#123; if(a[j]&lt;a[j-gap]) &#123; int temp=a[j]; for(k=j-gap;k&gt;=0;k=k-gap) &#123; if(a[k]&gt;temp) a[k+gap]=a[k]; else break; &#125; a[k+gap]=temp; &#125; &#125; &#125; &#125;&#125; 5.归并排序归并排序是基于分治法，基本思想是归：将数组一直拆分，直到拆分成一个数据的时候，可以认为这个子数组为有序的并：若两个子数组均有序，按顺序合并成一个数组就是有序的原始版本： 1.合并函数：设定两个指针指向两个已排序数组的起始位置，比较指针所指元素，选择小的元素放入合并空间中并移动指针到下一个位置，若某一指针超出自身子数组的序列范围，则将另一子数组剩下所有元素赋值到合并序列中，最后将合并序列的元素覆盖原先数组元素的位置 2.分解函数：将传入的数组分解成两个数组，之后继续分解分解出来的两个子数组，直到分解出来的数组中仅有一个元素则可认为有序，之后调用合并函数合并子数组 3.归并排序：先申请空间，用来存放合并序列，调用分解函数后释放空间123456789101112131415161718192021222324252627282930313233343536373839void mergeArray(int a[],int start,int mid,int end,int temp[]) //1.合并函数&#123; int i=start,j=mid+1; //两个子数组的头元素 int m=mid,n=end; //两个子数组的尾元素 int k=0; //temp数组所赋值的位置 while(i&lt;=m&amp;&amp;j&lt;=n) &#123; if(a[i]&lt;a[j]) temp[k++]=a[i++]; else temp[k++]=a[j++]; &#125; while(i&lt;=m) temp[k++]=a[i++]; while(j&lt;=n) temp[k++]=a[j++]; for(i=0;i&lt;k;i++) &#123; a[start+i]=temp[i]; &#125;&#125;void splitArray(int a[],int start,int end,int temp[]) //2.分解函数&#123; if(start&lt;end) &#123; int mid=(start+end)/2; splitArray(a,start,mid,temp); splitArray(a,mid+1,end,temp); mergeArray(a,start,mid,end,temp); &#125;&#125;bool mergeSort(int a[],int n) //3.归并排序&#123; int *p = new int[n]; if(p==NULL) return false; splitArray(a,0,n-1,p); delete[] p; return true;&#125; 6.快速排序快速排序基于分治法剑指offer上给出的是分区(Partition)方法是 1.随机找基准值 2.将基准值移至数组尾部 3.从数组头部开始遍历数组，找到一个小于基准值的数就将其移到数组前方 4.将基准值移到最后一个小于基准值的数的下一个位置上 5.返回基准值位置 之后便是快速排序(QuickSort)： 1.若传入数组为一个数，则表示排序完成 2.否则调用分区(Partition)函数 3.分区完成后，对于左分区(小于基准值)右分区(大于基准值)再递归调用快速排序(QuickSort)方法，直到排序完成1234567891011121314151617181920212223242526272829303132333435363738//分区(Partition)int Partition(int data[], int length, int start, int end)//分区&#123; if(data==NULL || length&lt;=0 || start&lt;0 || end&gt;=length) //输入参数有效行检验 throw new std::exception(&quot;Invalid Parameters&quot;); int index = RandomInRange(start,end); //1.随机找基准值 Swap(&amp;data[index], &amp;data[end]); //2.将基准值移至数组尾部 int small = start-1; //small位置表示小于基准数的值要填入的位置 //3.从数组头部开始遍历数组，找到一个小于基准值的数就将其移到数组前方 for(index=start; index&lt;end; index++) &#123; if(data[index]&lt;data[end]) //如果找到一个小于基准数的值 &#123; small++; //先small++找到应该放入数组的位置 if(small!=index) Swap(&amp;data[index], &amp;data[small]); //若small位置等于index位置，证明index位置的值是处于正确位置上不需要交换 //否则证明index位置上的值小于基准数还不处于应该填入的位置上，需要交换到small位置上 &#125; &#125; small++; Swap(&amp;data[small], &amp;data[end]); //4.将基准值移到最后一个小于基准值的数的下一个位置上 return small; //5.返回基准值位置，此时small左边为小于基准数的值，small右边为大于基准数的值&#125;//快速排序(QuickSort)void QuickSort(int data[],int length,int,start,int end)&#123; if(start==end) return; //1.若传入数组为一个数，则表示排序完成 int index=Partition(data,length,start,end); //2.否则调用分区(Partition)函数 3.分区完成后，对于左分区(小于基准值)右分区(大于基准值)再递归调用快速排序(QuickSort)方法，直到排序完成 if(index&gt;start) QuickSort(data,length,start,index-1); if(index&lt;end) QuickSort(data,length,index+1,end);&#125; MoreWindows博客大大提出了另一种实现方法，较为简洁，与剑指Offer提出的实现方法相比，有如下改动 1.直接选取第一个数作为基准数(也可以随机选择) 2.有前后指针同时遍历数组，而不是单一从前往后遍历 3.采用挖坑填数思想：将基准数保存，之后尾指针遍历，若是所指向的值比基准数小则填入头指针所指向的位置，之后头指针遍历，若是所指向的值比基准数大则填入尾指针所指向的位置，直到头指针与尾指针指向同一个位置，在这个位置填入基准数即可123456789101112131415161718192021222324//快速排序 void quick_sort(int s[], int l, int r) //l为头指针，r为尾指针&#123; if (l &lt; r) //递归停止条件：若l=r即为数组只有一个元素时则停止递归 &#123; //Swap(s[l], s[RandomInRange(l,r)]); //1.直接选取第一个数作为基准数(也可以随机选择) int i = l, j = r, x = s[l]; //将基准数保存在x里面，i为头指针，j为尾指针 while (i &lt; j) &#123; while(i &lt; j &amp;&amp; s[j] &gt;= x) // 从尾向头找第一个小于基准数的数 j--; if(i &lt; j) // 填入头指针所指向的位置并头指针指向下一个位置 s[i++] = s[j]; while(i &lt; j &amp;&amp; s[i] &lt; x) // 从头向尾找第一个大于等于x的数 i++; if(i &lt; j) // 填入尾指针所指向的位置并尾指针指向下一个位置 s[j--] = s[i]; &#125; s[i] = x; //将基准数填入头尾指针所指向的位置 quick_sort(s, l, i - 1); // 将左分区递归调用排序 quick_sort(s, i + 1, r); // 将右分区递归调用排序 &#125; &#125; Python实现更加简单，因为python在分治中很容易找到比基准值大或者小的数并放在一个数组里，而且Python合并数组也十分简单123456789//Python实现快速排序def quicksort(array): if(len(array)&lt;2): return array else: pivot=array[0] less=[i for i in array[1:] if i &lt;= pivot] greater=[i for i in array[1:] if i&gt; pivot] return quicksort(less)+[pivot]+quicksort(greater) 7.堆排序二叉堆：是完全二叉树或者近似完全二叉树，满足两个特点 1.父节点的键值总是大于(小于或者等于)任何一个子节点的键值，是一个最大堆(最小堆) 2.每个节点的左子树和右子树都是一个二叉堆 堆的存储：从上到下、从左到右遍历堆存储，一般用数组存储，这样节点有这样的规律：对于i节点：其父节点下标为(i-1)/2，其左右子节点为2*i+1和2\\i+2插入堆：总是将插入的数据放在数组最后，可通过将其与父节点比较调整位置，从而让数组满足堆的条件1234567891011121314151617void insertHeap(int a[],int n,int newData)&#123; a[n]=newData; //将插入的数据放在数组最后 int j=n; //子节点下标 int i=(j-1)/2; //父节点下标 while(i &gt;=0 &amp;&amp; j !=0) &#123; //若父节点的值大于子节点，则交换并继续比较新的父节点与子节点(最小堆) if(a[i]&gt;a[j]) &#123; Swap(a[i],a[j]); j=i; //交换后的父节点变新的子节点 i=(j-1)/2 //新的子节点的父节点 &#125; else break; //若父节点的值小于等于子节点，则停止交换 &#125;&#125;删除堆：按照定义每次只能删除第0个数据，为了便于重建堆，实际是将最后一个数据的值赋给根节点，再将根节点与其子节点比较调整位置，从而让数组满足堆的条件123456789101112131415161718void deleteHeap(int a[],int n)&#123; Swap(a[0],a[n-1]); //最后一个数据的值赋给头节点，此时尾节点下标为n-2 int i=0; //父节点下标 int j=2*i+1; //左子树节点 while(j&lt;=n-2) &#123; if(j+1&lt;=n-2 &amp;&amp; a[j+1]&lt;a[j]) j++; //在左右子树节点找到最小的 //若父节点的值大于子节点，则交换并继续比较新的父节点与子节点(最小堆) if(a[i]&gt;a[j]) &#123; Swap(a[i],a[j]); i=j; //交换后的子节点变为新的父节点 j=2*i+1; //新的父节点的子节点 &#125; else break; //若父节点的值小于等于子节点，则停止交换 &#125;&#125;堆化数组：只要将非叶子节点从下往上从右往左遍历，进行下沉调整即可下沉函数：类似于删除堆中的操作，即父节点其子节点比较调整位置，从而让数组满足堆的条件123456789101112131415161718192021222324//下沉函数void sink(int a[],int i,int n) //参数：数组，需要调整的父节点，数组长度&#123; int j=2*i+1; while(j&lt;=n-1) &#123; if(j+1&lt;=n-1 &amp;&amp; a[j+1]&lt;a[j]) j++; if(a[i]&gt;a[j]) &#123; Swap(a[i],a[j]); i=j; j=2*i+1; &#125; else break; &#125;&#125;//建立最小堆void makeHeap(int a[],int n)&#123; for(int i=n/2-1;i&gt;=0;i--) &#123; sink(a,i,n); &#125;&#125;堆排序：建立好的最小堆中第0个数据时堆中最小的数据，取出这个数据再执行下堆的删除，这样堆中第0个数据又是最小的数据，重复上述步骤直到堆中只有一个数据就直接取出，则取出的数据就是有序序列了12345678void heapSort(int a[],int n)&#123; for(int i=n-1;i&gt;0;i--) &#123; makeHeap(a,i+1); deleteHeap(a,i+1); &#125;&#125;","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://harviealwayshere.github.io/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://harviealwayshere.github.io/tags/算法/"}]},{"title":"剑指Offer算法记录(二)算法","slug":"offer2","date":"2018-03-02T09:06:07.000Z","updated":"2018-03-02T09:29:23.468Z","comments":true,"path":"2018/03/02/offer2/","link":"","permalink":"https://harviealwayshere.github.io/2018/03/02/offer2/","excerpt":"","text":"本文主要记录阅读剑指Offer这本书所遇到的算法解释并作一些个人的拓展 第二章2.4 算法和数据操作排序和查找是面试时考查算法的重点，如二分查找、归并排序、快速排序等。递归和循环是两种算法实现的方式，基于递归的实现较整洁但性能不如基于循环实现的方法，我们应该根据题目特点来选择使用哪种实现方式。 位运算可以看做一类特殊的算法，共有与、或、异或、左移和右移五种位运算2.4.1 查找和排序查找不外乎：顺序查找、二分查找、哈希表查找和二叉排序树查找，无论用递归还是循环都需要掌握这些查找方法的实现。排序则复杂一些：插入排序、冒泡排序、归并排序、快速排序等不同算法的优劣，能够从额外空间消耗、平均时间复杂度和最差时间复杂度等方面去比较它们的优缺点。值得一提的是，快速排序的实现代码是面试官钟爱的。快速排序思路:选择一个数字(有多种选择法)，接下来把数组中的数字分成两部分，比选择的数字小的数字移到数组的左边，比选择数字大的数字移到数组右边12345678910111213141516171819202122232425262728293031323334int Partition(int data[], int length, int start, int end)//分区&#123; if(data==NULL || length&lt;=0 || start&lt;0 || end&gt;=length) //输入参数有效行检验 throw new std::exception(&quot;Invalid Parameters&quot;); int index = RandomInRange(start,end); //函数RandomInRange生成[start,end]的随机数index为基准数 Swap(&amp;data[index], &amp;data[end]); //将基准数放在最后 int small = start-1; //small位置表示小于基准数的值要填入的位置 for(index=start; index&lt;end; index++) //从start开始寻找小于基准数的值 &#123; if(data[index]&lt;data[end]) //如果找到一个小于基准数的值 &#123; small++; //先small++锁定数组的前部分位置 if(small!=index) Swap(&amp;data[index], &amp;data[small]); //若small位置等于index位置，证明index位置的值是处于正确位置上不需要交换 //否则证明index位置上的值小于基准数还不处于small位置上，需要交换到small位置上 &#125; &#125; small++; Swap(&amp;data[small], &amp;data[end]); //最后将基准数与small++位置上的值交换，分区完成 return small; //返回基准数的位置，此时small左边为小于基准数的值，small右边为大于基准数的值&#125;//递归调用分区函数即为快速排序void QuickSort(int data[],int length,int,start,int end)&#123; if(start==end) return; //直到分区为一个数即为排好序了 int index=Partition(data,length,start,end); if(index&gt;start) QuickSort(data,length,start,index-1); if(index&lt;end) QuickSort(data,length,index+1,end);&#125;","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://harviealwayshere.github.io/tags/算法/"}]},{"title":"JS（四）JS常用对象","slug":"js4","date":"2018-02-27T07:21:19.000Z","updated":"2018-03-01T14:30:28.224Z","comments":true,"path":"2018/02/27/js4/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/27/js4/","excerpt":"","text":"JavaScript 中的所有事物都是对象：字符串、数值、数组、函数… JS对象基本概念JS对象由花括号分隔，对象属性以名称和值对的形式(name:value)来定义，对象属性由逗号分隔JS提供多个内建对象，如String、Date、Array等，对象是一种特殊的数据类型拥有属性和方法对象属性：是与对象有关的值，可用object.att或者object[“att”]访问，如var message=”hello world”;var length=message.length;对象方法：是能够在对象上执行的动作，可用objectName.methodName()访问，如var message=”hello world”;var upperMsg=message.toUpperCase(); JS对象创建JS创建对象有种方式 字面量创建使用{ }包围1var Person=&#123;firstName:&quot;John&quot;, lastName:&quot;Doe&quot;, id:5566&#125;; Object创建1234var Person=new Object();Person.firstName:&quot;John&quot;;Person.lastName:&quot;Doe&quot;;Person.id:5566; 工厂模式创建12345678910function createPerson(firstName,lastName,id)&#123; var obj=new Object(); obj.firstName=firstName; obj.lastName=lastName; obj.id=id; return obj;&#125;var Person1=createPerson(&quot;John&quot;,&quot;Doe&quot;,5566);var Person2=createPerson(&quot;Arvin&quot;,&quot;Harvie&quot;,7788); 构造函数创建12345678function Person(firstName,lastName,id)&#123; this.firstName=firstName; this.lastName=lastName; this.id=id;&#125;var Person1=new Person(&quot;John&quot;,&quot;Doe&quot;,5566);var Person2=new Person(&quot;Arvin&quot;,&quot;Harvie&quot;,7788); 原型创建对象123456789function Person()&#123;&#125;Person.prototype.firstName=&quot;John&quot;;Person.prototype.lastName=&quot;Doe&quot;;Person.prototype.id=5566;var person1=new Person();var person2=new Person();person2.firstName=&quot;Arvin&quot;;person2.lastName=&quot;Harvie&quot;;person2.id=7788; 组合构造函数和原型创建对象1234567891011function Person(firstName,lastName,id)&#123; this.firstName =firstName; this.lastName = lastName; this.id = id;&#125;Person.prototype = &#123; constructor:Person, showId: function()&#123; alert(this.id); &#125;;&#125; 总结：第1/2种字面量和Object构建对象，对于简单属性的对象而言十分简单明了，但是它们都是用了同一个接口创建很多对象，会产生大量的重复代码，就是如果你有100个对象，那你要输入100次很多相同的代码第3种工厂模式创建对象，将创建对象过程封装在函数体内，通过函数调用生成对象，但是无论哪个对象的生成函数返回的都是一个对象，我们无法判断返回的对象是哪个类型第4种构造函数创建对象，没有显式创造对象，没有return语句，而且可以识别对象类型，使用instanceof操作符进行检测(person insanceof Person);但是若对象中含有方法，则每个方法都要在实例中创建一遍，然而每个对象的方法应该是相同的才对，若是方法的数量很多，就会占用很多不必要的内存第5中原型创建对象，可以让所有对象实例共享它所包含的属性和方法，若为对象实例添加一个属性，这个属性会覆盖原型对象中的属性，但是这样子每个对象实例的属性一般都是不同的，创建起来就很复杂第6中原型和构造函数结合创建对象，是最好的，构造函数用于定义实例属性使每个对象实例有自己的属性，原型模式用于定义方法和共享的属性使每个对象相同的方法和属性共用同一片内存，节省空间 JS遍历对象可以使用for…in…循环遍历对象属性，语法：for (name in object){ text=text+name+”=&gt;”+object[name]+”\\n”;} JS Number对象JS中的数字可以使用小数点，也可以不使用小数点，如var x=314;var y=3.14;JS中数字均为浮点型，采用IEEE754标准定义的64位浮点格式表示JS中八进制前缀为0，十六进制前缀为0x，可以使用Number.toString(8/16/2)转换进制JS中的数字运算超出了数字上限，则以Infinity表示JS中的数字运算发生错误产生了非数字值，则以NaN表示，可以用isNaN()Number对象属性**： object.constructor：返回创建此对象的函数引用 Number.MAX_VALUE：返回Number可表示的最大的数 Number.MIN_VALUE：返回Number可表示的最小的数 Number.NaN：返回NaN Number对象方法： NumberObject.toString(radix=10)：将Number对象转换为radix进制的字符串 NumberObject.toLocaleString()：将Number对象转换为本地格式的字符串 NumberObject.toFixed(num=0)：将Number四舍五入为num(0-20)小数位数的数字 NumberObject.toExponential(num)：将Number转换成num(0-20)小数位的指数计数 NumberObject.valueOf()：返回Number对象的值的字符串 JS String对象String对象属性： object.constructor：返回创建此对象的函数引用 stringObject.length：返回字符串中字符数目 String对象方法： stringObject.indexOf(searchvalue,fromindex)：返回searchvalue在stringObject中首次出现的位置，fromindex为开始检索的位置(可选)，方法大小写敏感且无检索结果返回-1 stringObject.match(searchvalue/regexp)：返回stringObject中匹配searchvalue的字符串或者匹配regexp正则表达式的字符串，若regexp具有标志g则为多次匹配返回所有匹配字符串的数组 stringObject.replace(regexp/substr,replacement)：返回用replacement替换了regexp/substr匹配的字符串的新字符串 stringObject.toLocaleUpperCase()/toLocaleLowerCase()：返回大写/小写字符串 stringObject.split(separator,howmany)：返回以separator字符串或正则表达式分割的howmany个数的字符串数组，若用””分割则每个字符都会分割 更多对象方法可查看这里 JS Date对象new Date();会自动把当前日期和时间保存为其初始值，可调用对象方法更改Date对象属性Date对象方法： dateObject.getFullYear()/getMonth()/getDate()/getDay()：返回年份/月份(0-11)/日期/星期(0-6) dateObject.getHours()/getMinutes()/getSeconds()：返回小时(0-23)/分钟(0-59)/秒数(0-59) dateObject.getTime()：返回距 1970 年 1 月 1 日之间的毫秒数 dateObject.setFullYear(year,month,day)/setMonth(month,day)/setDate(day)：设置年份/月份/日期 dateObject.toUTCString()/toString()/toDateString()/toTimeString()：将日期转换为UTC世界时/本地时间/日期部分本地时间/时间部分本地时间的字符串 在页面上显示时钟(Date+onload事件)123456789101112131415161718192021&lt;script&gt;function startTime()&#123; var today=new Date(); var h=today.getHours(); var m=today.getMinutes(); var s=today.getSeconds();// 在小于10的数字前加一个‘0’ m=checkTime(m); s=checkTime(s); document.getElementById(&apos;block&apos;).innerHTML=h+&quot;:&quot;+m+&quot;:&quot;+s; t=setTimeout(function()&#123;startTime()&#125;,500);&#125;function checkTime(i)&#123; if (i&lt;10)&#123; i=&quot;0&quot; + i; &#125; return i;&#125;&lt;/script&gt;&lt;body onload=&quot;startTime()&quot;&gt; &lt;div id=&quot;block&quot;&gt;&lt;/div&gt; JS Array对象JS数组可以有三种声明赋值方式 创建数组再一一赋值:1234var cars=new Array();cars[0]=&quot;Saab&quot;;cars[1]=&quot;Volvo&quot;;cars[2]=&quot;BMW&quot;; 创建时就赋值(Condensed Array):使用( )包围1var cars=new Array(&quot;Saab&quot;,&quot;Volvo&quot;,&quot;BMW&quot;); 不创建直接赋值(Literal Array):使用[ ]包围1var cars=[&quot;Saab&quot;,&quot;Volvo&quot;,&quot;BMW&quot;]; 总结：1/2方式在于先创建一个空的多维数组，之后可使用for循环根据需求赋值，3对于枚举数据比较简单易用由于JS的弱检查特性，因此在JS数组中可以同时存储不同类型的变量，比如你可以把数字、字符串、字符、对象等内容放在同一个数组中。 Array对象属性： arrayObject.length：返回数组中元素数目 Array对象方法： arrayObject.concat(arrayX,arrayX,……,arrayX)：连接两个或多个数组，不会改变现有数组而是产生一个新的连接结果数组 arrayObject.join(separator)：把arrayObject中所有元素放入一个字符串以separator分割，默认以，分割 arrayObject.pop()：删除数组最后一个元素并返回元素的值，若数组为空则返回undefined arrayObject.push(newelement1,newelement2,….,newelementX)：向数组末尾增加一个或多个元素并返回新的数组长度 arrayObject.reverse()：将arrayObject数组元素颠倒顺序，会改变原数组 arrayObject.shift()：删除并返回第一个数组元素并返回元素的值，若为空则返回undefined arrayObject.slice(start,end)：返回arrayObject数组中下标从start到end的子数组，不改变原数组，可用负值表示从尾部选取元素 arrayObject.sort(sortby)：以sortby函数对数组排序，若无排序函数则以字符编码的顺序进行排序，排序函数有两个参数ab，若a在b前则返回小于0，a在b后则返回大于0 arrayObject.splice(index,howmany,item1,…..,itemX)：若howmany=0，则向数组中从index开始添加item1,…..,itemX个元素，若howmany&gt;0，则会删除从index开始后howmany个元素并以item1,…..,itemX代替，返回删除的元素数组，会改变原数组 arrayObject.toString()：返回，分割数组元素的字符串 arrayObject.unshift(newelement1,newelement2,….,newelementX)：向数组开头添加一个或多个元素并返回新的长度 JS Math对象Math对象无需创建可静态使用Math对象属性：Math.E(自然底数)/.LN2/.LN10(2/10的自然对数)/.LOG2E/.LOG10E(以2/10为底的e的对数)/.PI(圆周率)/.SQRT1_2/.SQRT2(返回2的平方根的倒数/返回2的平方根)Math对象方法：几乎所有的算数运算都有，详情见这里Math.round(x)：返回x最接近的整数Math.random()：返回0.0-1.0之间的伪随机数 JS RegExp对象RegExp 对象表示正则表达式，直接量语法：/pattern/attributes，创建RegExp对象的语法：new RegExp(pattern, attributes); 参数pattern是一个字符串，指定了正则表达式的模式或其他正则表达式。 参数attributes是一个可选的字符串，包含属性 “g”、”i” 和 “m”，分别用于指定全局匹配、区分大小写的匹配和多行匹配。Tips：pattern是正则表达式，而不是字符串，则必须省略该参数attributes。具体使用可查阅这里","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://harviealwayshere.github.io/tags/JavaScript/"},{"name":"Web前端","slug":"Web前端","permalink":"https://harviealwayshere.github.io/tags/Web前端/"}]},{"title":"JS（三）HTML DOM对象","slug":"js3","date":"2018-02-26T07:49:29.000Z","updated":"2018-02-27T07:57:58.195Z","comments":true,"path":"2018/02/26/js3/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/26/js3/","excerpt":"","text":"JS中若要动态改变页面信息和与用户交互，几乎都要使用HTML DOM对象 HTML DOM对象通过DOM，JS可以创建动态的HTML，如 改变页面中所有HTML元素(改变内容属性等) 改变页面中所有CSS样式 对页面中所有HTML DOM事件作出响应 对页面中所有HTML元素添加删除 JS HTML DOM-查找HTML元素1.使用元素Id(最常用)：document.getElementById(id)2.使用标签名TagName：document.getElementsByTagName(tagName)3.使用类名CalssName：document.getElementsByClassName(className) JS HTML DOM-改变HTML改变HTML输出流：document.write()用于直接向HTML输出流写内容改变HTML内容：通过改变HTML元素的innerHTML属性1document.getElementById(id).innerHTML=newHTML;改变HTML属性：通过改变HTML元素的attribute属性1document.getElementById(id).attribute=newValue; JS HTML DOM-改变CSS改变HTML样式：通过改变HTML元素的style子属性12345//document.getElementById(id).style.property=newValue;document.getElementById(&quot;p1&quot;).style.color=&quot;blue&quot;;document.getElementById(&quot;p1&quot;).style.visibility=&quot;hidden&quot;; //元素隐藏document.getElementById(&quot;p1&quot;).style.visibility=&quot;visible&quot;; //元素显示改变 JS HTML DOM-事件响应我们可以在事件发生时执行JavaScript，如用户点击、移动鼠标、提交HTML表单等。为HTML事件属性添加JS代码：onEvent=JSCodeonEvent(HTML事件属性)： onload/onunload事件：在用户进入或离开页面时被触发，可用于检测访问者浏览器类型和版本用于加载网页的正确版本，可用于处理cookie onchange事件：在用户改变输入字段（文本框的文本，选择框的选项等）被触发，可用于对输入字段的验证检测 onmouseover/onmouseout事件：用户鼠标进入或离开HTML元素时触发 onmousedown/onmouseup/onclick事件：用户点击鼠标/释放鼠标/完成点击HTML元素时被触发 onfocus事件：输入字段获得焦点时被触发更多DOM对象事件可查看这里 JSCode：可以直接JS代码，也可以是JS函数，参数可传递(this) JS HTML DOM-EventListener监听事件addEventListener()用于向指定HTML元素添加事件句柄，新添加的事件句柄不会覆盖已存在的事件句柄，可向一个元素添加多个无论是否是同类型的时间句柄语法：element.addEventListener(event, function, useCapture);event：事件类型，如”click”/“mousedown”，不使用on前缀function：事件触发的回调函数useCapture：布尔值，描述事件是冒泡还是捕获，可选参数 removeEventListener()：用于移除事件的监听语法：element.removeEventListener(event, function);event：移除的事件类型function：移除的回调函数 JS HTML DOM-添加删除HTML元素创建HTML元素：创建该元素（元素节点），然后向一个已存在的元素追加该元素，如12345var element=document.getElementById(&quot;div1&quot;); //找到已存在的元素var para=document.createElement(&quot;p&quot;); //创建新元素var node=document.createTextNode(&quot;这是一个新段落。&quot;); //创建文本节点para.appendChild(node); //为新元素添加文本节点element.appendChild(para); //向已存在的元素添加新元素节点删除HTML元素：找到需要删除的元素和它的父元素才能删除该元素，如123var child=document.getElementById(&quot;p1&quot;); //找到需要删除的元素var parent=document.getElementById(&quot;div1&quot;); //找到需要删除的元素的父元素parent.removeChild(child); //删除元素","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://harviealwayshere.github.io/tags/JavaScript/"},{"name":"Web前端","slug":"Web前端","permalink":"https://harviealwayshere.github.io/tags/Web前端/"}]},{"title":"JS（二）HTML 浏览器BOM对象","slug":"js2","date":"2018-02-26T07:49:15.000Z","updated":"2018-03-02T08:06:08.793Z","comments":true,"path":"2018/02/26/js2/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/26/js2/","excerpt":"","text":"浏览器对象模型（Browser Object Model (BOM)使 JavaScript 有能力与浏览器”对话”。所有浏览器都支持window 对象，它表示浏览器窗口。window对象的成员：所有JavaScript全局对象、函数以及变量window对象的属性：全局变量window对象的方法：全局函数Tips：所有Window对象方法都可以不使用window前缀，直接调用全局方法 Window Screen：包含有关用户屏幕的信息window.screen对象在编写时可以不使用window这个前缀screen对象属性： screen.availWidth：可用的屏幕宽度，以像素计，减去界面特性，比如窗口任务栏 screen.availHeight：可用的屏幕高度，以像素计，减去界面特性，比如窗口任务栏 Window Location：包含URL信息window.location对象用于获得当前页面的地址(URL)，并把浏览器重定向到新的页面location对象属性： location.href：返回当前界面的完整URL，如http://www.w3school.com.cn/js/js_window_location.asp location.hostname：返回web主机的域名， location.pathname：返回URL的路径名，如/js/js_window_location.asp location.port：返回web主机的端口(80或443) location.protocol:返回所使用的web协议（http:// 或 https://） location对象方法： location.assign(URL)：加载新的文档，打开URL地址新界面 location.reload(boolean)：重新加载当前文档，false则会根据文档是否改变决定是否使用缓存加载，true则无论文档是否改变均会会绕过缓存重新加载文档 Window History：包含浏览器历史history对象方法： history.back()：加载历史列表中的前一个URL界面 history.forward()：加载历史列表中的下一个URL界面 Window Navigator：包含有关访问者浏览器的信息由于Navigator信息可被浏览器使用者更改或者浏览器对于测试站点识别错误，所以信息具有误导性，不应该用于检测浏览器版本navigator对象方法： navigator.appCodeName：浏览器代号，如Mozilla navigator.appName：浏览器名称，如Netscape navigator.appVersion：浏览器版本，如Chrome/61.0.3163.100 navigator.cookieEnabled：是否启动启用Cookies，true navigator.platform：硬件平台，如Win32 navigator.userAgent：用户代理，如Mozilla/5.0 navigator.systemLanguage：用户代理语言，如undefined Window PopupAlert:弹窗1.window.alert()：警告框，确保用户得到某些消息，用户需点击确定才能继续操作2.window.confirm(“sometext”);：确认框，验证用户是否接受操作，用户可以点击确认或者取消，相应返回true/false3.window.prompt(“sometext”,”defaultvalue”);：提示框，提示用户需要输入某些值，然后点击确认或者取消，相应返回输入的值/null4.window.open(URL,name,features,replace)：打开一个URL新窗口并可以通过features控制其外观或者利用name查找一个已命名窗口 Window Timing：计时JS中设定一个时间间隔之后来执行代码，我们称之为计时事件，主要使用两个关键方法1.window.setInterval(callback function,milliseconds);：在指定milliseconds毫秒数不断执行callback function回调函数，返回计时器id，可用clearInterval(id)停止计时器2.window.setTimeout(callback function,milliseconds);：在milliseconds毫秒后执行一次callback function回调函数，返回计时器id，可用clearTimeout(id)在函数执行前停止计时器Tips：可使用setTimeout回调自身函数来实现无穷循环Tips：利用setInterval创建一个时钟(每秒钟更新一次时间)123456789&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script&gt;var myVar=setInterval(function()&#123;myTimer()&#125;,1000);function myTimer()&#123; var d=new Date(); var t=d.toLocaleTimeString(); document.getElementById(&quot;demo&quot;).innerHTML=t;&#125;&lt;/script&gt; Window Cookie：存储Web页面用户信息cookie是存储于访问者的计算机中的变量，当web服务器向浏览器发送web页面时，在连接关闭后，服务端不会记录用户的信息，可以利用Cookie记录客户端的用户信息用户信息在Cookie中以键值对的形式存储，如name=key，多个信息可用;分割1.创建Cookie：document.cookie=”username=harvie;expires=”+Date();2.读取Cookie：var x = document.cookie;，以字符串形式返回所有cookie3.删除Cookie：即使Cookie过期，即设置expires属性为以前的时间，如expires=Thu, 01 Jan 1970 00:00:00 GMTTips：我们使用函数设置、获取、检测Cookie123456789101112131415161718192021222324252627282930//设置Cookie（name+exdays）function setCookie(cname,cvalue,exdays)&#123; var d = new Date(); d.setTime(d.getTime()+(exdays*24*60*60*1000)); var expires = &quot;expires=&quot;+d.toGMTString(); document.cookie = cname+&quot;=&quot;+cvalue+&quot;; &quot;+expires;&#125;//获取Cookiefunction getCookie(cname)&#123; var name = cname + &quot;=&quot;; var ca = document.cookie.split(&apos;;&apos;); for(var i=0; i&lt;ca.length; i++) &#123; var c = ca[i].trim(); if (c.indexOf(name)==0) &#123; return c.substring(name.length,c.length); &#125; &#125; return &quot;&quot;;&#125;//检测Cookie(可在页面载入onload时执行checkCookie函数)function checkCookie()&#123; var user=getCookie(&quot;username&quot;); if (user!=&quot;&quot;)&#123; alert(&quot;欢迎 &quot; + user + &quot; 再次访问&quot;); &#125; else &#123; user = prompt(&quot;请输入你的名字:&quot;,&quot;&quot;); if (user!=&quot;&quot; &amp;&amp; user!=null)&#123; setCookie(&quot;username&quot;,user,30); &#125; &#125;&#125;","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://harviealwayshere.github.io/tags/JavaScript/"},{"name":"Web前端","slug":"Web前端","permalink":"https://harviealwayshere.github.io/tags/Web前端/"}]},{"title":"JS（一）基本语法","slug":"js1","date":"2018-02-25T03:28:57.000Z","updated":"2018-02-27T07:57:38.915Z","comments":true,"path":"2018/02/25/js1/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/25/js1/","excerpt":"","text":"JavaScript 是一种轻量级的脚本编程语言，是可插入 HTML 页面的编程代码，几乎可由所有的现代浏览器执行。 JavaScript能做什么？12345678910111213141516171819202122232425262728293031323334353637383940414243//1.直接写入 HTML输出流document.write(&quot;&lt;h1&gt;这是一个标题&lt;/h1&gt;&quot;);//2.对事件的反应函数&lt;button type=&quot;button&quot; onclick=&quot;alert(&apos;欢迎!&apos;)&quot;&gt;点我!&lt;/button&gt;//3.改变HTML内容样式（DOM (Document Object Model)（文档对象模型））&lt;script&gt;function myFunction()&#123; x=document.getElementById(&quot;demo&quot;); // 找到元素 x.innerHTML=&quot;Hello JavaScript!&quot;; // 改变内容 x.style.color=&quot;#ff0000&quot;; // 改变样式&#125;&lt;/script&gt;//4.改变HTML图像&lt;script&gt;function changeImage()&#123; element=document.getElementById(&apos;myimage&apos;) if (element.src.match(&quot;bulbon&quot;)) &#123; element.src=&quot;/images/pic_bulboff.gif&quot;; &#125; else &#123; element.src=&quot;/images/pic_bulbon.gif&quot;; &#125;&#125;&lt;/script&gt;//5.验证输入&lt;script&gt;function myFunction()&#123; var x=document.getElementById(&quot;demo&quot;).value; if(x==&quot;&quot;||isNaN(x)) &#123; alert(&quot;不是数字&quot;); &#125;&#125;&lt;/script&gt; JS用法JS需要被放置在&lt; script&gt;标签内&lt; script&gt;标签可位于或者标签内我们可以直接在&lt; script&gt;标签内编写JS代码或者使用&lt; script src=”xxx.js”&gt;引用外部JS代码Tips：有些老旧的实例可能会在&lt; script&gt;便签中使用type=”text/javascript”，现在已经不必了，因为JS已经是所有现代浏览器和HTML5中默认的脚本语言了 JS输出有不同方式输出，大致有四种1.使用window.alert()弹出警告栏2.使用document.write()将内容写入HTML文档中(页面加载前)3.使用x.innerHTML写入x元素的HTML内容4.使用console.log()写入浏览器的控制台Tips：console.log()用于调试JS是十分方便的，因为它可以显示结构化的数据，如Array、Object可以看到数组和对象的内容，而且不会打断页面操作，页面可以继续执行接下来的操作 JS语法JS字面量：固定值，如 数字(Number)：整数小数科学计数，314,3.14,123e5** 字符串(String)：单引号双引号字符，’Harvie’,”Harvie” 表达式字面量：带运算符，5+6，5*6 数组(Array)：[40,50,60] 对象(Object)：{firstName:”Harvie”,lastName:”Ryan”,age:50} 函数(function)：function myfunction(a,b){return a*b} JS变量：存储数据值，使用关键字var声明变量，使用=为变量赋值 JS操作符：分为赋值/算数/位运算符(=,+,-,*,/)和条件/比较/逻辑运算符(==,!=,&lt;,&gt;) JS语句：向浏览器发出命令，用;(分号)分隔 JS注释：不是命令的语句，用//(双斜杠)分隔 JS数据类型：数字、字符串、数组、对象等，使用相应的字面量赋值，是弱类型的，都是通过var声明 JS大小写和字符集：JS对于大小写敏感，使用Unicode字符集 JS语句JavaScript语句通常以一个语句标识符为开始，并执行该语句，如下。 JS注释//…单行注释，/…/多行注释，…//行末注释 JS变量变量是用于存储信息的”容器”，可以使用短名称(x,y)，也可以使用描述性名称(age,num),但是要符合一下规则Tips：如果重新声明 JavaScript 变量，该变量的值不会丢失，如var x=1;var x;，x的值仍为1Tips：let变量，作用域被限制在块级中的变量、语句或者表达式，在Function中局部变量使用let变量可避免变量名冲突，var变量作用域是整个封闭函数1234567891011121314151617function varTest() &#123; var x = 1; if (true) &#123; var x = 2; // 同样的变量 console.log(x); //2 &#125; console.log(x); // 2&#125;function letTest() &#123; let x = 1; if (true) &#123; let x = 2; // 不同的变量 console.log(x); // 2 &#125; console.log(x); // 1&#125; JS数据类型JS拥有动态类型，声明的变量类型均为弱类型，可随意切换，如1var x; x=1; x=&quot;HARVIE&quot;; x=[1,2,3];JS字符串中使用单引号和双引号需要使用+引号，如1var x=&quot;His name is \\&quot;Harvie\\&quot;&quot;;JS只有一种数字类型，可以带小数点，可以使用科学计数(e)，如1var x=314; x=3.14; x=314e-2;JS布尔类型只有两个值，true或者false1var x=true; var y=false; JS对象和数组：详情见博文JS（二）JS空类型Undefined表示变量不含有值，如变量刚声明时为UndefinedNull表示变量为空，可通过将变量的值设为null来清空变量 JS函数由事件驱动的或者当它被调用时执行的可重复使用的，使用关键词function，包裹在{ }中的代码块 JS作用域局部作用域：变量在函数内声明，变量为局部作用域，只能在函数内部访问全局作用域：变量在函数外声明即为全局变量，若变量在函数内没有声明(没有使用var关键字)，该变量自动升级为全局变量HTML中的全局变量：在HTML中，所有全局变量都属于window对象，都可以使用window.变量名访问let关键字变量：可将变量作用域限制在当前代码块中const关键字变量：所声明的是常量，其值不可以更改 JS字符串用于存储一系列字符，用单引号或双引号包裹可以在字符串中添加转义字符来使用引号等符号，如var x = ‘It\\’s alright’;可以使用内置属性length来计算字符串长度，如x.length;更多字符串方法可以看这里 JS条件语句 JS循环语句介绍一下For/In循环，主要用来遍历对象的属性(name+value)，如12345var Person=&#123;firstName:&quot;John&quot;, lastName:&quot;Doe&quot;, id:5566&#125;;var txt=&quot;&quot;;for (x in Person)&#123; txt=txt+x+&quot;=&gt;&quot;+Person[x]+&quot;\\n&quot;;&#125; JS typeof操作符typeof操作符：用于检测变量的数据类型，如typeof x，返回x的数据类型null：JS中一个只有一个值的数据类型，表示一个空对象的引用，typeof null为object，可以将对象设为null来清空对象undefined：JS中一个没有设置值的变量，typeof undefined为undefined，可以将任何变量设置为undefined来清空变量Tips：instanceof用于判断对象具体类型，如var result = objectName instanceof objectType，若objectName属于ObjectType类型则返回true，否则返回false JS类型转换JS有5种数据类型：string/number/boolean/object/function3种对象类型：Object/Date/Array2个不包含任何值的类型：null/undefinedTips:NaN指示该值不是数字值，某些算数运算(如求负数平方根)结果或者类型转换结果(parseInt()/parseFloat())，可用isNaN()判断一个值是否是NaN值Tips:数组Array/日期Date/null的数据类型均是object 变量的constructor属性：返回所有JS变量的构造函数，可用来判断对象是否为数组、日期，如123456function isArray(myArray) &#123; return myArray.constructor.toString().indexOf(&quot;Array&quot;) &gt; -1;&#125;function isDate(myDate) &#123; return myDate.constructor.toString().indexOf(&quot;Date&quot;) &gt; -1;&#125; JS变量的类型转换：有2种方法，1.通过使用JS函数，2.通过JS的自身自动转换JS函数：全局方法String()可将变量转为字符串，如Srting(123)/String(false)/String(new Date())全局方法Number()可将变量转为数字，如Number(“3.14”)/Number(“99 88”)=&gt;返回NaN/Number(new Date())全局方法parseFloat()/parseInt()将字符串转为一个浮点数/整数自动转换:一元运算符+：自动统一表达式两边变量类型转换成同一数据类型.innerHTML：输出一个对象或者变量时，JS会自动调用该变量的toString()方法，将改变量转换成String JS正则表达式正则表达式是使用字符串来描述、匹配一系列符合某个句法规则的字符串搜索模式，可用于文本搜索和文本替换JS正则语法格式：/正则表达式主体/修饰符(可选)修饰符：i=&gt;对大小不敏感，g=&gt;全局匹配，m=&gt;多行匹配字符串方法使用正则：1.serach()：检索字符串中指定的子字符串，若匹配则返回子串的起始位置2.replace()：用于在字符串中用一些字符替换另一些字符RegExp对象使用正则：1.test()方法用于检测一个字符串是否匹配某个模式，若字符串中含有匹配的文本，则返回true，否则返回false，如1234567891011121314151617181920212223242526272829/*是否带有小数*/function isDecimal(strValue ) &#123; var objRegExp= /^\\d+\\.\\d+$/; return objRegExp.test(strValue); &#125; /*校验是否中文名称组成 */function ischina(str) &#123; var reg=/^[\\u4E00-\\u9FA5]&#123;2,4&#125;$/; /*定义验证表达式*/ return reg.test(str); /*进行验证*/&#125;/*校验是否全由8位数字组成 */function isStudentNo(str) &#123; var reg=/^[0-9]&#123;8&#125;$/; /*定义验证表达式*/ return reg.test(str); /*进行验证*/&#125;/*校验电话码格式 */function isTelCode(str) &#123; var reg= /^((0\\d&#123;2,3&#125;-\\d&#123;7,8&#125;)|(1[3584]\\d&#123;9&#125;))$/; return reg.test(str);&#125;/*校验邮件地址是否合法 */function IsEmail(str) &#123; var reg=/^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+(\\.[a-zA-Z0-9_-])+/; return reg.test(str);&#125;2.exec()方法用于检索字符串中正则表达式的匹配，若找到匹配的结果则返回一个数组存放，若未找到则返回null JS错误try语句测试代码块的错误catch语句处理错误（系统发现的错误）throw语句创建或抛出异常(自己发现的错误)语法：1234567try &#123; //在这里运行代码 if(x==y) throw &quot;error!&quot;;&#125; catch(err) &#123; //在这里处理错误，如 alert(err.message);&#125; JS调试1.console.log()方法：在浏览器控制台打印关键信息2.debugger关键字：设置断点调试，如var x=1;debugger;var y=1; JS变量提升(Hoisting)JS中，函数及变量的声明都将被提升到函数的最顶部，因此变量可以在使用后声明。但是只有声明的变量会提升，初始化的变量不会提升 JS严格模式(Strict Mode)使用命令“use strict”;进入严格模式，可以消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为，1.增加代码安全性，2.提高编译器效率，3.为未来新版本的JS做好铺垫 JS表单验证1.表单事件验证：可以利用表单的onsubmit事件，在表单提交时被触发，执行验证函数，验证表单数据，若为return false则可阻止表单提交获取表单的数据可用document.forms[“formName”][“valueName”].value;获取表单数据如非空验证1234567891011121314&lt;form name=&quot;myForm&quot; action=&quot;demo_form.php&quot;onsubmit=&quot;return validateForm()&quot; method=&quot;post&quot;&gt;名字: &lt;input type=&quot;text&quot; name=&quot;fname&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;script&gt;function validateForm() &#123; var x = document.forms[&quot;myForm&quot;][&quot;fname&quot;].value; if (x == null || x == &quot;&quot;) &#123; alert(&quot;需要输入名字。&quot;); return false; &#125;&#125;&lt;/script&gt;如E-mail验证(必须包含@符号和点号(.)/@不可以是邮件地址的首字符/@后至少一个点号)1234567891011&lt;script&gt;function validateForm()&#123; var x=document.forms[&quot;myForm&quot;][&quot;email&quot;].value; var atpos=x.indexOf(&quot;@&quot;); var dotpos=x.lastIndexOf(&quot;.&quot;); if (atpos&lt;1 || dotpos&lt;atpos+2 || dotpos+2&gt;=x.length)&#123; alert(&quot;不是一个有效的 e-mail 地址&quot;); return false; &#125;&#125;&lt;/script&gt; 2.HTML约束验证：可在HTML元素中直接增加约束，如required=”required”/disabled/pattern/max/min/type等详情可见这里 3.服务器端数据验证：数据提交到服务器后再验证 JS JSONJSON全称JavaScript Object Notation，轻量级存储和传输数据的格式，通常用于服务端向网页传递数据。JSON格式：1.数据为键值对(“key”:”value”)，由逗号分隔，如”name”:”Runoob”2.大括号{}保存对象，{“name”:”Runoob”, “url”:”www.runoob.com”}3.方括号[]保存数组，数组中可保存对象，如 JSON字符串转换为JS对象：我们从服务器中接收JSON数据并利用JSON.parse(text[, reviver])将JSON字符串转换为JS对象，reviver为转换结果函数将会调用对象的每个成员，如function(k,v)1234567var text = &apos;&#123; &quot;sites&quot; : [&apos; + &apos;&#123; &quot;name&quot;:&quot;Runoob&quot; , &quot;url&quot;:&quot;www.runoob.com&quot; &#125;,&apos; + &apos;&#123; &quot;name&quot;:&quot;Google&quot; , &quot;url&quot;:&quot;www.google.com&quot; &#125;,&apos; + &apos;&#123; &quot;name&quot;:&quot;Taobao&quot; , &quot;url&quot;:&quot;www.taobao.com&quot; &#125; ]&#125;&apos;;JSObj = JSON.parse(text);// JSObj.sites[1].name =&gt; Google// JSObj.sites[1].url =&gt; www.google.com JS对象转换为JSON字符串：我们可以使用JSON.stringify(value[, replacer[, space]])方法将JS对象转换为JSON字符串传递给服务器，space可为文本添加缩进、空格、换行符，如int i则添加i个空格缩进，若为\\t则添加制表符12var str = &#123;&quot;name&quot;:&quot;菜鸟教程&quot;, &quot;site&quot;:&quot;http://www.runoob.com&quot;&#125;;str_pretty1 = JSON.stringify(str); //&#123;&quot;name&quot;:&quot;菜鸟教程&quot;,&quot;site&quot;:&quot;http://www.runoob.com&quot;&#125; JS死链接我们经常看到href=”javascript:void(0)”，表示点击这个链接是不会发生任何跳转的链接void()方法表示不返回任何值，void()中的语句会执行但是返回的结果不会被void传递到函数外部 href=”#”表示定位到#位置，#包含了一个位置信息，默认的锚#top也就是网页的上端，可用#+id定位到页面的具体位置 JS函数自调用函数：(function(){})();表示这是一个自调用函数，运行至脚本处会自动触发调用全局对象：若函数没有被自身的对象调用时，this的值会变成全局对象，web浏览器中全局对象是浏览器窗口(window对象)对象方法调用函数：函数可作为对象的方法被调用，如var x = {y:function(){ return 0;}}，可通过x.y()调用函数构造函数调用函数：函数调用使用new关键字则调用了构造函数，创建了新的对象，如function y(){this.z=1;};var x= new y();，则x为一个对象{“z” : 1} JS闭包计数器困境：若计数器为全局变量，则除了add()计数函数外其他所有函数也可以访问计数器变量，不安全；若计数器变量在add()计数函数内声明并初始化为0，则每次调用add()函数就都会初始化变量失去了计数功能闭包：父函数内嵌函数会持有父方法的局部变量并且不会随父方法销毁而销毁，就是说即便父函数已经执行完了但是里面的变量被赋给了别的变量，这个变量并不会随着父函数的调用结束而消失12345678910&lt;script&gt;var add = (function () &#123; var counter = 0; return function () &#123;return counter += 1;&#125;&#125;)();&lt;/script&gt;//利用自调用函数，执行一次申明并初始化变量counter的过程之后返回一个匿名函数给add，这样add就变成了一个函数add()&#123;return counter +=1;&#125;这个函数持有父函数的变量counter但是即便父函数执行结束后counter并没有被销毁因此每次执行add()，都会使counter++，也仅有执行add()才能调用到counter变量，保证了变量的私有性","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://harviealwayshere.github.io/tags/JavaScript/"},{"name":"Web前端","slug":"Web前端","permalink":"https://harviealwayshere.github.io/tags/Web前端/"}]},{"title":"Swoole(十六)实现一个长连接的网络聊天室","slug":"swoole16","date":"2018-02-21T11:09:56.000Z","updated":"2018-02-22T10:19:50.016Z","comments":true,"path":"2018/02/21/swoole16/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/21/swoole16/","excerpt":"","text":"这次我们首先一个类似IM的网络聊天室，服务器端使用websocket，客户端使用JS连接。 1.Websocket服务器首先将服务器端代码写好1234567891011121314151617181920212223242526272829303132333435363738&lt;?php//创建Websocket服务器$ws = new swoole_websocket_server(&quot;0.0.0.0&quot;, 9501);//on监听事件函数 open/message/close$ws-&gt;on(&apos;open&apos;, function ($ws, $request) &#123; echo &quot;user&quot;.$request-&gt;fd.&quot;in\\n&quot;; //将新用户存在全局变量里 $GLOBALS[&apos;fd&apos;][$request-&gt;fd][&apos;id&apos;] = $request-&gt;fd; $GLOBALS[&apos;fd&apos;][$request-&gt;fd][&apos;name&apos;] = &quot;noName&quot;;&#125;);$ws-&gt;on(&apos;message&apos;, function ($ws, $request) &#123; //若接受的数据中含#name# 则为设置用户名 if(strstr($request-&gt;data, &quot;#name#&quot;))&#123; //将接受到的数据中的#name#替换成空白后存入相应的全局变量中 $GLOBALS[&apos;fd&apos;][$request-&gt;fd][&apos;name&apos;] = str_replace(&quot;#name#&quot;, &apos;&apos;, $request-&gt;data); &#125;else&#123;//若接受的数据中不含#name#, 则为用户发送消息 //编辑消息格式 $msg = $GLOBALS[&apos;fd&apos;][$request-&gt;fd][&apos;name&apos;].&quot;:&quot;.$request-&gt;data.&quot;\\n&quot;; //向所连接的每个客户端发送消息 foreach ($GLOBALS[&apos;fd&apos;] as $client) &#123; //使用push推送消息 $ws-&gt;push($client[&apos;id&apos;],$msg); &#125; &#125;&#125;);$ws-&gt;on(&apos;close&apos;, function ($ws, $request) &#123; echo &quot;user&quot;.$request-&gt;fd.&quot;out\\n&quot;; //删除用户信息 unset( $GLOBALS[&apos;fd&apos;][$request-&gt;fd]);&#125;);//启动服务器$ws-&gt;start(); 2.配置LAMP环境LP我们已经具备了，现在配置AM环境2.1 安装Apache查询是否有Apache安装包：yum list httpd若有直接安装（如我的有x86_64版本的）:yum install httpd.x86_64若没有则使用yum安装Apache：yum -y install httpd设置开机启动：chkconfig –levels 235 httpd on启动Apache：service httpd start(重启Apache：service httpd restart)查询Apache是否启动：ps -ef|grep httpd [Apache默认网站目录/var/www/html]测试是否访问正常：cd /var/www/html/vim index.php&lt;?php phpinfo();?&gt;此时可访问localhost或者使用外网IP访问，出现phpinfo信息则正常 2.2 安装Mysql由于CentOS7默认是安装Maridb，但是不用担心，因为Maridb是mysql的一个分支且支持任何mysql语句，所以我们安装maridb，命令和操作都照常使用mysql的就可以拉，具体maridb和mysql的渊源可以看看知乎这里安装Maridb：yum install -y mariadb-server启动Maridb： service mariadb start（停止和重启服务是 service+服务名+stop/restart）查询是否启动：ps -ef|grep mariadb （此时可查询mysql服务，也可以查询出结果）设置开启启动：chkconfig –levels 235 mariadb on设置root账户密码：mysql_secure_installationTips:一开始提示输入原密码直接回车就好，因为原密码为空，然后输入新密码，之后一直y即可登录mariadb：mysql -u root -p (输入刚才设定的密码即可) 2.3 安装phpmyadmin远程管理数据库安装phpmyadmin：yum install phomyadmin由于默认情况下CentOS7上的phpmyadmin只允许从本地访问，因此我们需要修改phpmyadmin的配置phpMyAdmin默认配置目录为/etc/httpd/conf.d/phpMyAdmin.conf然后将限制ip访问的改成允许(共有4条语句要注释，增加两条Require all granted语句)，如下详情可点击这里查看之后输入IP地址/phpmyadmin即可远程登录数据库管理在开发环境想不用频繁登录phpmyadmin可以在/etc/phpMyAdmin/config.inc.php中修改登录模式，有自动登录模式，详情可查看这里 3.客户端实现客户端代码就十分简易，功能大概就是检验是否连接、设置昵称和发送消息12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;IM聊天室&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;msg&quot;&gt;&lt;/div&gt; &lt;input type=&quot;text&quot; id=&quot;text&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;发送数据&quot; onclick=&quot;send()&quot;&gt;&lt;/body&gt;&lt;script&gt; var msg = document.getElementById(&quot;msg&quot;); var connectIp = &apos;ws://39.108.210.229:9501&apos;; //调用websocket对象建立连接： //参数：ws/wss(加密)：//ip:port （字符串） var websocket = new WebSocket(connectIp); //onopen监听连接打开 websocket.onopen = function (evt) &#123; //websocket.readyState 属性： /* CONNECTING 0 The connection is not yet open. OPEN 1 The connection is open and ready to communicate. CLOSING 2 The connection is in the process of closing. CLOSED 3 The connection is closed or couldn&apos;t be opened. */ if(websocket.readyState == 1) &#123; msg.innerHTML=&quot;连接成功!&lt;br&gt;可使用&apos;#name#+您的昵称&apos;设置昵称&lt;br&gt;&quot;; &#125; //msg.innerHTML = websocket.readyState; &#125;; function send()&#123; var text = document.getElementById(&apos;text&apos;).value; document.getElementById(&apos;text&apos;).value = &apos;&apos;; //向服务器发送数据 websocket.send(text); &#125; //监听连接关闭// websocket.onclose = function (evt) &#123;// console.log(&quot;Disconnected&quot;);// &#125;; //onmessage 监听服务器数据推送 websocket.onmessage = function (evt) &#123; msg.innerHTML += evt.data +&apos;&lt;br&gt;&apos;;// console.log(&apos;Retrieved data from server: &apos; + evt.data); &#125;;//监听连接错误信息// websocket.onerror = function (evt, e) &#123;// console.log(&apos;Error occured: &apos; + evt.data);// &#125;;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;上传到服务器端的网页目录[/var/www/html]，之后运行服务器端代码，之后随意用任意浏览器访问客户端页面[ip/xxx.html]即可，具体效果如下，运行服务器脚本后当浏览器两个请求访问时可以看到两个用户加入了，然后我们可以设置昵称开始发送消息，每个客户端发送的消息到服务器端都会被服务器端推送至每个客户端","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"php项目","slug":"php项目","permalink":"https://harviealwayshere.github.io/tags/php项目/"},{"name":"swoole","slug":"swoole","permalink":"https://harviealwayshere.github.io/tags/swoole/"}]},{"title":"Swoole(十五)异步文件写入","slug":"swoole15","date":"2018-02-20T10:17:56.000Z","updated":"2018-02-21T09:01:56.087Z","comments":true,"path":"2018/02/20/swoole15/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/20/swoole15/","excerpt":"","text":"Swoole增加了异步文件读写，异步DNS，异步Http/WebSocket客户端等特性。开发纯异步非阻塞IO的程序时，不能使用PHP自带的网络客户端，如curl、file_get_contents、stream、sockets、mysql、redis。 1.(小文件)异步写文件：swoole_async_writefile提供了两种风格函数风格：swoole_async_writefile($filename, $fileContent, function($filename){}, $flags = 0);面向对象风格：Swoole\\Async::writeFile(string $filename, string $fileContent, callable $callback = null, int $flags = 0)$filename：文件名称，须有可写权限，文件不存在会自动创建，打开文件失败会返回false$fileContent：写入文件的内容，最大可写入4M$callback：写入成功的回调函数，可选flags：写入选项，可以使用FILE_APPEND表示追加到文件末尾Tips：Linux原生异步IO不支持FILE_APPEND，并且写入的内容长度必须为4096的整数倍，否则底层会自动在末尾填充0 2.(大文件)异步写文件：swoole_async_write函数原型：bool swoole_async_write(string $filename, string $content, int $offset = -1, mixed $callback = NULL);$filename：文件名称$content：写入文件的内容，因为是分段写入，所以无限制$offset：写入方式，-1为追加写入到文件末尾$callback：写入成功的回调函数，可选swoole_async_write是分段写的。不需要一次性将要写的内容放到内存里，所以只占用少量内存。swoole_async_write通过传入的offset参数来确定写入的位置。 3.两种写入方式测试将脚本上传到服务器运行可以看到我们用vim打开写入的文件看看内容可以看到由于是异步写入，write比writeFile2的写入还要早执行，但是三个写入函数都执行成功了，一个是直接写入，一个是追加写入，还有一个是大文件的写入","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"php项目","slug":"php项目","permalink":"https://harviealwayshere.github.io/tags/php项目/"},{"name":"swoole","slug":"swoole","permalink":"https://harviealwayshere.github.io/tags/swoole/"}]},{"title":"Swoole(十四)异步文件读取","slug":"swoole14","date":"2018-02-20T10:17:51.000Z","updated":"2018-02-21T08:27:33.779Z","comments":true,"path":"2018/02/20/swoole14/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/20/swoole14/","excerpt":"","text":"Swoole增加了异步文件读写，异步DNS，异步Http/WebSocket客户端等特性。开发纯异步非阻塞IO的程序时，不能使用PHP自带的网络客户端，如curl、file_get_contents、stream、sockets、mysql、redis。 1.(小文件)异步读取文件内容：swoole_async_readfile提供了两种风格函数风格：swoole_async_readfile(string $filename, mixed $callback);面向对象风格：Swoole\\Async::readFile(string $filename, mixed $callback);$filename：路径下的文件名$callback：由于是异步非阻塞，数据读取完毕后会立即调用指定的回调函数Tips：swoole_async_readfile会将文件内容全部复制到内存，所以不能用于大文件的读取如果要读取超大文件，请使用swoole_async_read函数 2.(大文件)异步读取文件内容：swoole_async_read函数原型：bool swoole_async_read(string $filename, mixed $callback, int $size = 8192, int $offset = 0);$filename：路径下的文件名$callback：回调函数接受两个参数bool callback(string $filename, string $content);，$filename-文件名称，$content-读取到的分段内容，如果内容为空，表明文件已读完，在回调函数中可通过return true/false，来控制继续读下一段内容/停止读取并关闭文件。$size：读取的分段内容的大小，单位字节Tips：此函数与swoole_async_readfile不同，它是分段读取，可以用于读取超大文件。每次只读$size个字节，不会占用太多内存。 3.两种读取方式测试123456789101112131415161718192021&lt;?phpecho &quot;swoole_async_readfile \\n&quot;;//readFile读取swoole_async_readfile(__DIR__.&quot;/testFile.txt&quot;, function($filename, $content) &#123; echo &quot;swoole_async_readfile-[$filename] : $content \\n&quot;;&#125;);echo &quot;swoole_async_read \\n&quot;;//read读取swoole_async_read(__DIR__.&quot;/testFile.txt&quot;, function($filename, $content) &#123; if($content)&#123; echo &quot;swoole_async_read-[$filename] : $content \\n&quot;; return true; &#125;else&#123; return false; &#125; &#125;); 上传脚本和测试文本到服务器可以看到由于是异步读取，两个echo都在文件读取之前输出出来了，之后就是两个文件读取内容的打印","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"php项目","slug":"php项目","permalink":"https://harviealwayshere.github.io/tags/php项目/"},{"name":"swoole","slug":"swoole","permalink":"https://harviealwayshere.github.io/tags/swoole/"}]},{"title":"Swoole(十三)DNS查询","slug":"swoole13","date":"2018-02-20T10:17:48.000Z","updated":"2018-02-21T07:16:18.752Z","comments":true,"path":"2018/02/20/swoole13/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/20/swoole13/","excerpt":"","text":"Swoole有(异步)DNS查询功能(我也不知道为什么集成了) 1.（异步）将域名解析为IP地址：swoole_async_dns_lookup函数原型：swoole_async_dns_lookup($domainName,callback function($host,$ip){});$domainName：传入的域名DNS查询完成：自动回调指定的callback函数。DNS查询失败：比如域名不存在，回调函数传入的$ip为空调用此函数是非阻塞的，调用会立即返回。将向下执行后面的代码。 2.执行DNS查询123swoole_async_dns_lookup(&quot;www.baidu.com&quot;, function($host, $ip)&#123; echo &quot;&#123;$host&#125; : &#123;$ip&#125;\\n&quot;;&#125;); 脚本在服务器运行，可以看到执行成功","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"php项目","slug":"php项目","permalink":"https://harviealwayshere.github.io/tags/php项目/"},{"name":"swoole","slug":"swoole","permalink":"https://harviealwayshere.github.io/tags/swoole/"}]},{"title":"Swoole(十二)锁机制","slug":"swoole12","date":"2018-02-20T10:17:41.000Z","updated":"2018-02-20T17:41:02.115Z","comments":true,"path":"2018/02/20/swoole12/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/20/swoole12/","excerpt":"","text":"Swoole针对内存的其他提供了一系列的锁机制swoole_lock类支持5种锁的类型： 文件锁 SWOOLE_FILELOCK 读写锁 SWOOLE_RWLOCK 信号量 SWOOLE_SEM 互斥锁 SWOOLE_MUTEX 自旋锁 SWOOLE_SPINLOCKTips：之前学习单例模式算法的时候，为了防止两个进程创建两个单例，就需要使用锁机制，C++/C#有private static object syncObj = new object();，JAVA中有synchronized(Singleton2.class){}，没想到PHP也有Swoole扩展的锁机制。 1.创建锁对象：$lock = new swoole_lock();函数原型：swoole_lock-&gt;__construct(int $type, [string $lockfile]);$type：锁的类型，具体为以上五种锁$lockfile：当类型为SWOOLE_FILELOCK(文件锁)时必须传入，指定文件锁的路径注意每一种类型的锁支持的方法都不一样，如读写锁、文件锁可以支持$lock-&gt;lock_read()。另外除文件锁外，其他类型的锁必须在父进程内创建，这样fork出的子进程之间才可以互相争抢锁。 2.加锁：swoole_lock-&gt;lock函数原型：bool $lock-&gt;lock();如果有其他进程持有锁，那这里将进入阻塞，直到持有锁的进程unlock。 3.释放锁：swoole_lock-&gt;unlock函数原型：bool $lock-&gt;unlock();解锁成功返回true。 4.创建一个互斥锁并通过主进程和子进程演示123456789101112131415161718192021222324&lt;?php//创建锁对象（互斥锁）$lock = new swoole_lock(SWOOLE_MUTEX);echo &quot;[Master]create mutex lock\\n&quot;;//主进程 加锁$lock-&gt;lock();//创建子进程if(pcntl_fork() &gt; 0)&#123; //创建成功则主进程解锁 sleep(1); $lock-&gt;unlock();&#125;else&#123; //创建失败则子进程等待主进程解锁后子进程再加锁进行自身的操作 echo &quot;[Child] Wait Lock\\n&quot;; $lock-&gt;lock(); echo &quot;[Child] Get Lock\\n&quot;; $lock-&gt;unlock(); exit(&quot;[Child] exit\\n&quot;);&#125;echo &quot;[Master]release lock\\n&quot;;unset($lock);sleep(1);echo &quot;[Master]exit\\n&quot;; 运行脚本在服务器上，可以看到首先主进程创建互斥锁并上锁(create mutex lock)此时子进程创建失败只能等待(wait lock)等到主进程释放锁(release lock)主进程释放锁后，子进程首先加锁(get lock)之后子进程做自己的事情，完成后解锁退出(exit)此时主进程再退出(exit)","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"php项目","slug":"php项目","permalink":"https://harviealwayshere.github.io/tags/php项目/"},{"name":"swoole","slug":"swoole","permalink":"https://harviealwayshere.github.io/tags/swoole/"}]},{"title":"Swoole(十一)进程信号触发器","slug":"swoole11","date":"2018-02-20T09:29:28.000Z","updated":"2018-02-21T11:21:50.053Z","comments":true,"path":"2018/02/20/swoole11/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/20/swoole11/","excerpt":"","text":"Swoole具备进程管理模块，用来代替PHP的pcntl拓展。1.设置异步信号监听：swoole_process::signal函数原型：bool swoole_process::signal(int $signo, callable $callback);此方法基于signalfd和eventloop是异步IO，不能用于同步程序中同步阻塞的程序可以使用pcntl扩展提供的pcntl_signal$callback如果为null，表示移除信号监听 如果已设置了此信号的回调函数，重新设置时会覆盖历史设置2.高精度定时器：swoole_process::alarm高精度定时器，是操作系统setitimer系统调用的封装，可以设置微秒级别的定时器。定时器会触发信号，需要与swoole_process::signal（异步）或pcntl_signal（同步）配合使用。函数原型：function swoole_process::alarm(int $interval_usec, int $type = ITIMER_REAL) : bool$interval_usec：定时器间隔时间，单位为微秒。如果为负数表示清除定时器$type：定时器类型 0 表示为真实时间,触发SIGALAM信号 1 表示用户态CPU时间，触发SIGVTALAM信号 2 表示用户态+内核态时间，触发SIGPROF信号 3.创建定时器及信号监听函数12345678910111213141516&lt;?php//触发函数 异步执行 达到条件停止swoole_process::signal(SIGALRM,function()&#123; //计时器 用于停止定时器触发信号 static $i=0; echo &quot;hello!\\n&quot;; $i++; if($i&gt;10)&#123; //触发十次 清除定时器 swoole_process::alarm(-1); &#125;&#125;);//定时信号swoole_process::alarm(100*1000); 将脚本上传至服务器并运行，可以看到成功发送了10次信号并触发后清除定时器停止程序","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"php项目","slug":"php项目","permalink":"https://harviealwayshere.github.io/tags/php项目/"},{"name":"swoole","slug":"swoole","permalink":"https://harviealwayshere.github.io/tags/swoole/"}]},{"title":"Swoole(十)进程队列通信","slug":"swoole10","date":"2018-02-20T09:25:28.000Z","updated":"2018-02-20T10:16:51.686Z","comments":true,"path":"2018/02/20/swoole10/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/20/swoole10/","excerpt":"","text":"Swoole具备进程管理模块，用来代替PHP的pcntl拓展。 1.投递数据到消息队列：swoole_process-&gt;push函数原型：bool swoole_process-&gt;push(string $data);$data：投递的数据，长度受限与操作系统内核参数的限制。默认为8192，最大不超过65536默认模式下（阻塞模式）：队列已满，push方法会阻塞等待非阻塞模式下：队列已满，push方法会立即返回false 2.从队列中提取数据：swoole_process-&gt;pop函数原型：string swoole_process-&gt;pop(int $maxsize = 8192);$maxsize：表示获取数据的最大尺寸，默认为8192操作成功会返回提取到的数据内容，失败返回false默认模式下：队列中没有数据，pop方法会阻塞等待非阻塞模式下：队列中没有数据，pop方法会立即返回false，并设置错误码为ENOMSG 3.回收结束运行的子进程：swoole_process::wait子进程结束必须要执行wait进行回收，否则子进程会变成僵尸进程函数原型：array(‘code’ =&gt; 0, ‘pid’ =&gt; 15001, ‘signal’ =&gt; 15) swoole_process::wait(bool $blocking = true);$blocking：可以指定是否阻塞等待，默认为阻塞操作成功会返回一个数组包含子进程的PID、退出状态码、被哪种信号KILL如果在异步信号回调中执行wait123456swoole_process::signal(SIGCHLD, function($sig) &#123; //必须循环执行wait直到返回false while($ret = swoole_process::wait(false)) &#123; echo &quot;PID=&#123;$ret[&apos;pid&apos;]&#125;\\n&quot;; &#125;&#125;); 4.启用消息队列作为进程间通信：swoole_process-&gt;useQueue函数原型：bool swoole_process-&gt;useQueue(int $msgkey = 0, int $mode = 2);$msgkey：消息队列的key，默认会使用ftok(FILE, 1)作为KEY$mode：通信模式，默认为2，表示争抢模式，所有创建的子进程都会从队列中取数据 5.退出子进程：swoole_process-&gt;exit函数原型：int swoole_process-&gt;exit(int $status=0);$status是退出进程的状态码，如果为0表示正常结束，会继续执行PHP的shutdown_function，其他扩展的清理工作。$status不为0，表示异常退出，会立即终止进程。不再执行PHP的shutdown_function，其他扩展的清理工作。在父进程中，执行swoole_process::wait可以得到子进程退出的事件和状态码。 6.创建进程队列并通信123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?php//进程池 存储进程$workers = []; //进程数量$worker_num = 2;//创建并启动进程for($i=0;$i&lt;$worker_num;$i++)&#123; //创建新进程，注意第三个参数为false，不启动pipe通信 $process = new swoole_process(&apos;doProcess&apos;,false,false); //启用消息队列作为进程间通信 $process-&gt;useQueue(); $pid = $process-&gt;start(); //启动进程并获取进程ID $workers[$pid] = $process; //将进程存入进程池&#125;//编写进程执行函数function doProcess(swoole_process $worker)&#123; //从主进程(master)中获取数据 $recv = $worker-&gt;pop(); echo &quot;Worker(&quot;.$worker-&gt;pid.&quot;)From Master: &quot;.$recv.&quot;\\n&quot;; sleep(2); //退出子进程 0表示正常结束 $worker-&gt;exit(0);&#125;//主进程向子进程添加数据foreach ($workers as $process) &#123; $process-&gt;push(&quot;hello worker[&quot;.$process-&gt;pid.&quot;]\\n&quot;);&#125;//等待子进程结束回收资源for($i = 0; $i &lt; $worker_num; $i++)&#123; //等待执行完成 $ret = swoole_process::wait(); $pid = $ret[&apos;pid&apos;]; //释放进程池中的进程资源 unset($workers[$pid]); echo &quot;Worker Exit, PID=&quot;.$pid.PHP_EOL;&#125; 将PHP脚本上传至服务器并运行，可以看到进程确实pop到了主进程push的数据，但是不知道为什么主进程push数据的时候识别的子进程的ID打印出来是错误的，可以看到子进程的PID分别是9922和9921，回收进程时也是这两个ID，可是接收到主进程push的数据时的PID确实9918和9919","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"php项目","slug":"php项目","permalink":"https://harviealwayshere.github.io/tags/php项目/"},{"name":"swoole","slug":"swoole","permalink":"https://harviealwayshere.github.io/tags/swoole/"}]},{"title":"Swoole(九)同步/异步进程","slug":"swoole9","date":"2018-02-19T09:40:20.000Z","updated":"2018-02-20T09:36:35.836Z","comments":true,"path":"2018/02/19/swoole9/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/19/swoole9/","excerpt":"","text":"Swoole具备进程管理模块，用来代替PHP的pcntl拓展。Process进程是系统中十分昂贵的资源，创建进程消耗很大，可以使用vmstat指令查看系统每秒进程切换次数 1.PHP自带pcntl拓展存在很多不足 pcntl没有提供进程间通信的功能 pcntl不支持重定向标准输入和输出 pcntl只提供了fork这样原始的接口，容易使用错误 swoole_process提供了比pcntl更强大的功能，更易用的API，使PHP在多进程编程方面更加轻松。 2.swoole_process提供了如下特性 swoole_process提供了基于unixsock的进程间通信，使用很简单只需调用write/read或者push/pop即可 swoole_process支持重定向标准输入和输出，在子进程内echo不会打印屏幕，而是写入管道，读键盘 输入可以重定向为*管道读取数据 配合swoole_event模块，创建的PHP子进程可以异步的事件驱动模式swoole_process提供了exec接口，创建的进程可以执行其他程序，与原PHP父进程之间可以方便的通信 3.创建进程：new swoole_process()函数原型：swoole_process::__construct(callable $function, $redirect_stdin_stdout = false, $create_pipe = true);参数： callable $function：子进程创建成功后要执行的函数，底层会自动将函数保存在对象的callback属性上，若要更改执行函数则可赋值新的函数在对象的callback属性。 $redirect_stdin_stdout：重定向子进程的标准输入输出，启动此选项后，子进程输出内容不是打印到屏幕而是写入主进程管道，读取键盘输入变成从管道中读取数据，默认为阻塞读取。 $create_pipe：是否创建管道，启动重定向后此项强制为1/true，如果子进程内没有进程间通信科设置为false。 管道类型：0/false =&gt; 不创建管道，1/true =&gt; 管道类型将设置为SOCK_STREAM(流式)，2 =&gt; 管道类型将设置为SOCK_DGRAM(数据包) 4.启动进程：swoole_process-&gt;start执行fork系统调用，启动进程函数原型：int swoole_process-&gt;start();返回参数：创建成功返回子进程的PID，创建失败返回false启动后可用属性： $process-&gt;pid属性为子进程的PID $process-&gt;pipe属性为管道的文件描述符 5.向管道写入数据：swoole_process-&gt;write函数原型：int swoole_process-&gt;write(string $data);参数：$data的长度在Linux系统下最大不超过8K，MacOS/FreeBSD下最大不超过2K父/子进程调用write，子/父进程可调用read接收数据同步模式：进程内未使用任何异步IO，则管道为同步阻塞模式，如果缓冲区满了，将阻塞直到write操作完成。如Task进程就是同步阻塞模式。异步模式：进程内使用了异步IO，如swoole_event_add(进程事件),进程内wirte操作变成异步模式，swoole底层会监听可写事件，自动完成管道写入。 6.从管道中读取数据：swoole_process-&gt;read函数原型：function swoole_process-&gt;read(int $buffer_size=8192) : string | bool; $buffer_size是缓冲区的大小，默认为8192，最大不超过64K 管道类型为DGRAM数据报(2)时，read可以读取完整的一个数据包 管道类型为STREAM(1/true)时，read是流式的，需要自行处理包完整性问题 读取成功返回二进制数据字符串，读取失败返回false 7.添加进程事件：异步IO，swoole_event_addswoole_event_add函数用于将一个socket加入到底层的reactor事件监听中。此函数可以用在Server或Client模式下。函数原型：bool swoole_event_add(int $sock, mixed $read_callback, mixed $write_callback = null, int $flags = null); int $sock：可以为一下三种类型1.int，就是文件描述符,包括swoole_client的socket,以及第三方扩展的socket（比如mysql）2.stream资源，就是stream_socket_client/fsockopen创建的资源3.sockets资源，就是sockets扩展中socket_create创建的资源，需要在编译时加入 ./configure –enable-sockets mixed $read_callback：可读回调函数 mixed $write_callback:可写事件回调，可以是字符串函数名、对象+方法、类静态方法或匿名函数，当此socket可读时回调指定的函数。 int $flags：事件类型的掩码，可选择关闭/开启可读可写事件，如SWOOLE_EVENT_READ，SWOOLE_EVENT_WRITE，或者SWOOLE_EVENT_READ | SWOOLE_EVENT_WRITE 8.创建同步进程123456789101112131415161718192021222324&lt;?php//创建进程对应的执行函数function doProcess(swoole_process $worker)&#123; var_dump($worker); echo &quot;\\n&quot;; echo &quot;PID : &quot;.$worker-&gt;pid.&quot;\\n&quot;; sleep(5);&#125;//创建进程 没有启动重定向$process = new swoole_process(&quot;doProcess&quot;);$pid = $process-&gt;start();//匿名函数创建进程(启动重定向)$process = new swoole_process(function (swoole_process $process) &#123; $process-&gt;write(&apos;Hello&apos;);&#125;, true);$process-&gt;start();sleep(10);echo $process-&gt;read(); //从管道输出//等待结束，关闭子进程(若不等待结束，容易出现僵尸进程)swoole_process::wait(); 将脚本上传至服务器并启动，可以看到，无重定向打印了$worker的内容和PID，重定向输出了Hello 9.创建异步进程因为子进程会继承父进程的内存和IO句柄，所以如果父进程要创建多个子进程，务必要等待创建完毕后再使用swoole_event_add/异步swoole_client/定时器/信号等异步IO函数。12345678910111213141516171819202122232425262728&lt;?php//进程池 存储进程$workers = []; //进程数量$worker_num = 3;//创建并启动进程for($i=0;$i&lt;$worker_num;$i++)&#123; $process = new swoole_process(&apos;doProcess&apos;); //创建单独新进程 $pid = $process-&gt;start(); //启动进程并获取进程ID $workers[$pid] = $process; //将进程存入进程池&#125;//编写进程执行函数function doProcess(swoole_process $process)&#123; $process-&gt;write(&quot;PID : (&quot;.$process-&gt;pid.&quot;)\\t CallbackFunction(&quot;.$process-&gt;callback .&quot;)&quot;.PHP_EOL); echo &quot;Write Msg : PID(&quot;.$process-&gt;pid.&quot;)\\t CallbackFunction(&quot;.$process-&gt;callback .&quot;)&quot;.PHP_EOL;&#125;//添加进程事件 向每个子进程添加需要执行的事件foreach ($workers as $process) &#123; //子进程也会包含此事件 swoole_event_add($process-&gt;pipe,function($pipe) use($process)&#123; $data = $process-&gt;read(); echo &quot;Receive Msg : &quot;.$data.PHP_EOL; &#125;);&#125;将脚本上传至服务器并启动，可以看到成功将PID和Callback函数写入管道并且读出来了","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"php项目","slug":"php项目","permalink":"https://harviealwayshere.github.io/tags/php项目/"},{"name":"swoole","slug":"swoole","permalink":"https://harviealwayshere.github.io/tags/swoole/"}]},{"title":"Swoole(八)同步TCP客户端","slug":"swoole8","date":"2018-02-18T12:06:51.000Z","updated":"2018-02-21T08:29:45.375Z","comments":true,"path":"2018/02/18/swoole8/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/18/swoole8/","excerpt":"","text":"创建一个TCP的同步客户端，可用于连接我们之前的实例TCP服务器 1.函数讲解1.建立TCP客户端对象：$client = new swoole_client(SWOOLE_SOCK_TCP);2.连接到服务器使用客户端对象的connect方法，参数分别为服务器$ip、服务器端口号$port和连接超时时间$time1$client-&gt;connect(&apos;127.0.0.1&apos;, 9501, 0.5);TCP需要进行3次握手，所以connect至少需要3次网络传输过程3.向服务器发送数据使用客户端对象的send方法，参数为字符串1$client-&gt;send(&quot;hello world&quot;);在发送少量数据时$client-&gt;send都是可以立即返回的。发送大量数据时，socket缓存区可能会塞满，send操作会阻塞。4.从服务器接收数据使用客户端对象的recv方法1$data = $client-&gt;recv();recv操作会阻塞等待服务器返回数据，recv耗时等于服务器处理时间+网络传输耗时之合。5.关闭连接1$client-&gt;close(); 这个客户端是同步阻塞的，connect/send/recv 会等待IO完成后再返回。同步阻塞操作并不消耗CPU资源，IO操作未完成当前进程会自动转入sleep模式，当IO完成后操作系统会唤醒当前进程，继续向下执行代码。 2.代码构建1234567891011121314151617181920212223&lt;?php$client = new swoole_client(SWOOLE_SOCK_TCP);//连接到服务器if (!$client-&gt;connect(&apos;0.0.0.0&apos;, 9501, 0.5))&#123; die(&quot;connect failed.&quot;);&#125;//向服务器发送数据if (!$client-&gt;send(&quot;hello world&quot;))&#123; die(&quot;send failed.&quot;);&#125;//从服务器接收数据$data = $client-&gt;recv();if (!$data)&#123; die(&quot;recv failed.&quot;);&#125;echo &quot;recv data is :&quot;.$data.&quot;\\n&quot;;//关闭连接$client-&gt;close();3.代码演示首先我们打开一个终端，执行一个tcp服务器的脚本之后我们上传tcp客户端脚本至服务器并运行，可以看到客户端连接服务器并发送数据成功，而且还接受到了服务器返回的数据，看看服务器端的反应证明客户端连接成功并且断开连接成功了","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"php项目","slug":"php项目","permalink":"https://harviealwayshere.github.io/tags/php项目/"},{"name":"swoole","slug":"swoole","permalink":"https://harviealwayshere.github.io/tags/swoole/"}]},{"title":"Swoole(七)异步TCP服务器","slug":"swoole7","date":"2018-02-18T11:14:06.000Z","updated":"2018-02-18T12:40:11.428Z","comments":true,"path":"2018/02/18/swoole7/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/18/swoole7/","excerpt":"","text":"Swoole提供了异步任务处理的功能，可以投递一个异步任务到TaskWorker进程池中执行，不影响当前请求的处理速度。在Server程序中如果需要执行很耗时的操作，比如一个聊天服务器发送广播，Web服务器中发送邮件。如果直接去执行这些函数就会阻塞当前进程，导致服务器响应变慢。 1.代码讲解1.创建TCP服务器：$serv = new swoole_server(“0.0.0.0”, 9501);2.设置异步任务的工作进程数1$serv-&gt;set(array(&apos;task_worker_num&apos; =&gt; 4));3.onReceive事件，用来投递异步任务，同时获取此次异步任务的ID12345//投递异步任务$serv-&gt;on(&apos;receive&apos;, function($serv, $fd, $from_id, $data) &#123; //获取此次异步任务的ID $task_id = $serv-&gt;task($data);&#125;);4.onTask事件，用来处理异步任务，同时返回任务执行的结果1234$serv-&gt;on(&apos;task&apos;, function ($serv, $task_id, $from_id, $data) &#123; //返回任务执行的结果 $serv-&gt;finish(&quot;$data -&gt; OK&quot;);&#125;);5.onFinish事件，用来处理异步任务的结果1234//处理异步任务的结果$serv-&gt;on(&apos;finish&apos;, function ($serv, $task_id, $data) &#123; &#125;);6.启动服务器，$serv-&gt;start(); 2.代码运行上传脚本代码至服务器并运行，再开启一个终端可以看到已经有4个额外的worker进程在运行我们把这个终端当作TCP客户端采用TCP方式连接服务器测试，并发送消息此时在另一个终端即TCP服务器端可以看到如下","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"php项目","slug":"php项目","permalink":"https://harviealwayshere.github.io/tags/php项目/"},{"name":"swoole","slug":"swoole","permalink":"https://harviealwayshere.github.io/tags/swoole/"}]},{"title":"Swoole(六)设置定时器","slug":"swoole6","date":"2018-02-18T08:26:36.000Z","updated":"2018-02-18T12:05:24.854Z","comments":true,"path":"2018/02/18/swoole6/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/18/swoole6/","excerpt":"","text":"swoole提供了类似JavaScript的setInterval/setTimeout异步高精度定时器，粒度为毫秒级。使用也非常简单。1.swoole_timer_tick相当于setInterval，是持续触发的函数原型：int $timer_id swoole_timer_tick(int $after_time_ms, mixed $callback function, mixed $user_param)参数： int $after_time_ms：指定触发的时间，单位为毫秒 mixed $callback function：执行的函数，参数有$timer_id mixed $user_param：用户参数返回值：int $timer_id，表示定时器ID 2.swoole_timer_after相当于setTimeout，仅在约定的时间触发一次函数原型：int $timer_id swoole_timer_after(int $after_time_ms, mixed $callback function, mixed $user_param)参数： int $after_time_ms：指定触发的时间，单位为毫秒 mixed $callback function：执行的函数 mixed $user_param：用户参数返回值：int $timer_id，表示定时器ID Tips：可以使用swoole_timer_clear(int $timer_id)清除定时器，参数为定时器ID 3.代码1234567891011&lt;?php//定时器 循环执行swoole_timer_tick(5000,function($timer_id)&#123; echo &quot;Tick 5s timer(ID:&quot;.$timer_id.&quot;) \\n&quot;;&#125;);//定时器 单次执行swoole_timer_after(3000,function($timer_id)&#123; echo &quot;After 3s timer(ID:&quot;.$timer_id.&quot;) \\n&quot;;&#125;);4.演示将脚本上传服务器后执行可看到如下结果","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"php项目","slug":"php项目","permalink":"https://harviealwayshere.github.io/tags/php项目/"},{"name":"swoole","slug":"swoole","permalink":"https://harviealwayshere.github.io/tags/swoole/"}]},{"title":"Swoole(五)配置WebSocket服务器","slug":"swoole5","date":"2018-02-16T12:21:49.000Z","updated":"2018-02-16T18:47:06.365Z","comments":true,"path":"2018/02/16/swoole5/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/16/swoole5/","excerpt":"","text":"接来下我们来学习配置一个WebSocket服务器1.首先介绍下什么是websocket初次接触 WebSocket 的人，都会问同样的问题：我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？答案很简单，因为 HTTP 协议有一个缺陷：通信只能由客户端发起。这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。一般有两种方法 AJAX轮询：让浏览器隔个几秒就发送一次请求，询问服务器是否有新信息。 Long Poll：原理跟AJAX轮询差不多，都是采用轮询的方式，不过采取的是阻塞模型，也就是说，客户端发起连接后，如果没消息，就一直不返回Response给客户端。直到有消息才返回，返回完之后，客户端再次建立连接，周而复始。 WebSocket协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。 2.Swoole实现Websocket服务端先上代码然后解释12345678910111213141516171819&lt;?php$ws = new swoole_websocket_server(&quot;0.0.0.0&quot;, 9504);$ws-&gt;on(&apos;open&apos;, function ($ws, $request) &#123; var_dump($request); $ws-&gt;push($request-&gt;fd,&quot;welcome to harvie&apos;s home !\\n&quot;)&#125;);$ws-&gt;on(&apos;message&apos;, function ($ws, $frame) &#123; echo &quot;receive from &#123;$frame-&gt;fd&#125;:&#123;$frame-&gt;data&#125;,opcode:&#123;$frame-&gt;opcode&#125;,fin:&#123;$frame-&gt;finish&#125;\\n&quot;; $ws-&gt;push($frame-&gt;fd, &quot;get it message !&quot;);&#125;);$ws-&gt;on(&apos;close&apos;, function ($ws, $fd) &#123; echo &quot;client &#123;$fd&#125; closed\\n&quot;;&#125;);$ws-&gt;start(); 3.代码解释1.构建websocket服务器对象：swoole_websocket_server($ip,$port)2.设置回调函数事件:2.1 open事件：建立连接事件， function (swoole_websocket_server $server, $request)，$server是服务器信息，$request是客户端信息2.2 message事件：接收消息事件，function (swoole_websocket_server $server, $request)，$server是服务器信息，$frame是客户端信息2.3 close：关闭连接事件，function (swoole_websocket_server $server, $fd)，$server是服务器信息，$frame是客户端信息2.4 使用swoole_websocket_server-&gt;push(int $fd, string $data, int $opcode = 1, bool $finish = true);向websocket客户端连接推送数据 $fd为客户端连接的ID $data为发送的数据内容 $opcode指定发送数据内容的格式，默认为文本。发送二进制内容$opcode参数需要设置为WEBSOCKET_OPCODE_BINARY $finish发送成功返回true，发送失败返回false3.启动服务器 4.测试运行将脚本上传到服务器并运行，打开浏览器，输入ip地址和端口号可以看到并不能成功访问，必须实现WebSocket协议才能和WebSocket服务器通信，我们创建一个前台websocket页面，代码如下12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=&quot;text/javascript&quot;&gt; var wsServer = &apos;ws://39.108.210.229:9504&apos;; var websocket = new WebSocket(wsServer); websocket.onopen = function (evt) &#123; console.log(&quot;连接成功&quot;); &#125;; websocket.onclose = function (evt) &#123; console.log(&quot;连接关闭&quot;); &#125;; websocket.onmessage = function (evt) &#123; console.log(&apos;从服务器接受到的数据为：&apos; + evt.data); &#125;; websocket.onerror = function (evt, e) &#123; console.log(&apos;错误发生信息: &apos; + evt.data); &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;然后放在我们Windows客户端下的Apache服务器下执行，可以打开浏览器看到此时我们可以看到服务器中打印了相关的请求信息","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"php项目","slug":"php项目","permalink":"https://harviealwayshere.github.io/tags/php项目/"},{"name":"swoole","slug":"swoole","permalink":"https://harviealwayshere.github.io/tags/swoole/"}]},{"title":"Swoole(四)配置Web服务器","slug":"swoole4","date":"2018-02-16T11:56:47.000Z","updated":"2018-02-16T18:25:40.553Z","comments":true,"path":"2018/02/16/swoole4/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/16/swoole4/","excerpt":"","text":"接来下我们来学习Swoole的基本函数，以此来配置一个Web服务器1.基本函数1.1 swoole_http_server：swoole_http_server继承自swoole_server，是一个完整的http服务器实现，支持同步和异步2种模式。函数原型：$http = new swoole_http_server($ip, $port); $ip：监听的ip $port：监听的端口 1.2 swoole_http_server-&gt;on:注册事件回调函数。swoole_http_server-&gt;on不接受onConnect/onReceive回调设置，swoole_http_server-&gt;on 额外接受1种新的事件类型onRequest123$http_server-&gt;on(&apos;request&apos;, function($request,$response) &#123; $response-&gt;end(&quot;&lt;h1&gt;hello swoole&lt;/h1&gt;&quot;);&#125;);在收到一个完整的Http请求后，会回调此函数。回调函数共有2个参数： $request：Http请求信息对象，包含了header/get/post/cookie等相关信息 $response：Http响应对象，支持cookie/header/status等Http操作 $response-&gt;end()：向客户端发送信息Tips：在onRequest回调函数返回时底层会销毁$request和$response对象，如果未执行$response-&gt;end()操作，底层会自动执行一次$response-&gt;end(“”) 2.构建基本的Web服务器1.构建swoole_http_server对象，设置监听对象为所有ip地址，端口为9503端口2.注册回调事件request，打印请求信息对象和返回Hello Swoole+一个随机数(证明每次访问返回不同)，$response-&gt;end()方法表示输出一段HTML内容，并结束此请求。3.启动服务器123456789$http = new swoole_http_server(&quot;0.0.0.0&quot;, 9503);$http-&gt;on(&apos;request&apos;, function ($request, $response) &#123; var_dump($request); $response-&gt;header(&quot;Content-Type&quot;, &quot;text/html; charset=utf-8&quot;); $response-&gt;end(&quot;&lt;h1&gt;Hello Swoole. #&quot;.rand(1000, 9999).&quot;&lt;/h1&gt;&quot;);&#125;);$http-&gt;start();我们先上传php脚本到服务器，之后执行然后我们使用浏览器访问服务器的ip地址，可以看到此时我们可以看到服务器会打印请求对象的信息我们再次刷新服务器可以看到随机数会变化","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"php项目","slug":"php项目","permalink":"https://harviealwayshere.github.io/tags/php项目/"},{"name":"swoole","slug":"swoole","permalink":"https://harviealwayshere.github.io/tags/swoole/"}]},{"title":"Swoole()配置UDP服务器","slug":"swoole3","date":"2018-02-16T09:23:01.000Z","updated":"2018-02-16T10:32:02.589Z","comments":true,"path":"2018/02/16/swoole3/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/16/swoole3/","excerpt":"","text":"接来下我们来学习Swoole的基本函数，以此来配置一个UDP服务器1.基本函数1.1 swoole_server-&gt;sendto：向任意的客户端IP:PORT发送UDP数据包。函数原型：bool swoole_server-&gt;sendto(string $ip, int $port, string $data, int $server_socket = -1); $ip:为IPv4字符串，如192.168.1.102。如果IP不合法会返回错误 $port:为 1-65535的网络端口号，如果端口错误发送会失败 $data:要发送的数据内容，可以是文本或者二进制内容 $server_socket服务器可能会同时监听多个UDP端口，此参数可以指定使用哪个端口发送数据包 2.构建基本的UDP服务器UDP服务器与TCP服务器不同，UDP没有连接的概念。启动Server后，客户端无需Connect，直接可以向Server监听的9502端口发送数据包。对应的事件为onPacket。构建步骤：1.创建swoole_server对象，注意$sock_type类型选择SWOOLE_SOCK_UDP2.注册监听事件，对应事件为Packet，回调函数类型为function ($serv, $data, $clientInfo)3.调用$server-&gt;sendto方法向客户端发送数据4.启动服务器 12345678910111213&lt;?php//创建Server对象，监听 0.0.0.0:9502端口，类型为SWOOLE_SOCK_UDP$serv = new swoole_server(&quot;127.0.0.1&quot;, 9502, SWOOLE_PROCESS, SWOOLE_SOCK_UDP); //监听数据接收事件$serv-&gt;on(&apos;Packet&apos;, function ($serv, $data, $clientInfo) &#123; $serv-&gt;sendto($clientInfo[&apos;address&apos;], $clientInfo[&apos;port&apos;], &quot;Server &quot;.$data); var_dump($clientInfo);&#125;);//启动服务器$serv-&gt;start(); 接下来我们上传文件到服务器并启动可以看到已经启动了，为了确保启动成功我们可以再开一个终端连接服务器查看进程接下来我们使用网络调试助手NetAssist来测试，上次使用windows自带的telnet感觉太鸡肋了，这个小工具简单好用，我下载的是V3.8.1，其实都大同小异","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"php项目","slug":"php项目","permalink":"https://harviealwayshere.github.io/tags/php项目/"},{"name":"swoole","slug":"swoole","permalink":"https://harviealwayshere.github.io/tags/swoole/"}]},{"title":"Swoole(二)配置TCP服务器","slug":"swoole2","date":"2018-02-14T17:55:02.000Z","updated":"2018-02-16T11:39:36.344Z","comments":true,"path":"2018/02/15/swoole2/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/15/swoole2/","excerpt":"","text":"接来下我们来学习Swoole的基本函数，以此来配置一个TCP服务器1.基本函数1.1 swoole_server：创建一个异步Server对象。函数原型：$serv = new swoole_server(string $host, int $port = 0, int $mode = SWOOLE_PROCESS, int $sock_type = SWOOLE_SOCK_TCP); $host:指定监听的ip地址IPv4使用 127.0.0.1表示监听本机，0.0.0.0表示监听所有地址IPv6使用::1表示监听本机，:: (相当于0:0:0:0:0:0:0:0) 表示监听所有地址 $port:监听的端口如果$sock_type为UnixSocket Stream/Dgram，此参数将被忽略监听小于1024端口需要root权限如果此端口被占用server-&gt;start时会失败 $mode:运行的模式SWOOLE_PROCESS多进程模式（默认）SWOOLE_BASE基本模式 $sock_type:指定Socket的类型支持TCP、UDP、TCP6、UDP6、UnixSocket Stream/Dgram 6种 1.2 swoole_server-&gt;on：注册Server的事件回调函数。函数原型：bool swoole_server-&gt;on(string $event, mixed $callback); $event:回调的名称connect：建立连接时receive：接收到数据时close：关闭连接时 $callback:回调的PHP函数，可以是函数名的字符串，类静态方法，对象方法数组，匿名函数。connect：function ($serv, $fd){} $serv:服务器信息 $fd:客户端信息receive：function ($serv, $fd, $from_id, $data){} $from_id:客户端ID $data:接收的数据close：function ($serv, $fd){} $serv:服务器信息 $fd:客户端信息 1.3 swoole_server-&gt;start：启动server，监听所有TCP/UDP端口。函数原型：bool swoole_server-&gt;start()启动成功后会创建:Master进程+Manager进程+serv-&gt;worker_num个Worker进程 Master进程:主进程内有多个Reactor线程，基于epoll/kqueue进行网络事件轮询。收到数据后转发到worker进程去处理 Manager进程:对所有worker进程进行管理，worker进程生命周期结束或者发生异常时自动回收，并创建新的worker进程 Worker进程:对收到的数据进行处理，包括协议解析和响应请求。 启动失败会立即返回false启动成功后将进入事件循环，等待客户端连接请求。start方法之后的代码不会执行服务器关闭后，start函数返回true，并继续向下执行 1.4 swoole_server-&gt;send：向客户端发送数据。函数原型：bool swoole_server-&gt;send(int $fd, string $data, int $extraData = 0); $data:发送的数据TCP协议最大不得超过2M，可修改buffer_output_size改变允许发送的最大包长度UDP协议不得超过65507，UDP包头占8字节, IP包头占20字节，65535-28 = 65507 UDP服务器使用$fd保存客户端IP，$extraData保存server_fd和port 发送成功会返回true发送失败会返回false，调用$server-&gt;getLastError()方法可以得到失败的错误码 2.构建基本的TCP服务器使用上述三个函数就可以构建出一个基本的TCP服务器了12345678910111213141516171819202122&lt;?php//创建Server对象，监听 0.0.0.0:9501端口$serv = new swoole_server(&quot;0.0.0.0&quot;, 9501); //监听连接进入事件$serv-&gt;on(&apos;connect&apos;, function ($serv, $fd) &#123; echo &quot;Client: Connect.\\n&quot;;&#125;);//监听数据接收事件$serv-&gt;on(&apos;receive&apos;, function ($serv, $fd, $from_id, $data) &#123; $serv-&gt;send($fd, &quot;Server: &quot;.$data);&#125;);//监听连接关闭事件$serv-&gt;on(&apos;close&apos;, function ($serv, $fd) &#123; echo &quot;Client: Close.\\n&quot;;&#125;);//启动服务器$serv-&gt;start(); 之后我们把tcpServer.php上传到服务器上在服务器端运行这个脚本我们可以再次连接服务器，通过查看进程确认脚本是否执行首先可以看到有一个进程-bash在使用一个子进程ps -ajft查看进程，这个bash就是我们连接服务器的进程然后可以看到有一个进程-bash有三个子进程在执行，可以看出分别是Master进程(32680)、Manager进程(32681)和Worker进程(32683)此时我们可以通过客户端使用网络工具来连接服务器（x为ip地址，y为端口号），我使用的是windows自带的telnet服务，具有TCP连接功能，如何开启请看这里可以看到成功连接并且实现了向客户端返回数据的功能，若是无法正常连接，可能有如下三种原因 在Linux下，使用netstat -an | grep 端口或者lsof -i:9501，查看端口是否已经被打开处于Listening状态，若处于可以看看是什么哪个进程在使用这个端口，并用kill -9 进程号(PID)，结束这个进程重新开放端口 上一步确认后，检查防火墙问题，最好使用命令systemctl stop firewalld.service 注意服务器所使用的IP地址，如果是127.0.0.1回环地址，则客户端只能使用127.0.0.1才能连接上 若是阿里云服务器，记得在阿里云控制台中安全组设置开放外界端口号 这时我们的基本的tcp服务器就已经搭建好了，若需要关闭这个进程，可以使用kill -9 进程号关闭掉Master的父进程-bash(32618)即可，此时再使用ps -ajft和netstat -an | grep 9501，可看到进程结束并且端口不再处于监听状态即可 我们搭建基本tcp服务器的过程就结束了，接下来我们将会学习如何搭建别的类型服务器，如UDP、Web、Websocket、异步TCP，还有一些队列通信、信号触发、DNS查询、异步文件IO、异步mysql等。","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"php项目","slug":"php项目","permalink":"https://harviealwayshere.github.io/tags/php项目/"},{"name":"swoole","slug":"swoole","permalink":"https://harviealwayshere.github.io/tags/swoole/"}]},{"title":"Swoole(一)安装","slug":"swoole1","date":"2018-02-09T16:29:04.000Z","updated":"2018-02-09T17:55:49.101Z","comments":true,"path":"2018/02/10/swoole1/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/10/swoole1/","excerpt":"","text":"说到PHP异步网络通信框架，相信PHPer脑海里第一个浮现的便是Swoole。 商业应用：IM聊天、战旗TV、虎牙直播、YY语音等。 应用领域：互联网、网络通信、企业软件、云计算、网络游戏、物理网等。 特点：1.异步、并行、高性能2.纯C编写，接近应用底层3.php扩展 应用：1.异步多线程服务器及客户端2.异步MySQL、Redis、数据库连接池、任务队列3.http/websocket服务器/客户端4.异步文件读写5.Swoole2.0支持协程 安装Swoole大致可分成3个步骤:1.搭建Linux操作系统2.安装环境依赖(php,gcc,httpd，pecl)3.安装Swoole并修改php.ini Part1:搭建Linux操作系统查看官方文档可知Swoole并不支持Windows系统，所以我们这里搭建一个CentOS 7.3 64位的操作系统，我是使用阿里云云服务器 ECS搭建的，使用系统盘安装即可，安装完毕之后可以远程连接进入云服务器中的Linux系统中Tips:如果想在Windows下便捷操作云服务器的系统，推荐使用SSH连接软件，这里我使用的是SSH Secure Shell Client3.2.9，安装完成后有两个工具可以使用，分别对应Linux系统的命令行界面和Linux文件系统的GUI界面的，十分便捷客观，提供工作效率。可参考这篇博客安装使用。连接成功后的界面为 Part2:安装环境依赖(php,gcc,httpd，pecl)在CentOS中使用yum安装php7，由于初始yum所安装的php版本是5.*的，我们首先要获取php7的yum源1234567891011//1.安装epel-releaseyum -y install epel-release //2.获取php7的yum源rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm//3.安装php7yum install php70w//4.验证安装php -v安装完成后可看到php版本之后我们要安装gcc和httpd1yum install httpd gcc最后我们要安装pecl，因为swoole项目已收录到PHP官方扩展库，可直接使用pecl安装swoole12wget http://pear.php.net/go-pear.pharphp go-pear.phar Part3:安装Swoole并修改php.ini1sudo pecl install swoole 会报错如下，别着急输入1vi `which pecl`进入Linux的Vim编辑模式，一直向下查找找到这个文件的最后一行按I进入Vim的插入模式，之后将-n标志去掉，按ESC进入Vim的退出(末行)模式，输入[:wq!]保存并退出之后安装 php-devel1sudo yum install php70w-devel再次安装swoole1sudo pecl install swoole成功安装！根据提示要添加”extension=swoole.so”在php配置文件php.ini中，我这里由于对于Vim的操作并不熟悉，我直接通过SSH软件将php.ini文件拉取到本地之后修改再上传到服务器php.ini一般在/etc目录下拉取到本地后添加”extension=swoole.so”语句，随意在任何两个配置语句中增加之后通过语句[php -m]可查看php拓展安装情况，如果看到swoole则安装成功！ 如果你实践完成了本教程，意味着你对于Linux和Windows系统的协同开发、php拓展安装已经了解了基本情形了，接下来我们将使用swoole开发php应用，敬请期待。","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"php项目","slug":"php项目","permalink":"https://harviealwayshere.github.io/tags/php项目/"},{"name":"swoole","slug":"swoole","permalink":"https://harviealwayshere.github.io/tags/swoole/"}]},{"title":"剑指Offer算法记录(一)数据结构","slug":"offer","date":"2018-02-07T08:20:05.000Z","updated":"2018-02-14T10:24:04.055Z","comments":true,"path":"2018/02/07/offer/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/07/offer/","excerpt":"","text":"本文主要记录阅读剑指Offer这本书所遇到的算法解释并作一些个人的拓展 第二章2.2.1 关于sizeof的小知识 sizeof 对于空类型(无成员变量和成员函数)的实例 = 1字节：由于声明空类型的实例必须在内存中占用一定空间否则无法使用，占用多少内存由编译器决定，在VS中每个空类型实例占用1字节。 sizeof 对于空类型+构造和析构函数的实例 = 1字节 ：调用函数只需知道函数地址即可，函数地址只与类型有关而与类型的实例无关，因此sizeof实例还是1字节。 sizeof 对于空类型+构造函数+虚析构函数(虚函数) = 1个指针大小：一个类型中有虚拟函数就会为该类型生成虚函数表，并为这个类型的每个实例中添加一个指向虚函数表的指针，指针大小与机器有关，32为指针为4字节，64位指针为8字节。1234567891011121314151617181920212223242526class B //空类型&#123;&#125;;class C //空类型+构造和析构函数&#123;public: C()&#123;&#125;; ~C()&#123;&#125;;&#125;;class D //空类型+构造函数+虚析构函数(虚函数)&#123;public: D()&#123;&#125;; virtual ~D()&#123;&#125;;&#125;;int main()&#123; B b; C c; D d; cout &lt;&lt; &quot;空类型大小:&quot; &lt;&lt; sizeof(b)&lt;&lt;endl; cout &lt;&lt; &quot;空类型+构造和析构函数大小:&quot; &lt;&lt; sizeof(c) &lt;&lt; endl; cout &lt;&lt; &quot;空类型+构造函数+虚析构函数(虚函数)大小:&quot; &lt;&lt; sizeof(d) &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 总结：空的类是会占用内存空间的，而且大小是1，原因是C++要求每个实例在内存中都有独一无二的地址。 类内部的成员变量：*普通的变量：是要占用内存的，但是要注意对齐原则（这点和struct类型很相似）。*static修饰的静态变量：不占用内容，原因是编译器将其放在全局变量区。 类内部的成员函数：*普通函数：不占用内存。*虚函数：要占用4个字节，用来指定虚函数的虚拟函数表的入口地址。所以一个类的虚函数所占用的地址是不变的，和虚函数的个数是没有关系的 2.2.1 关于复制函数的小知识C++标准不允许复制构造函数传值参数，否则会造成递归重复调用，编译错误。12345678910111213141516171819202122232425262728293031323334353637383940class E&#123;private: int num;public: //构造函数 E(int x) :num(x) &#123; cout &lt;&lt; &quot;constructor call&quot; &lt;&lt; endl; &#125; //复制构造函数 传引用调用 E(E&amp; x) &#123; num = x.num; cout &lt;&lt; &quot;copy constructor call&quot; &lt;&lt; endl; &#125; //赋值运算符重载 E&amp; operator = (E&amp; x) &#123; num = x.num; cout &lt;&lt; &quot;assignment operator call&quot; &lt;&lt; endl; return *this; &#125; //函数调用 void showNum(E x) &#123; &#125; &#125;;int main()&#123; E a(1); //1式 E b(2); //2式 b = a; //3式 E c = a; //4式 c.showNum(a); //5式 system(&quot;pause&quot;); return 0;&#125;运行结果如图： 1/2式 =&gt; 若是实例创建并初始化时调用相应参数的构造函数 3式 =&gt; 若是实例已经创建初始化后再用=赋值，则调用=重载赋值函数 4式 =&gt; 若是实例用另一个同类实例初始化，则调用复制构造函数 5式 =&gt; 若是实例使用方法调用另一个实例，则首先调用复制构造函数将实参复制给形参后执行相关操作 因此就可以解释为什么C++不允许复制构造函数传值了，若是传值，则调用E c = a或者c.showNum(a)或者的时候，a作为参数传值给c的复制构造函数的参数E x，因为x没有被初始化，所以要调用x的复制构造函数将a复制给x，即x.E(a)，然而x的复制构造函数也是传值的，因此又要将a作为参数传值给c的复制构造函数的参数x的复制构造函数的参数E x，又因为这个x也没有被初始化，又要调用这个x的复制构造函数，造成了无限的递归。因此复制构造函数的参数使用引用调用不是为了减少一次内存的复制，而是为了避免复制构造函数无限递归调用的情况出现。下面这几种情况下会调用复制构造函数:（1）显式或隐式地用同类型的一个对象来初始化另外一个对象。如上例中的E c=a;（2）作为实参传递给一个函数。如上例中的c.showNum(a);（3）在函数体内返回一个对象时，也会调用返回值类型的拷贝构造函数（4）初始化序列容器中的元素时。比如vector svec(5)，string的缺省构造函数和拷贝构造函数都会被调用。（5）用列表的方式初始化数组元素时。string a[] = {string(“hello”),string(“world”)};会调用string的拷贝构造函数。 面试题 1：赋值运算符函数赋值运算符函数基础4要数:1.返回值类型声明为该类型的引用并在函数结束前返回实例自身引用：只有这样才能实现连续赋值运算2.参数类型声明为常量引用:常量是因为在函数体内不改变传入实参状态，引用是可以减少一次从形参到实参的复制构造函数的调用，节省空间开销提高代码效率3.释放实例自身已有内存:在分配新内存之前释放已有空间，避免内存泄露4.需要判断传入参数和当前实例(*this)是不是同一个实例:若是同一个则不进行赋值直接返回，若没有判断则在释放实例自身内存时传入的参数的内存也被释放了，就再也找不到需要赋值的内容了结合以上4点的解法1234567891011CMyString&amp; CMyString::operator =(const CMyString &amp;str) //返回值+参数(1.2.)&#123; if(this == $str) return *this; //判断是否是自身赋值自身(4.) delete []m_pData; //被赋值的实例的成员变量delete释放内存(3.) m_pData = NULL; //初始化变量 m_pData = new char[strlen(str.m_pData)+1]; //new分配内存 strcpy(m_pData,str.m_pData); //赋值 return *this; //返回自身实例用于连续赋值运算(1.)&#125; 考虑异常安全性:若new char时内存不足导致抛出异常，m_pData将是空指针，程序十分容易崩溃，此时由于被赋值的实例的成员变量已经被delete了，实例改变了自身的状态，违背了异常安全原则。解决方案:1.先new分配内存再delete释放内存，当new失败时我们能确保实例不会被修改原先状态2.先创建一个临时实例，再交换临时实例和原来的实例，如下1234567891011121314CMyString&amp; CMyString::operator =(const CMyString &amp;str) &#123; if(this != $str) &#123; CMyString strTemp(str); //调用复制构造函数新创建一个临时实例 char* pTemp = strTemp.m_pData; //利用一个中间变量pTemp将变量值交换 strTemp.m_pData = m_pData; m_pData = pTemp; &#125; //在if作用域外，由于strTemp是局部变量会自动调用析构函数释放内存，//其中strTemp中的成员变量m_pData所指向的内存就是原来被赋值实例成员函数的内存，刚好一并释放 return *this;&#125; 面试题 2：实现Singleton（单例）模式首先单例模式最基本的有3点：1.构造函数私有:不能被外界随意调用2.单例对象实例:此类型只能生成一个实例3.单例获取函数:只能获取到同一个实例基于这三点我们可以写出第一版单例模式123456789101112public class Singleton1&#123; private Singleton1()&#123;&#125; //私有构造函数 private static Singleton1 instance = NULL; //单例对象实例 public static Singleton1 getInstance() //单例获取函数 &#123; if(instance == NULL) instance = new Singleton1(); return instance; &#125;&#125;//其中第四行我们也可以写成private static Singleton1 instance = new Singleton1();//这样在getInstance()中就不需要判空操作，这属于饿汉模式(主动创造)，一开始初始值是NULL属于懒汉模式(等人调用才创造)第二版单例模式:第一版的单例模式是非线程安全的，当最初情况两个线程同时判断instance是否为空时(针对懒汉模式)，则两个线程会创建两个实例不满足单例模式要求，因此在多线程下我们要加上一个同步锁12345678910111213141516171819202122232425public class Singleton2&#123; private Singleton2()&#123;&#125; private static Singleton1 instance = NULL; private static object syncObj = new object(); //C#同步锁 public static Singleton2 getInstance() &#123; if(instance == NULL) //一次检测:只有instance为NULL时需要加锁操作，节省开销 &#123; lock(syncObj) &#123; //二次检测:当两个进程同时访问，线程A创建完对象开锁后 //线程B还是会进入临界区创建对象，因此需要第二次检测 if(instance == NULL) instance = new Singleton1(); &#125; &#125; return instance; &#125;&#125;//其中第十二行只是C#同步锁的操作，JAVA中可使用synchronized(Singleton2.class)&#123;&#125;操作第三版单例模式:C#中有一个函数确保只调用一次，就是静态构造函数(饿汉模式)123456789public class Singleton3&#123; private Singleton3()&#123;&#125; private static Singleton3 instance = new Singleton3(); //由于C#在调用静态构造函数时初始化静态变量，.NET运行时能够确保只调用一次静态构造函数 public static Singleton3 getInstance() &#123; return instance; &#125;&#125;第四版单例模式:按需创造/懒加载 JAVA中可以使用静态内部类1.因为从外部无法访问静态内部类，只有调用Singleton.getInstance方法才能得到单例对象INSTANCE2.INSTANCE对象初始化并不是在类Singleton被加载时，而是在调用getInstance方法时加载静态内部类LazyHolder时才被初始化，这种方式是利用classloader的加载机制实现懒加载（需要时才创建），从而保证偶见单例的线程安全1234567891011121314public class Singleton4&#123; private Singleton4()&#123;&#125; private static class LazyHolder //静态内部类 &#123; private static final Singleton INSTANCE = new Singleton4(); &#125; public static Singleton4 getInstance() &#123; return LazyHolder.INSTANCE; &#125;&#125; C++中可以使用嵌套类型123456789101112131415public class Singleton4&#123; private Singleton4()&#123;&#125; class Nested //嵌套类型 &#123; static Newted()&#123;&#125; //嵌套类型的构造函数 internal static readonly Singleton4 instance = new Singleton4(); &#125; public static Singleton4 getInstance() &#123; return Nested.instance; &#125;&#125;第五版单例模式:无论怎么样设计单例模式，均可以通过反射打破单例反射打破单例过程：123456789//第一步：获得单例类的构造器Constructor con = SingletonEnum.class.getDeclaredConstructor();//第二步：把构造器设置为可访问con.setAccessible(true);//第三步：使用newInstance构造不同的对象SingletonEnum singleton1 = (SingletonEnum)con.newInstance();SingletonEnum singleton2 = (SingletonEnum)con.newInstance();//验证是否是同一对象 =&gt; falseSystem.out.println(singleton1.equals(singleton2));针对防止反射的方式构建对象，在JAVA中可以使用枚举的方式构建类，因为JAM会住址反射获取枚举类的私有构造方法，这还可以实现线程安全性，但是唯一的缺点就是并非使用懒加载，单例对象是在枚举类被加载的时候进行初始化的。1234//枚举实现单例模式public enum SingletonEnum&#123; INSTANCE;&#125; 总结：单例模式升级步骤——基本模式(1.)+线程安全(2.)+懒加载(提升使用效率)(3.4.)+防止反射构建(5.)2.3 数组和指针区别输出 “20,4,4”20：data1是一个数组，包含五个整数，每个整数占4字节，一共20字节4：data2是一个指针指向data1数组的第一个数字，指针大小为4字节4：在C/C++中数组作为参数传递时自动退化为同类型的指针，因此为4字节 面试题3：二维数组中的查找一般的思路是从左上角开始做比较，但是减小排除的范围无规律，若是从右上角或者左下角做比较，则可以以行或者列减小排查范围，而二维数组以连续内存存储的特性让我们可以通过下标访问数组以矩阵形式的空间位置。1234567891011121314151617181920212223bool Find(int* matrix, int rows, int columns, int number)&#123; bool found = false; if(matrix != NULL &amp;&amp; rows &gt;0 &amp;&amp; columns &gt;0) //矩阵有效性检测（若输入空指针） &#123; int row = 0; int column = column -1; while(row &lt; rows &amp;&amp; column &gt;=0) //循环停止条件:最后一行或者第一列 &#123; if(matrix[row * columns + column] == number) //第row行第column列，相当于[row][column] &#123; found = true; break; &#125; else if(matrix[row * columns + column] &gt;number) column--; else row++; &#125; &#125; return found;&#125; 2.3.2字符串小知识C/C++中每个字符串以’/0’作为结尾，这样可以方便地找到字符串的结尾，但有额外字符开销，易越界。C/C++将常量字符串放到一个单独的内存区域节省内存，当几个指针赋值给相同的常量字符串时，他们实际上会指向相同的内存地址，但是用常量内存初始化数组却会创建新空间。 面试题4：替换空格网络编程中，URL参数中特殊字符串(空格、#等)需要替换成服务器端可以识别的字符，转换的规则是在’%’后面加上字符ASCII码的两位十六进制表示，如空格的ASCII码为32，十六进制为0x20，因此空格被替换成”%20”。解题思路:题目理解有两种，第一种是创建新的字符串并在新的字符串上做替换，则我们可以分配足够多的内存，第二种是在原字符串上做替换，则我们需要保证输入字符串后有足够多的空余内存并且不能覆盖原字符串的内存。解法一:字符串从前往后遍历找到一个空格则空格后的字符集体向后移动两个字节大小。时间复杂度为O(n^2)，多次移动次数，不是好的解决方案。解法二:先遍历一次字符串，统计出字符串中空格总数由此计算出替换后字符串的长度，之后从字符串末尾开始复制和替换，这样所有字符只移动一次，算法的时间效率是O(n)。具体的复制和替换过程为使用两个指针 123456789101112131415161718192021222324252627282930313233343536373839404142void ReplaceBlank(char string[], int maxLength)&#123; if(string == NULL &amp;&amp; length &lt;= 0) //输入参数有效性检测性 return; //originalLength为字符串原先长度 int originalLength = 0; int numberOfBlank = 0; int i = 0; while(string[i] != &apos;\\0&apos;) &#123; originalLength++; if(string[i] == &apos; &apos;) numberOfBlank++; i++; &#125; //newLength为替换后的字符串长度 int newLength = originalLength + numberOfBlank * 2; if(newLength &gt; maxLength) //如果替换后字符串长度大于字符串总容量 return; int indexOfOriginal = originalLength; int indexOfNew = newLength; while(indexOfOriginal &gt;= 0 &amp;&amp; indexOfNew &gt; indexOfOriginal)//替换完成条件 &#123; //若是空格则后面的标记添加并前移三个字节 if(string[indexOfOriginal] == &apos; &apos;) &#123; string[indexOfNew --] = &apos;0&apos;; string[indexOfNew --] = &apos;2&apos;; string[indexOfNew --] = &apos;%&apos;; &#125; else &#123; //若不空格则复制前面指针的字符到后面指针的位置，并前移指针 string[indexOfNew --] = string[indexOfOriginal]; &#125; -- indexOfOriginal; &#125; &#125;2.3.3 链表小知识链表是由指针把若干个节点连接成链状结构，链表的创建、插入节点、删除节点等操作只需要20行代码就可以实现，比较适合面试。链表是一种动态结构，创建时无需知道链表的长度，每添加一次节点再分配新内存，然后调整指针的指向。单向链表的节点定义如下12345struct ListNode&#123; int Value; ListNode* Next;&#125;往链表末尾添加一个节点的函数如下要点：1.头指针的传参 2.插入的节点是第一个节点的情况(空链表/头指针为空)1234567891011121314151617181920void addToTail(ListNode** pHead, int value) //由于头指针可能改变，因此要以传指针的形式传参，否则出了函数头指针依然是空指针&#123; ListNode* pNew = new ListNode(); pNew-&gt;Value = value; pNew-&gt;Next = NULL; //注意新节点的Next初始化为NULL if(*pHead == NULL) //若是往一个空链表插入节点，则头指针指向新节点 &#123; *pHead = pNew; &#125; else //否则找到头指针指向第一个节点，开始遍历找到最后一个节点，将节点的Next指向新节点 &#123; ListNode* pNode = *pHead; while(pNode-&gt;Next != NULL) pNode = pNode-&gt;Next; pNode-&gt;Next = pNew; &#125;&#125;在链表中找到第一个含有某值的节点并删除该节点的函数如下要点： 123456789101112131415161718192021222324252627282930void removeNode(ListNode** pHead, int value)&#123; if(pHead == NULL || *pHead == NULL) //空链表直接返回 return; ListNode* pToBeDelete = NULL; //找到需要删除的节点 if((*pHead)-&gt;Value == value) //当第一个节点是需要删除的节点，则需要改变头指针的指向 &#123; pToBeDelete = *pHead; *pHead = (*pHead)-&gt;Next; &#125; else //否则开始遍历节点 &#123; ListNode* pNode = *pHead; while(pNode-&gt;Next != NULL &amp;&amp; pNode-&gt;Next-&gt;Value != value) //遍历到最后一个节点或者找到需要删除的节点的前一个节点则停止遍历 pNode = pNode-&gt;Next; if(pNode-&gt;Next != NULL &amp;&amp; pNode-&gt;Next-&gt;Value ==value) //找到需要删除的节点的前一个节点 &#123; pToBeDelete = pNode-&gt;Next; pNode-&gt;Next = pNode-&gt;Next-&gt;Next; //这里包含了当需要删除的节点是最后一个节点的情况，若是最后一个节点则它的前一个节点会指向NULL &#125; &#125; if(pToBeDelete != NULL) &#123; delete pToBeDelete; pToBeDelete = NULL; &#125;&#125;面试题5：从尾到头打印链表面试中如果我们打算修改输入数据，最好先问面试官允不允许。若允许我们可以将链表中的节点指针反转改变链表方向就可以了。通常打印是一个只读操作，假设面试官要求这个题目不能改变链表结构。思路：遍历是从头到尾，输出却是从尾到头，这是典型的后进先出的栈结构，然后递归的本质就是栈结构，于是我们可以每访问一个节点先递归输出它后面的节点，再输出该节点自身。显示用栈调用代码如下12345678910111213141516171819//Reversingly-倒置地void printListReversingly(ListNode* pHead) //不用改变头指针，可传值&#123; std::stack&lt;ListNode*&gt; nodes; ListNode *pNode = pHead; while(pNode != NULL) &#123; node.push(pNode); //入栈 pNode = pNode-&gt;Next; &#125; while(!node.empty()) &#123; pNode = nodes.top(); //取栈顶元素 cout &lt;&lt; pNode-&gt;Value &lt;&lt; endl; //输出节点值 nodes.pop(); //弹出栈顶元素 &#125;&#125;基于递归的栈调用代码如下 12345678910//Recursively-递归地void printListReversinglyRecursively(ListNode* pHead) //不用改变头指针，可传值&#123; if(pHead != NULL) //判断是不是空链表 &#123; if(pHead-&gt;Next != NULL) printListReversinglyRecursively(pHead-&gt;Next); //判断是不是最后一个结点，若是最后一个结点则递归结束 cout &lt;&lt; pHead-&gt;Value &lt;&lt; endl; &#125; &#125;Tips:链表长时，导致函数调用层级很深，有可能导致函数调用栈移除，鲁棒性(程序稳定性)不好。2.3.4 树小知识树是一种数据结构: 除了根节点外每个节点只有一个父节点，根节点没有父节点 除了叶节点外每个节点有一个或多个子节点，叶节点没有子节点 父节点与子节点之间用指针连接 二叉树：树的特殊结构，每个节点最多有两个子节点遍历方式： 前序：根-左-右 中序：左-根-右 后序：左-右-根 宽度优先：按照层的顺序从顶到底遍历，同一层的节点按从左到右遍历 二叉搜索树：左节点小于等于根节点，右节点大于等于根节点的二叉树堆：最大堆中根节点的值最大，最小堆中根节点的值最小红黑树：把树中的节点定义为红、黑两种颜色，并通过规则确保从根节点到叶节点的最长路径的长度不超过最短路径的两倍，C++中STL中set、multiset、map、multimap等数据结构都是基于红黑树实现的 面试题6：重建二叉树思路：前序遍历可以确定树的根节点(第一个数字)，中序遍历在知道了根节点的值后可以知道左子树的结点值(根节点左边的所有值)和右子树的结点值(根节点右边的所有值)，之后用递归的方式完成剩下子树的建立12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//树的主构造函数BinaryTreeNode* Construct(int* preorder, int* inorder, int length)&#123; if(preorder == NULL || inorder == NULL || length &lt;= 0) //输入有效性检测 return NULL; return ConstructCore(preorder, preorder+length-1, inorder, inorder+length-1);&#125;//树的核心构造函数，通过传入前序遍历的头尾指针、中序遍历的头尾指针递归建树BinaryTreeNode* ConstructCore(int* startPreorder, int *endPreorder, int* startInorder, int* endInorder)&#123; //前序遍历的第一个数字是根节点的值 int rootValue = startPreorder[0]; BinaryTreeNode* root = new BinaryTreeNode(); root-&gt;m_nValue = rootValue; root-&gt;m_pLeft = root-&gt;m_pRight = NULL; if(startPreorder == endPreorder) &#123; //若是输入的树前序只有一个值、中序也只有一个值且这两个值是同一个值 //则输入的这个值就是这棵树的根节点，否则是无效输入 if(startInorder == endInorder &amp;&amp; *startPreorder == *startInorder) return root; else throw std::exception(&quot;Invalid input&quot;); &#125; //在中序遍历中找到根节点的值 int* rootInorder = startInorder; while(rootInorder &lt;= endInorder &amp;&amp; *rootInorder != rootValue) rootInorder++; //如果找到的节点在中序的末尾且值并不是根节点的值，返回错误 if(rootInorder == endInorder &amp;&amp; *rootInorder != rootValue) throw std::exception(&quot;Invalid input&quot;); //可以通过找到的节点确定左子树长度和左子树范围 int leftLength = rootInorder - startInorder; int* leftPreorderEnd = startPreorder + leftLength; if(leftLength &gt;0) &#123; //构建左子树 root-&gt;m_pLeft = ConstructCore(startPreorder+1,leftPreorderEnd,startInorder,rootInorder-1); &#125; if(leftLength &lt; endPreorder-startPreorder) &#123; //构建右子树 root-&gt;m_pRight = ConstructCore(leftPreorderEnd+1,endPreorder,rootInorder+1,endInorder); &#125; return root;&#125;让我们来看看ConstructCore做了什么事 2.3.5 栈和队列小知识栈：先进先出，即最后入栈(push)的元素会第一个被弹出(pop) 队列：先进先出，即第一个进入队列的元素会第一个出来面试题7：用两个栈实现队列思路：插入元素直接插入第一个栈即可，删除元素则若是第二个栈有元素就pop，若是第二个栈没有元素，则将第一个栈的元素全部pop并push进第一个栈，之后按照第二个栈有元素的方式pop123456789101112131415161718192021222324252627//元素入队template&lt;typename T&gt; void CQueue&lt;T&gt;::appendTail(const T&amp; element)&#123; stack1.push(element);&#125;//元素出队template&lt;typename T&gt; T CQueue&lt;T&gt;::deleteHead()&#123; if(stack2.size() &lt;= 0) //stack2空则将stack1全部弹出压如stack2 &#123; while(stack1.size() &gt; 0) &#123; T&amp; data = stack1.top(); stack1.pop(); stack2.push(data); &#125; &#125; //此时若是stack2还是空，则证明队列是空的 if(stack2.size() = 0) throw new exception(&quot;queue is empty&quot;); T head = stack2.top(); //否则弹出栈顶元素 stack2.pop(); return head;&#125;两个栈实现一个队列像是一个是插入栈一个是删除栈，而两个队列实现一个栈呢？思路如下","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://harviealwayshere.github.io/tags/数据结构/"}]},{"title":"C++基础语法","slug":"cplusplus","date":"2018-01-31T07:31:56.000Z","updated":"2018-02-07T08:09:25.136Z","comments":true,"path":"2018/01/31/cplusplus/","link":"","permalink":"https://harviealwayshere.github.io/2018/01/31/cplusplus/","excerpt":"","text":"刚想刷剑指offer和leetcode上的题目，本来享用python写的，毕竟是刷算法感觉无论是什么语言总是相通的，但看到剑指offer上写到 大一学的C++基础语法都忘记的差不多了，还是先来巩固一下C++基础语法，本文以runoob和C++ Primer(第五版)为基础编写。 Part1：C++基础语法标准的 C++ 由三个重要部分组成： 核心语言，提供了所有构件块，包括变量、数据类型和常量，等等。 C++ 标准库，提供了大量的函数，用于操作文件、字符串等。 标准模板库（STL），提供了大量的方法，用于操作数据结构等。 C++面向对象四大特点:封装、抽象、继承和多态。 C++基本程序结构：12345678#include &lt;iostream&gt; //添加头文件using namespace std; //使用std命名空间 int main() //主函数，程序执行入口&#123; cout &lt;&lt; &quot;Hello World&quot;; // 输出 Hello World return 0; //终止main函数并返回0值&#125; C++内置数据类型：类型&emsp;&emsp;&emsp;&emsp;关键字&emsp;&emsp;&emsp;&emsp;内存(字节)布尔型 &emsp;&emsp;&emsp;bool&emsp;&emsp;&emsp;&emsp;&emsp;1字符型 &emsp;&emsp;&emsp;char&emsp;&emsp;&emsp;&emsp;&emsp;1整型 &emsp;&emsp;&emsp;&emsp;int&emsp;&emsp;&emsp;&emsp;&emsp;&nbsp;&nbsp;&nbsp;4浮点型 &emsp;&emsp;&emsp;float&emsp;&emsp;&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;4双浮点型 &emsp;&emsp;double&emsp;&emsp;&emsp;&emsp;8无类型 &emsp;&emsp;&emsp;void&emsp;&emsp;&emsp;&emsp;&emsp;宽字符型 &emsp;&emsp;wchar_t&emsp;&emsp;&emsp;&nbsp;&nbsp;4一些类型可用修饰符修饰:signed,unsigned,short,long.Tip:其实知道了字节数很简单计算范围，1字节=8位，每位存储一个二进制0/1，有几位二进制则可以存储2^位数范围大小的数字。Tip:存储有符号数的时候，例如int，虽然是4字节的，但是只能是1符号位+31数值为位，所以最大为2^31=2147483647。可以使用typedef为一个已有的类型取一个新的名字:typedef type newname;12typedef int SSS;SSS a = 2; 枚举类型(enumeration)：是C++中的一种派生数据类型，它是由用户定义的若干枚举常量的集合:语法为:enum name {IDentifier0[=int 0],IDentifier1=[int 1]} Variable;12enum color &#123; red, green, blue &#125; c; //定义变量c是枚举类型colorc = blue; //c赋值为blue 变量声明和定义:您可以使用extern关键字在任何地方声明一个变量。虽然您可以在 C++ 程序中多次声明一个变量，但变量只能在某个文件、函数或代码块中被定义一次。123456789101112// 变量声明extern int a; //可进行多次int main ()&#123; // 变量定义 //仅可进行一次 int a; // 实际初始化 a = 10; return 0;&#125; 函数声明和定义:在函数声明时，提供一个函数名，而函数的实际定义则可以在任何地方进行。1234567891011121314// 函数声明int func();int main ()&#123; // 函数调用 int i = func(); return 0;&#125;// 函数定义int func()&#123; return 666;&#125; 变量作用域: 在函数或一个代码块内部声明的变量，称为局部变量。 在函数参数的定义中声明的变量，称为形式参数。 在所有函数外部声明的变量，称为全局变量。 初始化:定义全局变量时，系统会根据数据类型自动初始化；定义局部变量时，系统不会自动初始化。 C++常量:定义后不能进行修改的固定值。整数常量: 前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制 后缀指定修饰符:是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。 浮点常量：由整数部分、小数点、小数部分和指数部分组成。 小数形式：必须包含整数部分、小数部分，或同时包含两者。 指数形式：必须包含小数点、指数，或同时包含两者。带符号的指数是用 e 或 E 引入的。 布尔常量：true/false字符常量：括在单引号中的可以是一个普通的字符（例如 ‘x’）、一个转义序列（例如 ‘\\t’），或一个通用的字符（例如 ‘\\u02C0’）。 宽字符常量：以 L（仅当大写时）开头存储在 wchar_t 类型的变量中（例如 L’x’）。 窄字符常量：存储在 char 类型的简单变量中（例如 ‘x’）。 字符串常量：括在双引号 “” 中的。一个字符串包含类似于字符常量的字符：普通的字符、转义序列和通用的字符。C++有两种简单定义常量方式: 使用 #define 预处理器:#define identifier value 使用 const 关键字:const type variable = value; Tips:常量一般被定义成大写字母形式 C++ 修饰符类型修饰符 signed、unsigned、long 、short可应用于整型，signed 和 unsigned可应用于字符型，long 可应用于双精度型。修饰符 signed 和 unsigned 也可以作为 long 或 short 修饰符的前缀。例如：unsigned long int。 C++ 类型限定符用于限定类型和类型成员的声明 const：限定对象在程序执行期间不能被修改改变。 volatile：限定变量的值可能以程序未明确指定的方式被改变。(多线程使用) C++ 存储类存储类定义 C++ 程序中变量/函数的范围（可见性）和生命周期，常有auto、static、extern、mutable、thread_local (C++11)。auto关键字用于两种情况： 声明变量时根据初始化表达式自动推断该变量的类型。 声明函数时函数返回值的占位符。1234auto f=3.14;cout&lt;&lt;typeid(f).name()&lt;&lt;endl; //doubleauto z = new auto(9); cout&lt;&lt;typeid(z).name()&lt;&lt;endl; // int* static关键字指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。 static修饰局部变量：变量在全局数据区分配内存，程序执行第一次时首次初始化，以后函数调用不再进行初始化，没有显式初始化则会被自动初始化为0。 static修饰全局变量：使变量的作用域限制在声明它的文件内。 static修饰类的成员变量：类外初始化，先于类存在，类所有对象共同一个静态成员变量，可通过类名直接调用公共(public)静态成员变量。123456789101112131415class A&#123;public: A()&#123; count++; &#125; //先于类存在，在类的构造方法中已经可以调用 static int count;&#125;;int A::count = 0; //类外初始化int main()&#123; A c; A d; cout &lt;&lt; A::count &lt;&lt; endl; //共用性和直接类名调用 system(&quot;pause&quot;); return 0;&#125; static修饰类的成员方法:先于类存在，方法中不能使用非静态成员(无this指针),可通过类名直接调用公共(public)静态成员方法。12345678910111213141516171819class A&#123;public: A()&#123; count++; &#125; static int count; static void showCount() &#123; cout &lt;&lt; &quot;count is &quot; &lt;&lt; count &lt;&lt; endl; //不用this指针织带变量 &#125;&#125;;int A::count = 0; int main()&#123; A c; A d; A::showCount(); //类名直接调用 system(&quot;pause&quot;); return 0;&#125; C++ 运算符运算符是一种告诉编译器执行特定的数学或逻辑操作的符号,有算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符和其他运算符。算数运算符:+、-、、/、%(取模,整除后的余数)、++(自增)、–(自减).关系运算符:==、!=、&gt;、&lt;、&gt;=、&lt;=.逻辑运算符:&amp;&amp;(逻辑与，均非零为真)、||(逻辑或，存在非零则为真)、!(逻辑非，逆转逻辑状态).Tips:&amp;&amp;(||)具有短路功能，即若第一个条件为false(true)，则不再计算第二个表达式；&amp;(|)则无论如何均会计算两个表达式.利用这点可将A&amp;&amp;B中的A作为一个条件语句(if)不满足则不执行B，如下1234567891011121314151617/*不用任何循环语句，不用if，来实现1+2+3+...+10的值*/#include &lt;iostream&gt;using namespace std;int add(int c)&#123; int a=0; c&amp;&amp;(a=add(c-1));//递归循环，直到传入c的值为0则结束循环不执行右式 //(用&amp;则会执行造成溢出错误) cout&lt;&lt;c+a&lt;&lt;endl; return c+a;&#125;int main()&#123; add(10); return 0;&#125;位运算:若A = 60，且 B = 13，以二进制表示如下A = 0011 1100B = 0000 1101赋值运算:=、+=、-=、=、/=、%=、&lt;&lt;=、&gt;&gt;=、&amp;=(按位与或且赋值)、^=(按位异或且赋值)、|=(按位或且赋值)杂项运算: C++ 循环 while:1234while(condition)&#123; statement(s);&#125; for:1234for ( init; condition; increment )&#123; statement(s);&#125; do…while:12345do&#123; statement(s);&#125;while( condition ); 循环控制语句: break：跳出循环。 continue:跳过循环主体的剩余部分，立即重新开始测试条件。 C++ 判断 if:1234if(boolean_expression)&#123; statement(true); // 如果布尔表达式为真将执行的语句&#125; if…else:12345678if(boolean_expression)&#123; statement(true); // 如果布尔表达式为真将执行的语句&#125;else&#123; statement(false); // 如果布尔表达式为假将执行的语句&#125; switch:123456789101112switch(expression)&#123; case constant-expression : statement(s); break; // 可选的 case constant-expression : statement(s); break; // 可选的 // 您可以有任意数量的 case 语句 default : // 可选的 statement(s);&#125; [ ? : ]运算符:1Exp1 ? Exp2 : Exp3; C++ 函数函数声明包含函数的名称、返回类型和参数C++中的函数声明形式：1return_type function_name( parameter list );函数定义提供了函数的实际主体。C++中的函数定义形式：1234return_type function_name( parameter list )&#123; body of the function&#125;函数参数:函数内使用的局部变量称作形式参数，有三种调用方式 传值调用(默认)：把参数的实际值复制给形式参数。在这种情况下，修改函数内的形式参数不会影响实际参数。 指针调用：把参数的地址复制给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。修改形式参数会影响实际参数。如函数声明:void swap(int *x, int *y)函数调用:swap(&amp;a,&amp;b) 引用调用：把参数的引用赋值给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。如函数声明:void swap(int &amp;x, int &amp;y)函数调用:swap(a,b) 参数默认值:定义函数时可以为参数列表中每一个参数指定默认值,如int sum(int a=10,int b=20)Lambda 函数与表达式:Lambda 表达式把函数看作对象。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。 C++ 数字数学运算:引用数学头文件 内有许多内置数学函数随机数:标准库（被包含于中）提供两个帮助生成伪随机数的函数 void srand(unsigned seed)：设置随机数种子，通常用time()初始化(使用time需要引入头文件)，如srand( (unsigned)time( NULL ) ); int rand(void)：从srand (seed)中指定的seed开始，返回一个[seed, RAND_MAX（0x7fff）)间的随机整数。 指定生成范围的随机数1234(low,up) (rand()%(up-low+1)) + low - 1[low,up) (rand()%(up-low)) + low(low,up] (rand()%(up-low))+ low + 1[low,up] (rand()%(up-low+1)) + low C++ 数组声明数组:type arrayName [ arraySize ];初始化数组:type arrayName [ arraySize ] = { data } ;访问数组元素:数组名称+索引，arrayName[index];数组详解: 多维数组:type arrayName[size1][size2]…[sizeN]; 数组指针:声明的数组名其实是指向数组第一个元素的指针，即*arrayName == &amp;arrayName[0]所以也可以使用指针形式访问数组*(arrayName + i ) == arrayName[i] 传递数组给函数:是以指针的形式传递的，因此有三种传递方式：(type *param)(type param[size])(type param[]) 函数返回数组:数组以指针的形式返回的，另外C++不支持在函数外返回局部变量的地址，因此返回的数组需要均是static变量 C++ 字符串 C风格字符串:实质是一个以’\\0’(null)结尾的char数组，例如123//以下msg1和msg2初始化规则相同char msg1[6] = &#123;&apos;H&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, &apos;o&apos;, &apos;\\0&apos;&#125;;char msg2[] = &quot;Hello&quot;; C++有大量函数操作以null结尾的字符串： C++引入的 string 类类型:C++标准库提供了string类型(需引入#include &lt; string >库)且支持上述函数操作1234string str1 = &quot;Hello&quot;;string str2 = str1; //复制string str3 = str1 + str2; //连接int length = str3.size(); //长度 C++ 指针 内存地址:每个C++变量都有一个内存地址，可用寻址（&amp;）运算符访问变量的内存地址 指针:是一个特殊的变量，其值为另一个变量的内存地址，声明形式为:type *var-name; 使用指针:过程一般为声明、存储、访问（对指针使用间址(*)运算符可访问指针存储地址的变量值）12345678string str = &quot;Hello&quot;;string *ip;ip = &amp;str;cout &lt;&lt; &quot;Address of str : &quot; &lt;&lt; &amp;str &lt;&lt; endl;cout &lt;&lt; &quot;Value of str : &quot; &lt;&lt; str &lt;&lt; endl;cout &lt;&lt; &quot;Stored Address of ip : &quot; &lt;&lt; ip &lt;&lt; endl; //指针存储的变量的地址cout &lt;&lt; &quot;Address of ip : &quot; &lt;&lt; &amp;ip &lt;&lt; endl; //指针本身的地址cout &lt;&lt; &quot;Value of ip : &quot; &lt;&lt; *ip &lt;&lt; endl; 执行结果如下: Null指针:指针初始化时指定NULL值被称作空指针可以避免越界使用指针1type *ptr = NULL; 指针的算数运算:指针是一个用数值表示的地址，可以执行四种算数运算（++，–，+，-）具体运算数值与指针的类型有关(如整形指针一次递增4个字节，字符指针一次递增1个字节等) 指针与数组的异同:（同）均可通过指针的算数运算和数组索引来访问数组（异）声明数组的数组名的指针是一个指向数组第一个元素地址的常量指针，不可改变指向的地址 指针数组:可声明一个数组来存放指针，其中每个数组元素都是一个指针，如type *ptr[size]; 多级指针:一个指针指向另一个指针的地址123type var;type *ptr1 = &amp;var;type *ptr2 = &amp;ptr1; //ptr2就是一个多级指针指向一级指针ptr1 指针参数:声明函数参数为指针类型即可，这种属于指针调用函数参数，将参数地址复制给函数的形式参数，在函数内修改形式参数会影响实际参数。 函数返回指针类型:声明函数返回类型为指针类型即可，但由于C++不支持在函数外返回局部变量的地址，因此可返回指针类型的变量需要声明为static变量。 C++ 引用引用变量是一个实际变量的别名。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。 引用于指针的区别:1.引用必须在创建时初始化，指针可以在任何时间初始化。2.引出初始化为一个对象后不能更改，指针可以在任何时候指向另一个对象。3.不存在空引用，引用必须连接到一个合法内存。 引用创建初始化使用:type&amp; name = variable; 引用参数:声明函数参数为引用类型即可，属于引用调用的函数参数。这比传一般参数安全。 函数返回引用类型:声明函数返回类型为引用类型，但是实际上函数返回一个引用时是返回一个指向返回值的隐式指针，这样函数可以放在赋值语句的左边。返回引用最大的好处是在内存中不产生被返回值的副本，节省内存，但是不能返回局部变量的引用。 C++ 日期和时间C++继承了C语言用于日期和时间操作的结构和函数,需要引入 &lt; ctime > 头文件 有四个与时间有关的类型，其中clock_t、time_t、size_t 将系统时间和日期表示为某种整数，tm结构类型将日期和时间以C结构形式保存。 C/C++中关于日期和时间的重要函数:1.time(): 返回从 1970-01-01 到 当前的日历时间的秒数123//函数原型:time_t time(time_t *t)time_t nowSeconds = time(NULL);cout &lt;&lt; nowSeconds &lt;&lt; endl; 2.ctime():返回一个格式为[Www Mmm dd hh:mm:ss yyyy]基于参数timer的时间的字符串1234//函数原型:char *ctime(const time_t *timer)#pragma warning(disable:4996) //接触安全警报限制time_t curtime = time(NULL);cout &lt;&lt; ctime(&amp;curtime) &lt;&lt; endl; 3.localtime(): struct tm *localtime(const time_t *timer)，将参数timer的值分解为tm结构，并用本地时区表示12345678910//函数原型:struct tm *localtime(const time_t *timer)#pragma warning(disable:4996) //接触安全警报限制time_t curtime = time(NULL);struct tm *info = localtime(&amp;curtime);cout &lt;&lt; &quot;tm_sec:&quot; &lt;&lt; info-&gt;tm_sec &lt;&lt; endl;cout &lt;&lt; &quot;tm_min:&quot; &lt;&lt; info-&gt;tm_min &lt;&lt; endl;cout &lt;&lt; &quot;tm_hour:&quot; &lt;&lt; info-&gt;tm_hour &lt;&lt; endl;cout &lt;&lt; &quot;tm_mday:&quot; &lt;&lt; info-&gt;tm_mday &lt;&lt; endl;cout &lt;&lt; &quot;tm_mon:&quot; &lt;&lt; info-&gt;tm_mon &lt;&lt; endl;cout &lt;&lt; &quot;tm_year:&quot; &lt;&lt; info-&gt;tm_year &lt;&lt; endl; 4.clock(): 返回程序执行起处理器时钟所使用的时间，为了获取CPU所使用秒数需要除以CLOCKS_PER_SEC常量12345678910111213//函数原型:clock_t clock(void)#pragma warning(disable:4996) //接触安全警报限制clock_t start_t, end_t;start_t = clock();cout &lt;&lt; &quot;程序启动：&quot; &lt;&lt; start_t &lt;&lt; endl;for(int i=0; i&lt; 10000000; i++)&#123;&#125;end_t = clock();cout &lt;&lt; &quot;程序结束：&quot; &lt;&lt; end_t &lt;&lt; endl;double total_t;total_t = (double)(end_t - start_t) / CLOCKS_PER_SEC;cout &lt;&lt; &quot;CPU占用时间:&quot; &lt;&lt; total_t &lt;&lt; endl; 5.asctime()：返回一个基于timeptr的时期和时间的字符串的指针12345//函数原型:char *asctime(const struct tm *timeptr)#pragma warning(disable:4996) //接触安全警报限制time_t curtime = time(NULL);struct tm *info = localtime(&amp;curtime);cout &lt;&lt; asctime(info) &lt;&lt; endl; 6.gmtime():使用timer来填充tm的结构，并协调世界时(UTC)也被称作格林尼治标准时间(GMT)表示12345//函数原型:struct tm *gmtime(const time_t *timer)#pragma warning(disable:4996) //接触安全警报限制time_t curtime = time(NULL);struct tm *info = gmtime(&amp;curtime);cout &lt;&lt; asctime(info) &lt;&lt; endl; 7.mktime():将tm结构的timer转换成一个依据本地时区的time_t值123456//函数原型:time_t mktime(struct tm *timeptr)#pragma warning(disable:4996) //接触安全警报限制time_t curtime = time(NULL);struct tm *info = localtime(&amp;curtime);time_t localtime = mktime(info); cout &lt;&lt; ctime(&amp;localtime) &lt;&lt; endl; 8.difftime(): 返回time1和time2之间的相差秒数1234567891011// double difftime(time_t time1, time_t time2)#pragma warning(disable:4996) //接触安全警报限制#include &lt;windows.h&gt; //sleep函数time_t start_t, end_t;time(&amp;start_t);cout &lt;&lt; &quot;程序启动：&quot; &lt;&lt; start_t &lt;&lt; endl;Sleep(5632);time(&amp;end_t);cout &lt;&lt; &quot;程序结束：&quot; &lt;&lt; end_t &lt;&lt; endl;double diff_t = difftime(end_t, start_t); //以秒为单位精度是double我也不太清楚为什么....cout &lt;&lt; &quot;程序占用时间:&quot; &lt;&lt; diff_t &lt;&lt; endl; 9.strftime(): size_t strftime(char *str, size_t maxsize, const char *format, const struct tm *timeptr)，根据format中定义的格式化规则，格式化数据结构timeptr表示的时间，并把它存储在str中12345time_t now = time(NULL);struct tm *info = localtime(&amp;now);char buffer[80];strftime(buffer, 80, &quot;%x - %I:%M%p&quot;, info);cout &lt;&lt; &quot;格式化时间：&quot; &lt;&lt; buffer &lt;&lt; endl; C++ 基本输入输出 C++的I/O 发生在流中，流是字节序列。输入操作：字节流是从设备（如键盘、磁盘驱动器、网络连接等）流向内存。输出操作：字节流是从内存流向设备（如显示屏、打印机、磁盘驱动器、网络连接等）。 I/O 库头文件：1.标准输出流(cout):是ostream类的实例，与运算符&lt;&lt;将对象连接到标准输出设备2.标准输入流(cin):是istream类的实例，与运算符&gt;&gt;将对象连接到标准输入设备3.标准错误流(cerr):是ostream类的实例，是非缓冲的，每个流插入cerr会立即输出4.标准日志流(clog):是ostream类的实例，是缓冲的，每个流插入clog会先存储到缓冲区直到其填满或者刷新时才会输出 C++ 结构用户自定义的数据类型，允许存储不同类型的数据项，格式如下1234567struct type_name &#123;member_type1 member_name1;member_type2 member_name2;member_type3 member_name3;..&#125; object_names; 访问结构成员:使用成员访问运算符(.)，如1object_names.member_name 访问指向结构的指针:可定以指向结构的指针，则使用指针访问运算符(-&gt;)，如12struct type_name *struct_ptr = &amp;object_names;struct_pointer-&gt;title","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://harviealwayshere.github.io/tags/C/"}]},{"title":"粤语歌单","slug":"musicYueYu","date":"2018-01-30T08:34:19.000Z","updated":"2018-01-31T09:45:01.985Z","comments":true,"path":"2018/01/30/musicYueYu/","link":"","permalink":"https://harviealwayshere.github.io/2018/01/30/musicYueYu/","excerpt":"","text":"今天推荐的歌单是粤语抒情相关的，怎么说呢，感觉粤语歌与普通话的歌听觉上有所不同，粤语歌的咬文嚼字可能并不需要那么清晰，但是情感却十分饱满浓郁。第一位着重推荐的是我喜欢的比较冷门的粤语歌手侧田，听他的歌总是能感受的到他的力量、他的硬朗，能身临其境地走入他的内心感受他歌唱时的情感，听他的歌总能汲取歌中的能量，让听众奋发向上。 第二位推荐的是杨千嬅，她总是吟唱悲伤无助的歌曲，高亮干净的嗓音让她的歌总是令人心生怜意，比较适合一个人、悲伤的时候听，也许她的歌可以让你明白，悲剧才是最感动的。 第三位推荐的是谢安琪，”男不听七友，女不听钟无艳”相比很多人都听过，都是伤感情歌，谢安琪更是把以好友身份苦恋无果、甘做备胎的状态演唱的淋漓尽致。由于版权原因，请移步钟无艳 试听。","categories":[{"name":"Music","slug":"Music","permalink":"https://harviealwayshere.github.io/categories/Music/"}],"tags":[{"name":"粤语","slug":"粤语","permalink":"https://harviealwayshere.github.io/tags/粤语/"},{"name":"music","slug":"music","permalink":"https://harviealwayshere.github.io/tags/music/"}]},{"title":"使用Hexo和Markdown写作","slug":"hexoWrite","date":"2018-01-27T10:03:33.000Z","updated":"2018-01-30T08:30:23.412Z","comments":true,"path":"2018/01/27/hexoWrite/","link":"","permalink":"https://harviealwayshere.github.io/2018/01/27/hexoWrite/","excerpt":"","text":"终于开始激动人心的写博客环节了，但是在hexo上写博客跟word上写博客可不太一样。 Hexo特性：hexo可以用命令行创建文章，hexo可以自定义写作布局layout，hexo的资源文件的引用 Markdown语法：hexo生成的文章都是.md格式，需要使用特殊的编辑器来进行写作，还有特殊的markdown写作语法 资源的引用：使用外链（图床）和本地引用方法 严格规范markdown语法看来写博客也是一件不省心的事情，就让我们按部就班一步步来看看各个环节的特性吧。 1.Hexo特性建议参考官方文档&emsp; &emsp;&emsp;&emsp;&emsp;1.1 修改layout布局：&emsp;&emsp;&emsp;&emsp;打开博客文件夹根目录下的[scaffolds]中的[post.md]文件，可以看到初始只有title/date/tags三种文件变量称作Front-matter,可以添加updated/categories等基本变量如下&emsp;&emsp;&emsp;&emsp;Tips:并列的tips需要使用- (-和空格)否则会编译出错 &emsp;&emsp;&emsp;&emsp;1.2 创建文章语法：1$ hexo new [layout] &lt;title&gt; &emsp;&emsp;&emsp;&emsp;1.3 Hexo自带语法：&emsp;&emsp;&emsp;&emsp;Hexo也有一些用于写作的不同于md的基本语法称作标签插件(Tag Plugins)比如引用块真是不知命运所馈赠的礼物，早已在暗中标明了价格。 茨威格断头王后比如代码块1alert(&apos;Hello World!&apos;); 2.Markdown语法&emsp;&emsp;&emsp;&emsp;Markdown语法很多很细致但是很简单，网上有很多文章介绍，这里我就推荐一个写的很好的博主文章供大家学习，相信很多人都是看这篇文章入门的，我就不露丑介绍了。 3.资源引用&emsp;&emsp;&emsp;&emsp;相信很多人在写博文为了增强用户体验都会插入一些图片表达，md中都是依靠链接来插入图片的，唯一不同的是这个链接是本地链接还是外部链接呢，本地链接无风险但是插入的图片会占据github空间而且不灵活不好分享毕竟我们写的博文都是需要部署到github上的，外部链接节省github空间但是万一失效了图片就显示不出来了俗称图片挂了，我个人原则是 小图片用本地链接大图片可以尝试外部链接，重要图片用本地链接稍微不那么关键的图片用外部链接。 &emsp;&emsp;&emsp;&emsp;3.1 本地链接的使用：&emsp;&emsp;&emsp;&emsp;本地链接的使用其实很简单，但是由于图片在本地路径和在生成($ hexo g)文件的路径并不相同，所以我的做法是首先将图片放在跟博文文件一个目录下，在本地预览完成需要部署的时候，再将图片剪切到[博客根目录/source/images/]文件夹里面同时要修改博文中对于图片的引用变成(/images/picture.png)因为编译后图片放在网站根目录的images中。 &emsp;&emsp;&emsp;&emsp;3.2 外部链接的使用：&emsp;&emsp;&emsp;&emsp;外部链接的使用其实就是利用一些网站服务器的空间来存储你的图片俗称图床，在博文中直接使用直接路径调用图片，如类似这种链接https://i.loli.net/2018/01/25/5a69a60eeda77.gif&emsp;&emsp;&emsp;&emsp;图床有许多，有免费的也有收费的，有些有浏览流量的限制，收费的我推荐七牛云,免费的我推荐SM.MS,用到现在还没有出现挂图的迹象。&emsp;&emsp;&emsp;&emsp;Tips：其实图床蛮多托的，有人建议直接放在github仓库上用绝对连接访问就好。 在repository的根目录下建立文件夹，然后将图片放在其中，在写链接的时候直接使用自己的GitHub Pages根路径加图片地址访问即可。 4.严格规范markdown语法&emsp;&emsp;&emsp;&emsp;Markdown语法看似简单，其实有许多坑需要踩。比如最简单的用[###]表示字体大小，也许在markdown编辑器上可以直接使用[###你好]表示，但是生成页面的时候却显示不出来，这是因为[#]的严格语法是[#+空格+内容]，缺少一个空格将会造成无法编译。还有一些小技巧，比如想打出空格,换行，底色等，最好还是用字符或者Html语法的形式，如下1234567&amp;emsp; //空格&lt;br&gt; //换行&lt;font face=&quot;微软雅黑&quot;&gt;&lt;/font&gt; //字号&lt;font color=red&gt;&lt;/font&gt; //字体颜色&lt;font color=#0099ff size=7&gt;&lt;/font&gt; //字体[1-7]&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=orange&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; //背景色--- //分割线 相信你已经初步了解怎么使用hexo和markdown语法写作了，你肯定迫不及待地想写下自己第一篇博文打了吧，去吧！","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://harviealwayshere.github.io/tags/Hexo/"},{"name":"GithubPages","slug":"GithubPages","permalink":"https://harviealwayshere.github.io/tags/GithubPages/"}]},{"title":"大三上寒假计划","slug":"planOfHoliday","date":"2018-01-27T09:13:41.000Z","updated":"2018-01-30T08:30:21.686Z","comments":true,"path":"2018/01/27/planOfHoliday/","link":"","permalink":"https://harviealwayshere.github.io/2018/01/27/planOfHoliday/","excerpt":"","text":"我的寒假学习计划同时也是博客的更新计划，大致有以下几个方面： 算法：LeetCode、牛客网、剑指Offer的题目解法总结 专业相关：机器学习的实践相关内容总结 实战：Laravel框架的学习和一个网页功能开发实战的更新总结 python：python相关的库使用，如爬虫、机器学习、可视化、游戏等 影评：休闲之时也会写一些影评推荐一些精品电影给大家（资源也会放出来） 每部分的更新频率不一定，但是会尽量面面俱到、频繁更新的，敬请期待哦！","categories":[{"name":"Life","slug":"Life","permalink":"https://harviealwayshere.github.io/categories/Life/"}],"tags":[{"name":"Plan","slug":"Plan","permalink":"https://harviealwayshere.github.io/tags/Plan/"}]},{"title":"使用github pages和hexo搭建个人博客","slug":"gitPagesAndHexo","date":"2018-01-14T12:51:14.000Z","updated":"2018-01-30T08:30:24.530Z","comments":true,"path":"2018/01/14/gitPagesAndHexo/","link":"","permalink":"https://harviealwayshere.github.io/2018/01/14/gitPagesAndHexo/","excerpt":"","text":"大致步骤可以分为6步 下载安装Node.js（可以使用npm下载和管理包） 申请github账户（用于注册github pages仓库） 下载git（最好是bash 便于使用命令行操作系统） 安装hexo并配置基本参数 安装hexo主题并配置基本参数 博客部署到github pages上线 1. 下载安装Node.js（可以使用npm下载和管理包）1.1访问Node.js中文官网下载安装包:根据你的操作系统和系统类型（位数）选择下载哪一个安装包Tips：32位安装包兼容64位操作系统，64位安装包不兼容32位操作系统&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;建议使用.msi格式一键安装&nbsp;&nbsp;1.2安装Node.js:&emsp;&emsp;&emsp;&emsp;.zip文件：运行node.exe文件会跳出命令行安装&emsp;&emsp;&emsp;&emsp;.msi文件:根据提示步骤安装（安装路径最好是全英文）1.3测试是否安装成功:&emsp;&emsp;&emsp;&emsp;1.3.1 打开命令提示符:&emsp;&emsp;&emsp;&emsp;windows系统下用+R）打开运行窗口输入cmd打开命令提示符&emsp;&emsp;&emsp;&emsp;1.3.2： 输入命令 node -v 和npm -v 查看node.js和npm是否安装成功：&emsp;&emsp;&emsp;&emsp; &emsp;&emsp;&emsp;&emsp; 若有版本号（不一定与我的相同）则安装成功 否则安装失败则重新安装即可 2. 申请github账户（用于注册github pages仓库）&emsp;&emsp;&emsp;&emsp;2.1 访问github官网注册账号&emsp;&emsp;&emsp;&emsp;2.3 申请一个仓库:&emsp;&emsp;&emsp;&emsp;登录你的github账号点击上方的New repository 如下图所示&emsp;&emsp;&emsp;&emsp;在Repository name上填写 [你注册的github名称.github.io] 即可&emsp;&emsp;&emsp;&emsp;如我注册的github名称是xxx则我的Repository name为 [xxx.github.io]&emsp;&emsp;&emsp;&emsp;其他的都不用填写 之后点击[Create repository]即可 3. 下载安装git（最好是bash 便于使用命令行操作系统） Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 此部分内容建议参考廖雪峰老师的git安装文档&emsp;&emsp;&emsp;&emsp;3.1 通俗来说git就是一个软件类似于cmd命令行，但是它可以使用git命令和linux命令来操控系统，这是cmd所做不到的。在此项目中，我们主要使用它来编写npm命令、hexo命令、git命令来生成和部署自己的博客到github pages上&emsp;&emsp;&emsp;&emsp;访问git下载页面下载对应系统的git &emsp;&emsp;&emsp;&emsp;安装完毕之后打开gitbash即可使用&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;首次使用git的用户还需配置自己的用户名和地址用于验证身份：12$ git config --global user.name &quot;Your Name&quot; $ git config --global user.email &quot;email@example.com&quot; &emsp;&emsp;&emsp;&emsp;3.2 将计算机的ssh key设置到你的github账号上，你才能将本地的文件上传到你的github上面&emsp;&emsp;&emsp;&emsp;具体操作可参考廖雪峰老师的ssh key设置教程 4. 全局安装hexo建立自己的博客并配置基本参数此部分内容建议参考hexo官方文档&emsp;&emsp;&emsp;&emsp; 4.1 全局安装hexo：&emsp;&emsp;&emsp;&emsp;访问hexo官方网站查看安装命令，运行Git Bash输入安装命令npm install hexo-cli -g&emsp;&emsp;&emsp;&emsp; 4.2 建立自己的博客：在Git Bash中输入123$ hexo init [你的博客文件夹名称] $ cd [你的博客文件夹名称] $ npm install&emsp;&emsp;&emsp;&emsp;我这里演示的文件夹名称是[testBlog]&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Tips:输入pwd可查看当前文件夹的路径&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&nbsp;输入explorer .可打开命令行当前文件夹&emsp;&emsp;&emsp;&emsp;如果看到以下内容，那么恭喜你hexo建站成功了&emsp;&emsp;&emsp;&emsp; &emsp;&emsp;&emsp;&emsp; 4.3 配置基本参数博客本地预览&emsp;&emsp;&emsp;&emsp;您可以在 _config.yml 文件中修改大部份的配置具体参数意义可参考官方文档&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;输入以下命令可在本地预览你生成的博客网址123$ npm install hexo-server --save $ hexo generate$ hexo server &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;你可以像我一样用[$ hexo g]和[$ hexo s]来简化命令&emsp;&emsp;&emsp;&emsp;[$ npm install hexo-server –save]用来安装hexo本地预览的服务器 只用第一次执行一次就可以了&emsp;&emsp;&emsp;&emsp;以后每次改动就只用[$ hexo g]生成文件和[$ hexo s]启动服务器就可以了&emsp;&emsp;&emsp;&emsp;之后在浏览器输入[http://localhost:4000]就可以查看你的博客页面了&emsp;&emsp;&emsp;&emsp; 5. 安装hexo主题并配置基本参数&emsp;&emsp;&emsp;&emsp;到目前为止，是不是觉得hexo默认的主题不符合你的心意，没关系，hexo爱好者们提供了上千个主题供你挑选使用，安装主题的方法也十分简单，让我们一起来让博客的面目焕然一新吧&emsp;&emsp;&emsp;&emsp;5.1 挑选你喜爱的主题下载&emsp;&emsp;&emsp;&emsp;可以参考官方主题推荐文档或者github大神整理来寻找自己喜欢的主题并按照对应主题的文档说明下载使用&emsp;&emsp;&emsp;&emsp;如我的博客采用的主题是Huemen下载就十分简单，按照官方文档按部就班即可&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;5.2 配置主题的基本参数：&emsp;&emsp;&emsp;&emsp;主题的配置是类似于hexo配置，修改主题文件下中的[_config.yml]文件即可具体每个参数的意义请参考主题的说明文档&emsp;&emsp;&emsp;&emsp;5.3 配置成功之后可运行命令预览自己的博客了（在博客根目录下运行命令）123$ hexo clean $ hexo g $ hexo s 6. 博客部署到github pages上线&emsp;&emsp;&emsp;&emsp;6.1 安装git pages部署器：在博客根目录下打开git bash运行[$ npm install hexo-deployer-git –save]命令&emsp;&emsp;&emsp;&emsp;6.2 修改博客根目录下的配置文件[_config.yml]中的deploy参数：123deploy: type: git repo: [你注册的github pages的仓库地址] &emsp;&emsp;&emsp;&emsp;6.3 部署至github上：12$hexo generate $hexo deploy &emsp;&emsp;&emsp;&emsp;或者1$hexo d -g&emsp;&emsp;&emsp;&emsp;成功之后你可以在线访问你的github pages地址[你的github仓库名.github.io]来查看你的博客了 恭喜你，你的博客已经搭建成功并上线了! 之后我会再写一篇文章介绍hexo写作的基本方法、使用markdown格式写作、图床的使用技巧等博文写作知识，敬请期待。","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://harviealwayshere.github.io/tags/Hexo/"},{"name":"GithubPages","slug":"GithubPages","permalink":"https://harviealwayshere.github.io/tags/GithubPages/"}]}]}