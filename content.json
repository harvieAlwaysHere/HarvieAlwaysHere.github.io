{"meta":{"title":"Harvie Blog","subtitle":"Fright For Better Day","description":"IT Blog","author":"Harvie Yao","url":"https://harviealwayshere.github.io"},"pages":[{"title":"about","date":"2018-01-30T09:37:04.000Z","updated":"2018-01-30T09:37:04.587Z","comments":true,"path":"about/index.html","permalink":"https://harviealwayshere.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"腾讯后台开发面试总结","slug":"txmianshi","date":"2018-04-25T13:04:38.000Z","updated":"2018-04-27T03:50:07.152Z","comments":true,"path":"2018/04/25/txmianshi/","link":"","permalink":"https://harviealwayshere.github.io/2018/04/25/txmianshi/","excerpt":"","text":"总结腾讯后台开发所遇到的问题大纲Linux和操作系统OSnetstat命令：显示网络连接状态 netstat -a：显示tcp、udp和unix协议下套接字的所有连接 netstat -t：tcp协议连接 netstat -u：udp协议连接 netstat -n：默认netstat会通过反向域名解析技术查找每个ip地址对应的主机名，会降低查找速度，如果仅直到ip地址即可，可通过-n禁用域名解析功能 netstat -l：只列出监听中的连接，-tl列出监听状态的tcp端口和连接，-ul列出监听状态的udp端口和连接，不能使用-al这会列出所有连接 netstat -p：查看端口号的同时查看对应的进程名和进程号 netstat -s：打印网络统计数据，包括协议下的收发包数量 netstat -r：打印内核路由情况 netstat -i：打印网络接口信息 netstat -c：持续输出信息 netstat -aple | grep +服务：可以查看http、smtp、ntp等服务是否在运行 tcpdump命令：即dump the traffic on a network根据使用者的定义对网络上的数据包进行截获的包分析工具。tcpdump可以将网络中传送的数据包的“头”完全截获下来提供分析。它支持针对网络层、协议、主机、网络或端口的过滤，并提供and、or、not等逻辑语句来帮助你去掉无用的信息。 tcpdump -c number：限制截获number数量的数据包 tcpdump -q：精简模式显示 ipcs命令：报告进程间通信设施状态，包括共享内存，消息队列，信号量等 ipcs -a：打印出当前系统所有进程通信方式信息 ipcs -m -q -s：分别打印出使用共享内存、消息队列、信号进行进程通信的信息 ipcs -t：输出信息的详细时间变化 ipcs -p：输出创建ipc方式的进程ID ipcs -c：输出ipc方式的创建者、拥有者 ipcs -u：输出当前系统下ipc方式的状态信息 ipcrm命令：移除一个消息对象、共享内存段、信号集，同时会将与ipc对象相关链的数据也一起移除，只有超级管理员，或者ipc对象的创建者才有这项权利 ipcrm -M shmkey：移除用shmkey创建的共享内存段 ipcrm -m shmid：移除用shmid标识的共享内存段 ipcrm -Q msgkey：移除用msqkey创建的消息队列 ipcrm -q msqid：移除用msqid标识的消息队列 ipcrm -S semkey：移除用semkey创建的信号 ipcrm -s semid：移除用semid标识的信号 关系系统命令方面的命令： top：实时显示进程状态 ps -ef|grep +进程名：查看进程名的进程状态 kill -9 +进程ID：强制杀死进程 chmod u+x +文件名：给予文件运行权限 find / -name “文件名”：搜索文件 关于文本编辑方面的命令： awk：报告生成器，格式化以后显示，对处理的文件数据生成报告 sed：Sed是Strem Editor(流编辑器)缩写，是操作、过滤和转换文本内容的强大工具。常用功能有增删改查，过滤，取行。 grep：文本搜集工具, 搜索文本，过滤文本字符串。 多线程和多进程的区别进程是资源分配的基本单位，一个进程可以有多个线程，多个进程可以并发执行线程是系统独立调度和CPU独立运行的基本单位，一个进程中的线程可以共享进程的资源 线程和进程的区别： 资源占用：进程时资源分配基本条件，线程不拥有资源只可以访问隶属进程的资源 CPU调度：线程是独立调度的基本单位，同一进程的线程切换不会引起进程切换，不同进程的线程切换会引起线程切换 系统开销：创建撤销进程时，系统都要分配或者回收资源，如内存空间、IO设备等，开销大于创建撤销线程。进程切换时系统要保存当前CPU执行环境和新调度进程的CPU环境设置，开销大于线程切换时仅需保存和设置少量寄存器内容 通信：进程间通信（IPC）需要使用同步、互斥手段，保持数据一致性，线程则可以通过读写同一进程的数据段（如全局变量）进行通信 并发和并行的区别：并发：系统的CPU小于线程数时，系统会将CPU运行时间划分为若干个时间段（时间片）,分配给各个线程执行，一个时间段的线程代码执行时另外的线程处于挂起状态并行：系统CPU大于同时运行的线程数时，每个CPU执行一个线程，多个线程不互相抢占CPU资源，可以同时执行 线程共享环境：进程代码段，进程共有数据(全局变量等),进程打开的文件描述符，进程的当前目录，进程用户ID，进程组ID线程私有环境：线程ID，寄存器组的值(将当前线程的寄存器集合状态保存再线程重新被切换时能回复原本的运行状态)，线程堆栈（保证调用的函数能正常执行不受其他线程影响），错误返回码，线程优先级 C语言辨别系统64位/32位：位指的是操作系统的位数，在C中直观的就是指针类型占用的字节数，32位系统指针占32位即4字节，64位系统指针占64位即8字节int main(){ int bits= sizeof(char *); if(bits == 4) printf(“32位\\n”); else if(bits == 8) printf(“64位\\n”); else printf(“others, bits = %d\\n”, bits);} 信号：是Linux系统中用来通知进程发生了异步事件，它是一种进程间的通信通知机制。[1,31]为Unix支持的传统信号，是不可靠信号(不实时，不支持排队（可能丢失）)，[32,63]是扩充信号，是可靠信号(实时信号，支持排队)产生信号： 终端组合键：如Ctrl+C发出信号2SIGINT，Ctrl+\\发出信号3SIGQUIT 硬件异常产生的信号：如当前进程执行了除以0的命令，CPU运算单元产生异常，内核会将异常解释为SIGFPE信号发给进程；如当前进程访问了非法地址，MMU会产生异常，内核会将异常解释为SIGSEG发送给进程 调用系统函数向进程发信号：如kill命令、raise函数给当前进程发送指定信号、abort函数给当前进程发送SIGABRT终止信号 由软件条件产生信号：调用软件函数如alarm函数发送SIGALRM信号 接受信号产生的动作： 忽略此信号 执行该信号的默认处理动作(终止该信号) 执行自定义的信号处理函数处理信号，称作捕捉信号 核心转储Core Dumped：当⼀个进程要异常终止时，可以选择把进程的用户空间内存数据全部保存到磁盘上，文件名通常是core，这叫做Core Dump。也叫核心转储，帮助开发者进行调试，在程序崩溃时把内存数据dump到硬盘上，让gdb识别。 数据库SQL语句优化： 使用索引查询：具体方法有在where、orderby语句中涉及的列上建立索引，避免全表查询，在where语句中不使用!=、不进行null值判断、不用or连接、in用between代替、不对字段进行表达式或者函数操作等，以上都是使用索引不进行全表查询的注意点 适当使用索引：若索引列有大量重复数据时不使用索引，过多的索引会降低inset和update效率，一般的表中索引最好不超过6个 避免更新聚集索引：因为聚集索引数据列的顺序就是数据表的物理存储序列，若更新则会导致整个表的记录顺序调整，若频繁更新聚集索引数据列则需考虑是否将该索引建为聚集索引 用varchar代替char：节省空间、查询效率高 用数字字段代替字符字段：提升查询和连接性能，字符字段的查询和连接需要比较字符串中每一个字符，而数字仅需比较一次 避免大事务操作，提升系统并发能力 锁机制： 乐观锁：通过版本控制，实际上不加锁先执行，若执行完毕后版本号发生改变，则回滚重新执行 悲观锁：上锁，每次数据只有一个线程访问，其余的线程会阻塞 共享锁(lock in share mode)：读锁，允许多个线程并发读取资源，不允许写入资源 排它锁(for update)：写锁，会阻塞其他的读锁或写锁请求，确保同一时刻只能有一个连接可以写入资源，并防止其他连接读取或者写资源 区间锁：next key lock，锁定某个范围区间，如between 10 and 30 边界锁：gapLock，锁定某个边界 表锁：锁定整个表，影响整个表的读写 行锁：仅锁定某些行，其他行仍可以被其他链接请求读写 SQL事务的隔离级别： RU(Read Uncommited)未提交读：事务中的修改没有提交也对其他会话可见，会导致脏读(读取到一个事务未提交的数据，因为无法保证事务是否执行成功，因此读取到的数据不一定准确) RC(Read Commited)提交读：事务中的操作对其他会话不可见，但可能出现不可重复读(一个事务读取到的数据可能产生变化，同一个sql在一个事务中执行多次得到不同结果) RR(Repeatable Read)可重复读：事务中多次执行统一sql返回结果相同，mysql默认的隔离等级 Serializable可串行化：事务中每次读取的行加锁，写加写锁","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"面试总结","slug":"面试总结","permalink":"https://harviealwayshere.github.io/tags/面试总结/"},{"name":"后台开发","slug":"后台开发","permalink":"https://harviealwayshere.github.io/tags/后台开发/"}]},{"title":"软件测试(二) 白盒测试","slug":"swtest2","date":"2018-04-24T02:02:01.000Z","updated":"2018-04-24T12:39:05.461Z","comments":true,"path":"2018/04/24/swtest2/","link":"","permalink":"https://harviealwayshere.github.io/2018/04/24/swtest2/","excerpt":"","text":"本文是软件测试课程课堂笔记和作业记录大纲白盒测试定义：白盒测试也称为结构测试、逻辑驱动测试，是从程序的控制结构、内部逻辑出发导出测试用例的测试 基本要求：1.模块中所有独立路径至少被执行一次2.对所有逻辑值测试真假两个分支3.在上下边界、可操作范围内运行所有循环4.确保内部数据结构的有效性 测试覆盖标准：由于白盒测试中存在循环，所以路径数目较大，要执行每一条路径是不可能的，因此存在测试覆盖标准规定测试覆盖的程度测试覆盖标准由低到高分别是：1.语句覆盖：选择足够的测试用例，使程序中每个语句至少能被执行一次如程序如果要执行语句覆盖，那么只需要选择一个通过路径ace的例子，如A=2，B=0，X=32.判定/分支覆盖：执行足够的测试用例，使程序中每个分支至少通过一次如果执行判定/分支覆盖，则需要覆盖所有路径，可以选择路径ace+abd或者acd(A=3,B=0,X=1)+abe(A=2,B=1,X=3)3.条件覆盖：执行足够测试用例，使程序中每个判断中的每个条件中的每个取值至少可以执行一次如果执行条件覆盖，首先了解程序的条件，程序的条件有4个A&gt;1,B=0,A=2,X&gt;1则针对每个条件都需要有相应的测试数据满足A&gt;1,A&lt;=1,B=0,B!=0,A=2,A!=2,X&gt;1,X&lt;=1所有满足条件则可以使用A=2，B=0，X=4 满足 A&gt;1,B=0,A=2,X&gt;1和A=1，B=1，X=1 满足 A&lt;=1,B!=0,A!=2,X&lt;=1 值得一提的是，条件覆盖并不包含分支覆盖，即条件覆盖只需要满足所有判定条件均执行但不一定保证所有分支均执行4.判定/条件覆盖：执行足够测试用例，使得条件覆盖和分支覆盖均满足可以使用A=2，B=0，X=4 满足 A&gt;1,B=0,A=2,X&gt;1和A=1，B=1，X=1 满足 A&lt;=1,B!=0,A!=2,X&lt;=1同时这两种条件覆盖满足了分支覆盖 ace+abd路径5.条件组合覆盖：执行足够的测试用例，使每个判定中条件的各种可能组合至少出现一次","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"软件测试","slug":"软件测试","permalink":"https://harviealwayshere.github.io/tags/软件测试/"},{"name":"黑盒测试","slug":"黑盒测试","permalink":"https://harviealwayshere.github.io/tags/黑盒测试/"}]},{"title":"软件测试(一) 黑盒测试","slug":"swtest1","date":"2018-04-23T06:43:42.000Z","updated":"2018-04-23T09:05:56.472Z","comments":true,"path":"2018/04/23/swtest1/","link":"","permalink":"https://harviealwayshere.github.io/2018/04/23/swtest1/","excerpt":"","text":"本文是软件测试课程课堂笔记和作业记录大纲黑盒测试定义：黑盒测试又称为功能测试、数据驱动测试、基于规格说明书的测试，是一种从用户观点出发的测试。 测试错误类型：1.不正确或遗漏的功能2.接口、界面错误3.性能错误4.数据结构、外部数据访问错误5.初始化、终止条件错误 黑盒测试优点：1.从用户角度出发，证明产品是否可以达到用户要求的功能，产品是否符合用户的工作要求2.可复用性，软件实现发生变化黑盒测试用例仍可使用3.开发同步性，测试用例可通过软件用例设计出，与软件开发同时进行节省时间4.可重复性，能重复执行相同动作，可由机器完成重复执行 黑盒测试缺点：1.测试人员需要了解软件所用技术2.测试用例数量大，冗余多3.功能测试覆盖率达不到1004.测试过程大多是手工测试 黑盒测试实施过程：1.计划2.设计：按照规格说明书或用户手册，按照规范化方法进行软件功能划分和设计测试用例3.执行：按照2设计的测试用例执行测试和自由测试(补充测试)4.总结 测试用例：类似于需求用例，是一个文档，描述输入、动作、时间和结果，基本要求有编号、标题、重要级别、测试输入、操作步骤、预期结果 黑盒测试中设计测试用例的技术： 等价类划分法定义：将所有可能输入数据划分成若干子集，从每个子集中选取少数代表性数据作为测试用例 划分等价类：将所有输入合理划分为有效等价类和无效等价类，在每一个等价类中取一个数据代表整个等价类作为测试输入取得测试结果 有效等价类：是合理、有意义的输入数据，用来测试软件是否实现了规格说明中规定的功能和性能 无效等价类：是不合理、无意义的输入数据，对于具体问题应该至少有一个无效等价类 等价类划分标准：1.完备测试：等价类集合的并是整个输入集合2.避免冗余：等价类集合互不相交 划分等价类方法：1.输入取值范围：若输入范围为[a,b]，则可划分一个有效等价类[a,b]和两个无效等价类[-∞,a]、[b,+∞]2.输入特定值：如规定输入a=9，则可划分一个有效等价类a=9和一个无效等价类a!=93.输入n组值：如规定输入a,b,c，则可划分3个有效等价类a/b/c和一个无效等价类(任何不等于abc的值)4.输入等价类中元素在程序中处理方式不同时，应该将等价类进一步划分为更小的等价类 设计测试用例：1.为每个等价类规定一个唯一编号2.设计一个测试用例尽可能多覆盖有效等价类3.设计一个测试用例尽可能少覆盖无效等价类 边界值分析法定义：从等价类中选取等于、稍大于、稍小于边界的值作为测试数据，而不是选取等价类中典型数值 边界值分析方法：1.规定输入值范围：若输入范围为[a,b]，则应该选取等于、刚达到、刚超越这个范围边界的值作为输入数据，如a,a+0.0001,a-0.0001,b,b+0.0001,b-0.00012.规定输入值个数：若规定输入[a,b]个值，则应该选取**最大个数、最小个数、最大个数+1、最小个数-1，如输入a、a-1、b、b+1个值 错误推测法定义：基于经验直觉推测出程序中可能有的错误和容易发生错误的特殊情况从而选择测试用例 因果图测试法","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"软件测试","slug":"软件测试","permalink":"https://harviealwayshere.github.io/tags/软件测试/"},{"name":"黑盒测试","slug":"黑盒测试","permalink":"https://harviealwayshere.github.io/tags/黑盒测试/"}]},{"title":"安卓实战开发(一) GroQuiz","slug":"androidProject1","date":"2018-04-12T07:12:03.000Z","updated":"2018-04-12T10:31:07.055Z","comments":true,"path":"2018/04/12/androidProject1/","link":"","permalink":"https://harviealwayshere.github.io/2018/04/12/androidProject1/","excerpt":"","text":"本文以”Android编程权威指南第3版”为核心，记录安卓实战开发中遇到的问题和心得 大纲用户界面的编写1.用户界面组成：一个垂直布局组件：LinearLayout一个TextView组件一个水平布局组件：LinearLayout两个Button组件 2.主要组件属性：match_parent:视图与父视图大小相同wrap_content:视图根据其内容自动调整大小orientation=”vertical”:布局组件垂直放置orientation=”horizontal”:布局组件水平放置text=”@string/string_name”:组件显示的文字内容，@string/表示文字在字符串资源XML中 3.代码：1234567891011121314151617181920212223242526272829303132&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/activity_quiz\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:padding=\"24dp\" android:text=\"@string/question_text\" /&gt; &lt;LinearLayout android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"horizontal\"&gt; &lt;Button android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@string/true_button\"/&gt; &lt;Button android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@string/false_button\"/&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 活动JAVA文件编写1.声明组件变量：1.1导入库(Alt+Enter)1.2注意m命名规范 2.引用组件：使用findViewBuId方法 注意类型转换(View-&gt;Button) 3.设置监听器：setOnClickListener(new View.OnClickListener(){ @Override public void onClick(View v){ } }); 4.提示消息：Toast.makeText(Context QuizActivity.this,String R.string.correct_toast,Toast.LENGTH_SHORT).show(); 5.完整代码：1234567891011121314151617181920212223242526272829303132333435363738package com.example.admin.groquiz;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button; //1.import android.widget.Toast;public class QuizActivity extends AppCompatActivity &#123; private Button mTrueButton; //1. private Button mFalseButton; //1. @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_quiz); mTrueButton=(Button)findViewById(R.id.true_button); //2. mFalseButton=(Button)findViewById(R.id.false_button); //2. //3. mTrueButton.setOnClickListener(new View.OnClickListener()&#123; @Override public void onClick(View v)&#123; //4. Toast.makeText(QuizActivity.this,R.string.correct_toast,Toast.LENGTH_SHORT).show(); &#125; &#125;); //3. mFalseButton.setOnClickListener(new View.OnClickListener()&#123; //3. @Override public void onClick(View v)&#123; //4. Toast.makeText(QuizActivity.this,R.string.incorrect_toast,Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125;&#125;","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"安卓开发","slug":"安卓开发","permalink":"https://harviealwayshere.github.io/tags/安卓开发/"}]},{"title":"安卓开发(四) 四大组件—广播","slug":"android4","date":"2018-04-10T01:16:40.000Z","updated":"2018-04-10T02:31:36.513Z","comments":true,"path":"2018/04/10/android4/","link":"","permalink":"https://harviealwayshere.github.io/2018/04/10/android4/","excerpt":"","text":"本文主要记录第一行代码中安卓开发流程总结和个人安卓APP开发中遇到的实战问题解决方案 大纲广播机制应用程序可以对自己感兴趣的广播(系统或者别的应用程序发出的)注册，就可以接受到自己关心的广播内容 广播类型1.标准广播(Normal Broadcasts)：完全异步执行，发出后所有接收器同时接收到这条广播，无法截断，效率很高2.有序广播(Orderd broadcasts)：完全同步执行，发出后只有一个接收器接收到这条广播，接收器接收广播逻辑执行完成后广播才会继续传递，因此接收器是有优先级，可被截断 系统广播Android内置许多系统级别的广播，如手机开机、电量变化、网络变化等 注册广播接收器两种注册方式：1.在代码中注册(动态注册)和2.在AndroidManifest.xml中注册(静态注册) 代码中注册(动态注册)1.新建广播接收类A：继承BroadcastReceiver并重写其onReceive方法 2.声明创建IntentFilter对象：用于调用其.addAction()方法添加监听的广播 3.实例化广播接收类A对象B 4.注册广播registerReceiver(B,IntentFilter) 5.取消注册广播unregisterReceiver(B) 6.声明B所需的权限(视监听的广播情况而定)12345678910111213141516171819202122232425262728293031public class MainActivity extends AppCompatActivity &#123; private IntentFilter intentFilter; private NetworkChangeReceiver networkChangeReceiver; @Override protected void onCreate(Bundle savedInstanceState) &#123; ... //2.声明创建IntentFilter对象 intentFilter=new IntentFilter(); intentFilter.addAction(\"android.net.conn.CONNECTIVITY_CHANGE\"); //3.实例化广播接收类对象 networkChangeReceiver=new NetworkChangeReceiver(); //4.注册广播 registerReceiver(networkChangeReceiver,intentFilter); &#125; //1.新建广播接收类 class NetworkChangeReceiver extends BroadcastReceiver&#123; @Override public void onReceive(Context context, Intent intent)&#123; //接收到广播执行相应逻辑 &#125; &#125; @Override protected void onDestroy()&#123; ... //5.取消注册广播 unregisterReceiver(networkChangeReceiver); &#125;&#125; AndroidManifest.xml中注册(静态注册)1.类似动态注册新建广播接收类A 2.注册广播 3.添加对应的监听广播 4.添加权限12345678910111213141516171819//1.类似动态注册新建广播接收类public class BootCompleteReceiver extends BroadcastReceiver&#123; @Override public void onReceive(Context context, Intent intent)&#123; //接收到广播执行相应逻辑 &#125;&#125;//2.注册广播&lt;receiver android:name=\".BootCompleteReceiver\" android:enabled=\"true\" android:exported=\"true\"&gt; //3.添加对应的监听广播 &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.BOOT_COMPLETED\"/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt;//4.添加权限&lt;uses-permission anroid:name=\"android.permission.RECEIVE_BOOT_COMPLETED\" /&gt;","categories":[],"tags":[{"name":"安卓开发","slug":"安卓开发","permalink":"https://harviealwayshere.github.io/tags/安卓开发/"}]},{"title":"Scrapy爬虫实战(二) 爬取新闻网站","slug":"scrapy2","date":"2018-04-02T11:47:34.000Z","updated":"2018-04-09T02:30:50.302Z","comments":true,"path":"2018/04/02/scrapy2/","link":"","permalink":"https://harviealwayshere.github.io/2018/04/02/scrapy2/","excerpt":"","text":"本文记录Scrapy爬虫在Linux系统下的实战 大纲scrapy startproject projectname1.创建项目：scrapy startproject demo2.项目结构和文件作用：用户编写的主要就是spiders+items+pipeline模块 编写爬虫前的设置(settings.py)1.设置爬虫不遵守robots.txt，robots协议就是网站规定的爬虫爬取规则12# Obey robots.txt rulesROBOTSTXT_OBEY = False 2.设置取消Cookies，Cookies是服务器识别计算机的资料12# Disable cookies (enabled by default)COOKIES_ENABLED = False 3.设置用户代理(USER_AGENT)，可在浏览器F12-Network-Headers里找到浏览器代理，让爬虫伪装成浏览器12# Crawl responsibly by identifying yourself (and your website) on the user-agentUSER_AGENT = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36' 4.设置IP地址，一般来说有些网站被同一个IP访问过于频繁多次会封锁IP，这时候需要更换代理IP继续爬取 编写items模块items模块主要定义爬取的数据字典12345678910import scrapyclass DemoItem(scrapy.Item): url=scrapy.Field() title = scrapy.Field() time = scrapy.Field() source = scrapy.Field() img=scrapy.Field() content=scrapy.Field() pass 编写spiders模块1.新建爬虫文件：1scrapy genspider -t basic spiderName spiderUrl这里以爬取虎扑新闻(https://voice.hupu.com/nba/ )为例，则新建爬虫可以为scrapy genspider -t basic hupu hupu.com2.编写爬虫文件 2.1爬取所有页面整体1234567891011121314151617class HupuSpider(scrapy.Spider): name = 'hupu' allowed_domains = ['hupu.com'] start_urls = ['http://hupu.com/'] # 规定爬取的url后会进入parse回调函数 def parse(self, response): # 观察新闻每个页数的url，我们可以发现规律为 # 页数i对应的url为https://voice.hupu.com/nba/i for i in range(0,1): url='https://voice.hupu.com/nba/'+str(i+1) # yield类似于这个数的return后循环在下一个数执行 # Request(url,callback)用于迭代爬取 可以调用callback进一步爬取传入的url # 记得引入from scrapy.http import Request # 这个语句的意思是 将每个遍历到的url做进一步处理再执行下一个遍历到的url yield Request(url=url,callback=self.newsPage) pass 2.1爬取每个页面需要的内容1234567891011# 上一个Request传入的url响应的response作为参数传入回调函数newsPagedef newsPage(self,response): # 通过观察页面我们知道每个页面中的新闻的连接在 # 属性为class=list-hd的div标签下的h4标签下的a标签下的href属性中 # 可用response.xpath().extract()得到这个页面所有新闻的url allPageUrl=response.xpath('//div[@class=\"list-hd\"]/h4/a/@href').extract() for i in range(0,len(allPageUrl)): #len(allPageUrl) # 同样地 将这个页面的url一个一个遍历处理 yield Request(url=allPageUrl[i],callback=self.aNewPage) pass pass 2.1爬取每个新闻详情页面的信息12345678910111213141516 # 上一个Request传入的每个新闻的url的响应response即新闻详情页面传入 def aNewPage(self,response):# 此时要将爬取到的数据存入item中了 # 引入from news.items import NewsItem 新建item对象 item=NewsItem() # 观察页面中所需信息的xpath信息再利用xpath存入对应的item字段 item['url']=[response.url] item['title']=response.xpath('//div[@class=\"artical-title\"]/h1/text()').extract() item['time']=response.xpath('//div[@class=\"artical-info\"]/span/a/span/text()').extract() item['source']=response.xpath('//div[@class=\"artical-info\"]/span/span/a/text()').extract() item['img']=response.xpath('//div[@class=\"artical-importantPic\"]/img/@src').extract() content=response.xpath('//div[@class=\"artical-main-content\"]//p/text()').extract() # 注意爬取到的content为多段&lt;p&gt;标签组成 需要合并处理 item['content']=[\"\\n\".join(content)] # 爬取到的数据交给pipelines处理 yield item 编写pipelines模块pipeline主要功能为读取item中爬取到的数据+做相应数据处理+保存数据(数据库/文件/..)1.读取item中爬取到的数据：12345678class NewsPipeline(object):def process_item(self, item, spider): url = item['url'][0] title = item['title'][0] timeT = item['time'][0] source = item['source'][0] img = item['img'][0] content = item['content']2.数据处理：1234567# 如title中有杂乱的空格和\\r\\n数据title = title.replace(' ','').replace('\\r\\n','')# 如需要将时间转换成时间戳存储from datetime import datetimeimport timedatetimeTime=datetime.strptime(str(timeT).replace(' ',''), '%Y-%m-%d%H:%M:%S')timestampTime=time.mktime(datetimeTime.timetuple())3.保存数据至数据库：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# python操作数据库模块import pymysql# 数据库连接参数config=&#123; 'host':'127.0.0.1', 'port':3306, 'user':'root', 'password':'', 'db':'news', 'charset':'utf8'&#125;class NewsPipeline(object): # 连接数据库 def __init__(self): self.conn=pymysql.connect(**config) def process_item(self, item, spider): try: url = item['url'][0] title = item['title'][0].replace(' ','').replace('\\r\\n','') timeT = item['time'][0] source = item['source'][0] img = item['img'][0] content = item['content'] # 时间转成时间戳存储 # str-&gt;datetime 字符串转datetime格式 datetimeTime=datetime.strptime(str(timeT).replace(' ',''), '%Y-%m-%d%H:%M:%S') #datetime-&gt;timestamp datetime格式转timestamp格式 timestampTime=time.mktime(datetimeTime.timetuple()) print('----------start--------\\n') # 初始化游标用于存储数据 cursor=self.conn.cursor() sql='INSERT INTO news (url,title,time,source,img,content) VALUES (%s,%s,%s,%s,%s,%s)' cursor.execute(sql,(url,title,timestampTime,source,img,content)) self.conn.commit() print('新闻链接：', url) print('新闻标题：', title) print('----------end--------\\n') return item except Exception as err: # 存储失败打印错误信息 print(str(err)) pass # 关闭游标和数据库 def close_spider(self): cursor.close() self.conn.close() 编写自动化脚本周期执行爬虫1.编写自动化脚本：在linux下执行的python文件需要指定执行.py文件的python路径，可用which python命令找到路径，写在.py文件顶部，如#!/usr/bin/python12345678910111213141516171819#!/usr/bin/pythonimport timeimport os# 循环执行while True: print time.strftime(\"%Y-%m-%d %H:%M:%S\", time.localtime()) print(\"---------Run Scrapy!-----------\") # 发送系统指令 执行爬虫命令就是scrapy crawl hupu --nolog os.system(\"scrapy crawl hupu --nolog\") print(\"---------End Scrapy!-----------\") # 执行更新新闻脚本 在后续文件中 os.system(\"./updateNews.py\") # 规定脚本每执行一次阻塞10分钟 即每10分钟执行一次爬取 time.sleep(60*10) 2.编写自动化更新新闻(删除旧新闻)脚本1234567891011121314151617181920212223242526272829303132333435#!/usr/bin/pythonimport pymysqlimport timefrom datetime import datetimefrom datetime import timedeltaconfig=&#123; 'host':'127.0.0.1', 'port':3306, 'user':'root', 'password':'123456', 'db':'news', 'charset':'utf8'&#125;try: conn=pymysql.connect(**config) cursor=conn.cursor() # 得到昨天此时的时间戳 lastday=datetime.now()-timedelta(days=1) lastdayTimestamp=time.mktime(lastday.timetuple()) # 将时间戳小于昨天此时的时间戳的新闻删除 sql='DELETE FROM news WHERE news.time&lt;'+str(lastdayTimestamp) deleteCount=cursor.execute(sql) conn.commit() print('-----------DELETE OLD NEWS NUM:----------') print(deleteCount) print('---------------DELETE END--------------------')except Exception as err: print('DELETE FAIL MSG BEHIND:') print(str(err)) pass 3.执行自动化脚本123456789# 若是windows编写的.py文件在linux下执行需要更改文件格式：vim run.py:set ff=unix# 添加执行权限 chmod u+x run.py# 在后台执行脚本并输出执行日志在脚本目录下nohup ./run.py &gt; nohup.log 2&gt;&amp;1 &amp; # 查看脚本是否执行ps -ef|grep python","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"Scrapy爬虫","slug":"Scrapy爬虫","permalink":"https://harviealwayshere.github.io/tags/Scrapy爬虫/"},{"name":"Python","slug":"Python","permalink":"https://harviealwayshere.github.io/tags/Python/"},{"name":"Linux","slug":"Linux","permalink":"https://harviealwayshere.github.io/tags/Linux/"}]},{"title":"Scrapy爬虫实战(一) Linux下的安装","slug":"scrapy1","date":"2018-04-02T11:46:19.000Z","updated":"2018-04-02T14:21:51.606Z","comments":true,"path":"2018/04/02/scrapy1/","link":"","permalink":"https://harviealwayshere.github.io/2018/04/02/scrapy1/","excerpt":"","text":"本文记录Scrapy爬虫在Linux系统下的实战 大纲 CentOS7下安装Scrapy Scrapy命令 CentOS7下安装Scrapy1.首先查看一下系统有无内置python和pip工具可以看到CentOS7中是有内置Python2.7.5和pip9.0.1Scrapy仅支持Python2.7以上或者Python3.3以上，那么CentOS7内置版本的Python已经足够了2.安装gcc及扩展包yum install gcc libffi-devel python-devel openssl-devel3.安装开发工具包yum groupinstall -y development4.安装libxslt-devel支持lxmlyum install libxslt-devel5.安装Scrapypip install scrapy可以看到，安装成功了，至此Scrapy爬虫环境搭建就完成了 Scrapy命令Scrapy命令分为全局命令和项目命令 全局命令：全局使用，主要用于整体项目使用scrapy -h可以查看全局命令 项目命令：进入项目内部使用进入项目路径后执行scrapy-h可以看到项目命令Tips:basic基础模板 crawl自动爬虫 csvfeed处理csv文件 xmlfeed处理xml文件，若用basic模板创建一个文件fileDemo则使用命令:scrapy genspider -t basic fileDemo创建一个fileDemo.py文件","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"Scrapy爬虫","slug":"Scrapy爬虫","permalink":"https://harviealwayshere.github.io/tags/Scrapy爬虫/"},{"name":"Python","slug":"Python","permalink":"https://harviealwayshere.github.io/tags/Python/"},{"name":"Linux","slug":"Linux","permalink":"https://harviealwayshere.github.io/tags/Linux/"}]},{"title":"WEB信息系统安全（五）密码技术及其应用","slug":"webSecurity5","date":"2018-04-02T02:45:39.000Z","updated":"2018-04-02T02:46:25.057Z","comments":true,"path":"2018/04/02/webSecurity5/","link":"","permalink":"https://harviealwayshere.github.io/2018/04/02/webSecurity5/","excerpt":"","text":"本系列是陈春华教授所讲授的信息系统安全课程的个人笔记 大纲","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"WEB安全","slug":"WEB安全","permalink":"https://harviealwayshere.github.io/tags/WEB安全/"},{"name":"校园课程","slug":"校园课程","permalink":"https://harviealwayshere.github.io/tags/校园课程/"}]},{"title":"安卓开发(三) UI组件","slug":"android3","date":"2018-04-02T02:22:32.000Z","updated":"2018-04-02T05:59:59.240Z","comments":true,"path":"2018/04/02/android3/","link":"","permalink":"https://harviealwayshere.github.io/2018/04/02/android3/","excerpt":"","text":"本文主要记录第一行代码中安卓开发流程总结和个人安卓APP开发中遇到的实战问题解决方案 大纲基本组件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687//文本框&lt;TextView android:id=\"@+id/TextViewId\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:gravity=\"center\" android:textSize=\"24sp\" android:textColor=\"#000000\" android:text=\"TextView Content\"/&gt;//按钮&lt;Button android:id=\"@+id/ButtonId\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"Button Content\" android:textAllCaps=\"false\"/&gt;//按钮点击事件Button button=(Button)findViewById(R.id.ButtonId);button.setOnClickListener(new View.OnClickListener()&#123; @Override public void onClick(View v)&#123; //点击逻辑 &#125;&#125;);//输入框&lt;EditText android:id=\"@+id/EditTextId\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:hint=\"Type Something Here\" android:maxLines=\"2\"/&gt;//获取输入框内容EditText editText=(EditText)findViewById(R.id.EditTextId);String inputText=editText.getText().toString();//图片&lt;ImageView android:id=\"@+id/ImageViewId\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:src=\"@drawable/imgName\"/&gt;//替换图片ImageView imageView=(ImageView)findViewById(R.id.ImageViewId);imageView.setImageResource(R.drawable.imgName);//进度条&lt;ProgressBar android:id=\"@+id/ProgressId\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" style=\"?android:progressBarStyleHorizontal\" android:max=\"100\"/&gt;//控制可见属性和进度ProgressBar progressBar=(ProgressBar)findViewById(R.id.ProgressId);progressBar.getVisibility(); //得到当前状态progressBar.setVisibility(View.VISIBLE); //View.INVISIBLE不可见 View.Gone移除空间int progress=progressBar.getProgress(); //得到当前进度progress+=10;progressBar.setProgress(progress); //设置进度//弹出对话框AlertDialog.Builder dialog=new AlertDialog.Builder(FirstActivity.this);dialog.setTitle(\"TitleName\"); //标题dialog.setMessage(\"Msg\"); //内容dialog.setCancelable(false); //可否取消dialog.setPositiveButton(\"OK\", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; //确定按钮点击事件 &#125;&#125;); dialog.setNegativeButton(\"Cancel\", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; //取消按钮点击事件 &#125;&#125;);dialog.show();//弹出进度条ProgressDialog progressDialog=new ProgressDialog(FirstActivity.this);progressDialog.setTitle(\"TitleName\");progressDialog.setMessage(\"Msg\");progressDialog.setCancelable(true);progressDialog.show(); 基本布局123456789101112//线性布局 //vertical垂直排列 组件layout_height高度不能为match_parent//horizontal为水平排列 组件layout_width宽度不能为match_parent&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt;&lt;/LinearLayout&gt;//线性布局中的组件属性android:layuot_gravity=\"\" //在垂直排列中指定水平位置 在水平排列中指定垂直位置android:layout_weight=\"\" //指定分配权重 水平排列中指定width为0dp 使用weight来分配权重 //垂直排列中指定height为0dp 使用weight来分配权重 ListView控件12345&lt;ListView android:id=\"@+id/ListViewName\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /&gt;","categories":[],"tags":[{"name":"安卓开发","slug":"安卓开发","permalink":"https://harviealwayshere.github.io/tags/安卓开发/"}]},{"title":"WEB信息系统安全（四）身份认证与访问控制","slug":"webSecurity4","date":"2018-04-02T02:01:49.000Z","updated":"2018-04-02T02:29:49.589Z","comments":true,"path":"2018/04/02/webSecurity4/","link":"","permalink":"https://harviealwayshere.github.io/2018/04/02/webSecurity4/","excerpt":"","text":"本系列是陈春华教授所讲授的信息系统安全课程的个人笔记 大纲身份认证与访问控制 基于凭证对比的身份认证 口令 访问控制 访问控制策略 基于所有权的访问控制 身份认证与访问控制身份认证：对主体(用户)合法性的认证访问控制：对主体的访问行为进行授权 基于凭证对比的身份认证用户提交能代表身份的凭证与系统中存储的凭证进行对比身份凭证的种类 密码：口令，个人识别码PIN，秘钥等 信物：信用卡，IC卡，USB KEY 生物特征：指纹，虹膜认证方式：单因素，双因素(多种凭证，如口令+信用卡) 口令静态口令：账户公开，口令保密，简单易用，安全性低动态口令：一次性口令，如令牌，短信密码，硬件令牌动态口令生成技术： 时间同步口令：基于令牌与服务器时间，一般60S产生一个新口令 事件同步：某一特定事件出现次序和相同种子值的哈希算法 异步口令：挑战应答，服务器给客户发送挑战(随机数R)，客户将R+pwd(服务器和客户共享的长期密码)作哈希返回给服务器，服务器作同样计算进行验证 访问控制对于认证通过的合法用户，也要对其访问行为进行控制 访问控制策略主体的访问控制可用二元组表示，即控制对象和访问类型二元组描述形式： 访问控制矩阵：Own所有权；R读；W写 访问控制列表(Access Contro List,ACL)：从资源(客体)出发描述控制信息 基于资源所有权的访问控制自主访问控制：资源所有者可以对资源的访问进行控制，规定谁可以访问其资源，权限传递灵活，应用于操作系统中强制访问控制：系统管理员确定用户的访问权限，用户不能改变自身或任何客体的安全属性，安全性高，应用于军事系统中基于角色的访问控制：将主题分配给其对应角色，获得角色的访问权限","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"WEB安全","slug":"WEB安全","permalink":"https://harviealwayshere.github.io/tags/WEB安全/"},{"name":"校园课程","slug":"校园课程","permalink":"https://harviealwayshere.github.io/tags/校园课程/"}]},{"title":"安卓开发(二) 四大组件—活动","slug":"android2","date":"2018-03-30T02:22:32.000Z","updated":"2018-04-01T16:22:45.379Z","comments":true,"path":"2018/03/30/android2/","link":"","permalink":"https://harviealwayshere.github.io/2018/03/30/android2/","excerpt":"","text":"本文主要记录第一行代码中安卓开发流程总结和个人安卓APP开发中遇到的实战问题解决方案 大纲活动(Activity)活动包含用户界面的组件，用于与用户交互，一个应用中可以包含多个活动 活动用法1.创建活动：用于调用布局和元素用来与用户交互创建一个空活动(Add No Activity)，可在app/src/main/java/com.example.activitytest中创建活动(New-Activity-EmptyActiviy)创建的是EmptyActivity十分简洁，在onCreate()中仅调用了父类的onCreate()方法 2.创建布局和元素：活动对应的布局用来显示界面内容创建一个布局，在app/src/main/res下创建一个存储布局文件的文件夹layout，然后在里面添加一个布局文件(New-Layout resource file)创建一个Button元素，指定id和属性 3.活动加载布局和元素：使用setContentView(layoutId)方法加载布局layoutId可在R文件中找到，因为项目中任何资源都会在R文件中生成对应的资源id，调用方式为R.ResourceCategory.FileName如layout下的firstLayout为R.layout.firstLayout 4.注册活动：AS在创建活动时会自动在AndroidManifest.xml中帮我们注册活动或其他组件在标签中使用标签注册活动1234567&lt;activity android:name=\".FirstActivity\" //指定注册活动名 android:label=\"This is FirstActivity\"&gt; //活动标题栏内容 &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; //设置主活动 &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; //设置主活动 &lt;/intent-filter&gt;&lt;/activity&gt; 简单的活动1.Toast(短小消息提醒)：Toast.makeText(Context,Msg,Time).show()123456789//FirstActivity.java//在活动中设置Button监听点击事件触发ToastButton button1=(Button)findViewById(R.id.ButtonFirst);button1.setOnClickListener(new View.OnClickListener()&#123; @Override public void onClick(View v)&#123; Toast.makeText(FirstActivity.this,\"FirstToast!\", Toast.LENGTH_SHORT).show(); &#125;&#125;);2.Menu(菜单)：创建菜单资源文件，res-&gt;New directory-&gt;menu，menu-&gt;New-&gt;Menu resource file12345678910111213141516171819202122232425262728//main.xml&lt;item //菜单项 android:id=\"@+id/addItem\" android:title=\"Add\"/&gt;&lt;item android:id=\"@+id/removeItem\" android:title=\"Remove\"/&gt;//FirstActivity.java@Overridepublic boolean onCreateOptionsMenu(Menu menu)&#123; getMenuInflater().inflate(R.menu.main,menu); return true;&#125;@Overridepublic boolean onOptionsItemSelected(MenuItem item)&#123; switch (item.getItemId())&#123; case R.id.addItem: Toast.makeText(this,\"Add!\", Toast.LENGTH_SHORT).show(); break; case R.id.removeItem: Toast.makeText(this,\"Remove!\", Toast.LENGTH_SHORT).show(); break; default: &#125; return true;&#125;3.finish()销毁活动： 活动跳转(Intent)Intent是Android中组件之间进行交互的方式，可用于指明当前组件动作和组件间传递数据，一般用于启动互动、启动服务、发送广播等 显式Intent显式Intent的意图明显，如Intent(Context,Class)，Context为背景上下文，Class为目标活动启动活动可以用startActivity(Intent) 隐式Intent(程序内活动)隐式Intent意图不明显，不指定启动函数而是由系统分析出合适活动去启动使用Intent的另一个构造函数Intent(ActionName)/intent.addCategory(CategoryName)，ActionName和CategoryName会在活动注册标签和中寻找匹配的活动1234567//AndroidManifest.xml&lt;activity android:name=\".SecondActivity\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"com.example.activitytest.ACTION_START\"/&gt; &lt;category android:name=\"android.intent.category.DEFAULT\"/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 隐式Intent(程序间活动)隐式Intent还可以启动其他程序的活动，使得Android程序间功能共享成为可能如启动安卓内置浏览器打开网页、启动拨打号码活动等 Intent代码示例12345678910111213//显示Intent(Context,Class)Intent intent=new Intent(FirstActivity.this,SecondActivity.class);//隐式Intent(ActionName)+intentObj.addCategory(CategoryName)Intent intent=new Intent(\"com.example.activitytest.ACTION_START\");intent.addCategory(\"android.intent.category.DEFAULT\");//隐式Intent程序间活动Intent intent=new Intent(Intent.ACTION_VIEW);intent.setData(Uri.parse(\"http://www.baidu.com\"));//启动活动startActivity(intent); 活动传递数据(Intent)123456789//传递数据 intent.putExtra(key,value);String data=\"Hello Next Activity!\";Intent intent=new Intent(FirstActivity.this,SecondActivity.class);intent.putExtra(\"passData\",data);startActivity(intent);//取出数据 getIntent()+intent.getStringExtra(key)Intent intent=getIntent();String data=intent.getStringExtra(\"passData\"); 活动返回数据(startActivityForResult)1234567891011121314151617181920212223242526//启动活动时用startActivityForResult(Intent,Code)//Code为请求码Intent intent=new Intent(FirstActivity.this,SecondActivity.class);startActivityForResult(intent,1);//被启动活动将要传递的数据放在intent中并setResult(Status,Intent)//Status为活动处理结果 RESULT_OK/RESULT_CANCALED//这段代码可以放在活动元素中或者onBackPressed()中(用户按back键销毁活动)Intent intent=new Intent();intent.putExtra(\"dataReturn\",\"Hello Previous Activity!\");setResult(RESULT_OK,intent);//被启动的活动销毁后会调用上一个活动的onActivityResult(Code,Status,Intent)//Code为请求码，Status为活动处理结果，Intent为带有数据的返回Intent@Overrideprotected void onActivityResult(int code,int status,Intent data)&#123; switch(code)&#123; case 1: if(status==RESULT_OK) &#123; String returnData=data.getStringExtra(\"dataReturn\"); &#125; break; default: &#125;&#125; 活动的生命周期Android使用任务(Task)来管理活动的，一个任务就是一组存放在返回栈中的活动集合 活动的状态运行状态：栈顶活动 暂停状态：不处于栈顶但是仍然可见的活动 停止状态：不处于栈顶并且不可见的活动 销毁状态：出栈的活动 活动改变状态函数Tips：活动从停止状态变为运行状态，有两条路径，取决于停止状态时活动是否被系统回收，若已经被系统回收，则返回到活动时需要调用onCreate()重新创建活动，否则调用onRestart()重新启动活动 活动回收时保存数据活动在被系统回收时若需要保存当前活动数据，可以在onSaveInstanceState()函数中使用Bundle数据类型的putString/putInt(key,value)等保存数据，函数保证活动回收前一定被调用12345678910111213//保存数据@Overrideprotect void onSaveInstanceState(Bundle outState)&#123; super.onSaveInstanceState(outState); outState.putString(key,value);&#125;//取出数据@Overrideprotected void onCreate(Bundle savedInstanceState)&#123; if(savedInstanceState!=null)&#123; String data=savedInstanceState.getSrring(key); &#125;&#125; 活动启动模式通过在AndroidManiFest.xml中给标签指定android:launchMode属性指定活动启动模式 standard模式：活动每次启动都创建一个新的活动实例 singleTop模式：处于栈顶的活动启动不会创建新的活动实例 singleTask模式：在栈内的活动会被调用至栈顶并弹出这个活动以上的所有活动 singleInstance：创建一个单独栈启动活动，其他活动均调用这个栈内的活动实例 活动小技巧可以创建一个活动基类BaseActivity添加一些方法辅助我们编写活动1234567public class BaseActivity extends AppCompatActivity&#123; @Override protect void onCreate(Bundle saveInstanceState)&#123; super.onCreate(saveInstanceState); Log.d(\"NowActivity\",getClass().getSimpleName()); //打印当前创造的活动名 &#125;&#125;被启动的活动若需要传递参数启动可以编写一个函数用于启动活动时调用12345678910//如启动活动需传递一个String值public static void actionStart(Context context,String data)&#123; Intent intent=new Intent(context,startActivityName.class); intent.putExtra(key,data); context.startActivity(intent);&#125;//别的活动就可以调用这个函数来启动活动String NeedData;startActivityName.actionStart(FirstActivity.this,NeedData);","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"安卓开发","slug":"安卓开发","permalink":"https://harviealwayshere.github.io/tags/安卓开发/"}]},{"title":"安卓开发(一) 环境搭建+简单入门","slug":"android1","date":"2018-03-30T02:16:24.000Z","updated":"2018-04-01T01:57:01.913Z","comments":true,"path":"2018/03/30/android1/","link":"","permalink":"https://harviealwayshere.github.io/2018/03/30/android1/","excerpt":"","text":"本文主要记录第一行代码中安卓开发流程总结和个人安卓APP开发中遇到的实战问题解决方案 大纲Android Studio安装百度网盘下载Android Studio 2.2版本Tips：不要去什么安卓中文官网下载3.*版本的AS，原因如下1.下载的安装包不包括Android SDK2.下载的3.*版本对于Android SDK的版本要求过高，容易不兼容低版本sdk导致项目Build失败，市场份额最高的安卓sdk版本为15，不需要追求太高的版本 模拟器创建和安装点击顶部工具栏中的AVD Manager选择Nexus 5X机型+Nougat Android 7.0操作系统版本+保持默认配置即可点击Finish即可创建好模拟器，之后点击三角形Start启动模拟器 运行Android项目在模拟器上下面工具栏对应编译项目+选择运行项目+运行项目点击运行项目选择刚才创建的模拟器即可将选择运行的项目在模拟器上运行 真机调试1.将手机使用USB连接至PC端后打开USB调试功能(开发者选项)2.在选择运行项目的app栏中选择Edit Configuration中的Deployment Target Options选项中选择USB Device3.点击运行项目，若出现Error running app: No target device found.错误，则点击下方的Android Monitor选项卡，会自动帮你识别你的设备，如下4.此时再运行项目，AS会自动将项目打包成.apk格式安装到你的手机上并自动运行 安卓项目结构重点学习app项目，其他文件了解即可，后期才会学习 安卓项目运行流程以HelloWorld项目为例1.在AndroidMainfest.xml中注册HelloWorld活动：标签里的语句表示这个活动是主活动123456&lt;activity android:name=\".HelloWorld\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt;2.在Java文件夹下编写HelloWorld活动代码：继承Activity类(AppCompatActivity为其子类用于向下兼容)，重载父类的onCreate方法，setContentView引入布局文件1234567public class HelloWorld extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_hello_world); &#125;&#125;3.在res/layout中编写布局文件：可以看到布局文件中有个组件其中有个属性为text=”Hello World!”，因此整个活动就是显示这个text为HelloWorld！的TextView组件 资源引用对于res文件夹里面的资源，可以使用两种方式引用，以引用res/values/strings中的字符串为例 代码中R.string|drawable|mipmap.ValueName布局XML中@string|drawable|mipmap/ValueName Adnroid Studio的构建脚本AS采用Gradle来构建项目，Gradle是一个先进的项目构建工具，摈弃了XML的繁琐配置，使用了特定的DSL语言来简洁构建项目 外层项目中的build.gradle：1.使用了jcenter()配置，是一个代码托管仓库，配置之后就可以引用jcenter的开源项目2.声明了构建项目类型为安卓项目，通过dependencies闭包中的classpath指定构建项目的Gradle插件1234567891011121314151617buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:2.2.0' // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files &#125;&#125;allprojects &#123; repositories &#123; jcenter() &#125;&#125; app模块的build.gradle： 1.apply plugin指定模块类：com.android.application为应用模块，com.android.library为库模块 2.android闭包指定项目构建属性compileSdkVersion 编译版本buildToolsVersion 项目构建工具版本applicationId 项目包名minSdkVersion 最低兼容安卓系统版本targetSdkVersion 目标运行安卓版本versionCode 项目版本号versionName 项目版本名 3.buildTypes闭包指定生成安装文件配置：包含release闭包指定正式安装文件配置和debug闭包(可省略)指定测试安装文件配置，AS直接运行项目生成的都是测试版安装文件minifyEnabled 是否代码混淆proguardFiles 代码混淆规则 4.dependencies闭包指定项目依赖关系：AS项目中有三种依赖关系，本地依赖(本地Jar包或者目录)，库依赖(项目中的库模块)，远程依赖(jcenter库上的开源项目)compile fileTree 本地依赖中的一种com.android.support:appcompat-v7:24.2.1 远程依赖库格式 域名:组名称:版本号1234567891011121314151617181920212223242526272829apply plugin: 'com.android.application'android &#123; compileSdkVersion 24 buildToolsVersion \"27.0.3\" defaultConfig &#123; applicationId \"com.example.admin.helloworld\" minSdkVersion 15 targetSdkVersion 24 versionCode 1 versionName \"1.0\" testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\" &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125;&#125;dependencies &#123; compile fileTree(dir: 'libs', include: ['*.jar']) androidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', &#123; exclude group: 'com.android.support', module: 'support-annotations' &#125;) compile 'com.android.support:appcompat-v7:24.2.1' testCompile 'junit:junit:4.12'&#125; 日志工具Android的日志工具类是Log(android.util.Log)，提供五个级别的方法来打印日志信息Log.v()——verbose——繁琐意义最小的日志信息Log.d()——debug——调试信息Log.i()——info——重要数据如用户行为Log.w()——warn——警告信息Log.e()——error——错误信息如catch 在HelloWorld中的onCreate中加入一条log.d(),运行项目后可在Android Monitor中的logcat中看到日志信息","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"安卓开发","slug":"安卓开发","permalink":"https://harviealwayshere.github.io/tags/安卓开发/"}]},{"title":"WEB信息系统安全（三）数据完整性和不可否认性保护","slug":"webSecurity3","date":"2018-03-29T11:58:41.000Z","updated":"2018-03-30T02:13:56.379Z","comments":true,"path":"2018/03/29/webSecurity3/","link":"","permalink":"https://harviealwayshere.github.io/2018/03/29/webSecurity3/","excerpt":"","text":"本系列是陈春华教授所讲授的信息系统安全课程的个人笔记 大纲 数据完整性保护 消息认证 鉴别码 哈希函数 数据不可否认性保护 数字签名 数据完整性保护针对三种攻击 内容篡改：对报文内容进行加入删除改变等 序列篡改：对报文序列进行插入删除错序等 时间篡改：对报文进行延迟或者回放完整性保护即是保护内容完整性+序列完整性+时间完整性方法：消息认证、鉴别码(MAC)、Hash函数等 消息认证(Message Authentication)又称报文鉴别，可以验证所收到的信息是否来自真正的发送方并未收到内容、序列、时间篡改攻击1.内容认证：消息认证的核心2.序列认证：通常通过报文序号是否按序3.时间认证：通常采用时间戳或者询问应答机制 消息认证-鉴别码(MAC)MAC(Message Authentication Code，消息认证码)：使用一个由秘钥控制鉴别码生成函数基于报文的固定长的鉴别码M为明文，C为鉴别码生成函数，K为秘钥，MAC为消息认证码鉴别码生成函数特点：1.不要求可逆性，不需解密2.生成的MAC长度固定3.密文M与MAC存在多对一的关系，即不同密文可能对应同一MAC4.MAC函数比加密函数更不易攻破 常用的MAC函数算法：CBC-MAC，数据认证算法，建立在DES基础上，按照CBC模式操作构造MAC 哈希函数(数据指纹)原理：将任意长的输入消息通过哈希算法(H)变成固定长度的输出，该输出就是哈希值，又称为数据指纹安全性：1.哈希函数H可应用于任何长度的输入2.单向性，给定M计算H(M)=h容易，给定h计算出M困难3.强抗碰撞性，对于不同的M，生成的哈希值h基本不同，防止替代性报文伪造 哈希算法举例：1.报文摘要(Message Digest,MD)：将报文使用哈希函数变换成具有固定长度的鉴别码，不需秘钥2..MD5算法：哈希值长度128bits，主要用于防篡改鉴别码生成和加密口令，碰撞复杂度为2^403.SHA(Secure Hash Algorithm，安全哈希算法)：包括有SHA-1/-224/-256等，哈希值长度在160bits以上，主要应用在数字标准签名算法(DSS)上，最大报文长度为2^64-1 数据不可否认性保护用于抵抗如下行为：否认、冒充、伪造、篡改等一方对另一方的欺骗行为不可否认性保护：在通信双方未建立信任关系且存在利益冲突情况下，消息认证无法有效解决问题，可采用数字签名技术 数字签名定义：附加在数据单元上的一些数据或者密码变换，用来保证接受者可以使用其来缺人数据来源和数据完整性并保护数据不被伪造安全性：1.签名的生产识别验证应该效率高2.签名可以用于验证报文内容的真实性+签名者的身份+签名的时间3.签名需要是与报文相关的二进制串4.签名可以由第三方验证，解决双方通信不信任 直接数字签名使用非对称加密，将消息认证与签名结合，实现数据完整性和不可否认性结合过程：1.发送方：将报文M通过哈希函数H处理生成哈希值h2.发送方：哈希值h和私钥SK通过加密函数E加密成验证密文s(这里的私钥SK和加密函数E与报文M的加密体制里的秘钥不同)3.接收方：将收到的报文M通过哈希函数H处理生成哈希值h4.接收方：将受到的验证密文s和公钥PK通过解密函数D解密得到发送方加密的哈希值h，通过比较报文生成的哈希值h与解密验证密文s得到的哈希值h来验证是否数据完整和不可否认","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"WEB安全","slug":"WEB安全","permalink":"https://harviealwayshere.github.io/tags/WEB安全/"},{"name":"校园课程","slug":"校园课程","permalink":"https://harviealwayshere.github.io/tags/校园课程/"}]},{"title":"WEB信息系统安全（二）机密性保护","slug":"webSecurity2","date":"2018-03-29T11:58:36.000Z","updated":"2018-03-29T14:20:08.458Z","comments":true,"path":"2018/03/29/webSecurity2/","link":"","permalink":"https://harviealwayshere.github.io/2018/03/29/webSecurity2/","excerpt":"","text":"本系列是陈春华教授所讲授的信息系统安全课程的个人笔记 大纲 数据机密性保护 加密概念 古典算法 替代算法 换位算法 现代密码体制 对称密码体制 非对称密码体制 对称与非对称体制相比 Https 数据的机密性保护机密性保护定义：保护数据不为非授权者(用户、实体或者过程)获取或者使用分类： 可读性保护：借助数据加密技术 可见性保护：借助数据隐藏技术 数据加密概念数据加密：隐藏数据的可读性，使非授权用户不能直接了解数据内容加密系统：明文+算法+秘钥=密文加密算法分类： 古典算法（不安全 密钥空间小 计算机可穷举秘钥破解）1.替代算法：substitution cipher原理：将明文中每个位置的字母用其他字母代替举例： 凯撒密码算法：明文字母替换成字母表中后面举例5位的字母，如CHINA-&gt;HMNSF 维基利亚密码：按照秘钥长度分解明文成若干节，对于每个明文字母用对应秘钥和维基利亚方阵进行替换，具体为字母对应的秘钥为行数，字母本身为列数，在方阵中查找替换字母 2.换位算法：transposition cipher原理：将明文中的字母位置重新排列举例： 简单替换：将明文倒序输出 列换位法：按照秘钥长度分解明文，按照秘钥的字母在字母表中的顺序输出对应列的明文 现代密码体制C为明文，E为加密函数，EK为加密秘钥M为密文，D为解密函数，DK为解密秘钥按照DK与EK的关系，现代密码体制可分为 对称密码体制：DK==EK 非对称密码体制：DK!=EK 1.对称密码体制原理：加密与解密用相同秘钥举例： 流加密(stream cipher)：RC4算法等 原理：对明文与密钥流进行逐比特位(bit)进行加密操作(异或运算) 密钥流：基于种子秘钥K，通过密钥流生成函数不断产生Keystream 安全性： 1.密钥流生成函数需要有伪随机性(长周期不重复和不可推断) 2.种子秘钥K不重复使用，仅使用在一个通信会话中 3.长周期的种子秘钥更换：显示中真随机源(无周期重复)较难实现，一般采用线性反馈移位寄存器结构，具有很长的周期性即可 块加密(block cipher)：DES算法和AES算法 原理：将明文编码(如01编码)，按照一定长度(m)分组，再将各组明文编码分别在秘钥的控制下加密 操作模式： 1.ECB(Electronic Codebook，电码本)：明文被处理成大小合适的分组之后对每个分组进行独立的加密解密操作 2.CBC(Cipher-block chaining，密码分组连接)：每个明文块先于前一个密文进行异或后在进行加密，因此每个密文快都依赖于它前面所有的明文块 安全性：明文块的长度(m)对安全性十分关键，至少需要64bit，推荐128bit以上，抵挡字典攻击 DES(Data Encryption Standard，数据加密标准)：块长度64位，秘钥长度56位 AES(Advanced Encryptio Standard，高级数据加密标准)：块长度128位，可变秘钥长度128/192/256位 对称秘钥体制问题：通信双方共享一个用于加密/解密的秘钥K，在规模为n的通信群体中共需要n(n-1)个秘钥，规模庞大时，秘钥管理困难 2.非对称密码体制原理：加密与解密使用不同秘钥，使用其中一个秘钥(公钥PK)进行加密，可以用对应的另一个秘钥(私钥SK)进行解密安全性：仅知道公钥难以求得私钥解决秘钥管理问题：每个实体仅需要保管一个公私秘钥对举例： RSA算法，安全性依赖于大整数素因子分解难题 对称与非对称体制比较对称加密： 运算效率高，使用方便，加密效率高 秘钥需要安全信道传输，若秘钥泄密，损失惨重非对称加密： 安全性高 运算效率低，通常用于加密对称秘钥 HTTPS加密HTTPs采用混合的加密机制，使用公开密钥(非对称加密)加密用于传输对称密钥，之后使用对称密钥加密进行通信PublicKey为非对称加密的公钥，PrivateKey为非对称加密的私钥，用于传输对称加密秘钥SessionKey这存在一个问题：怎么保证获取到的公钥PublickKey为真正的公钥呢？答案是证书认证(签名)数字证书认证机构（CA，Certificate Authority是客户端与服务器双方都可信赖的第三方机构。服务器的运营人员向CA提出公开密钥的申请，CA在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。进行HTTPs通信时，服务器会把证书发送给客户端，客户端取得其中的公开密钥之后进行验证其中的数字签名是否为CA，如果验证通过，就可以开始通信。使用OpenSSL这套开源程序，每个人都可以构建一套属于自己的认证机构，从而自己给自己颁发服务器证书。浏览器在访问该服务器时，会显示“无法确认连接安全性”或“该网站的安全证书存在问题”等警告消息。","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"WEB安全","slug":"WEB安全","permalink":"https://harviealwayshere.github.io/tags/WEB安全/"},{"name":"校园课程","slug":"校园课程","permalink":"https://harviealwayshere.github.io/tags/校园课程/"}]},{"title":"LeetCode算法总结","slug":"leetcode","date":"2018-03-26T02:54:03.000Z","updated":"2018-03-26T06:56:43.510Z","comments":true,"path":"2018/03/26/leetcode/","link":"","permalink":"https://harviealwayshere.github.io/2018/03/26/leetcode/","excerpt":"","text":"本文主要总结LeetCode题目的C++解法，日常更新两篇 算法思想二分查找对于有序数组而言，二分查找速度快1234567891011121314//在数组array中查找key 找到返回其index 无返回-1int BinarySearch(int* array,int length,int key) &#123; if(array==NULL) return -1; int start=0,end=length-1; while(start&lt;=end) &#123; int mid=start+(end-start)/2 //防止越界 if(key&lt;array[mid]) end=mid-1; else if(key&gt;array[mid]) start=mid+1; else return mid; &#125; return -1;&#125; 求开方Leetcode:69.Sqrt(x)(Easy)123456789101112131415int mySqrt(int x) &#123; if(x==0) return 0; if(x&lt;=1) return 1; int start=1,end=x; while(start&lt;=end) &#123; int mid=start+(end-start)/2; if(mid&gt;x/mid) end=mid-1; else if(mid&lt;x/mid)&#123; if((mid+1)&gt;x/(mid+1)) return mid; else start=mid+1; &#125; else return mid; &#125;&#125;思路：1.数x的开方肯定在0-x之间，0-x为有序数组，可使用二分查找2.处理特殊情况(x==0/x==1)3.使用mid=start+(end-start)/2代替mid=(start+end)/2，防止(start+end)越界溢出4.使用mid与x/mid作比较代替midmid与x作比较，防止midmid越界溢出 摆硬币Leetcode:441.Arranging Coins(Easy)1int 思路：1.能摆的层数h肯定在0-x之间，0-x为有序数组，可使用二分查找 数据结构","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://harviealwayshere.github.io/tags/算法/"},{"name":"数据结构","slug":"数据结构","permalink":"https://harviealwayshere.github.io/tags/数据结构/"}]},{"title":"C++字符及字符串操作","slug":"cplusplus2","date":"2018-03-26T01:42:22.000Z","updated":"2018-03-26T02:52:16.220Z","comments":true,"path":"2018/03/26/cplusplus2/","link":"","permalink":"https://harviealwayshere.github.io/2018/03/26/cplusplus2/","excerpt":"","text":"C++中字符和字符串的操作不可忽略，即便已经掌握了许多算法和数据结构，对于数据输入处理成可操作的数据这一过程，大多是需要字符和字符串操作的 String类1.头文件及命名空间12#include &lt;string&gt;using namespace std; 2.声明与初始化12345678910111213141516//声明string str;string strArray[10];//初始化//默认构造函数初始化为空字符串string str; //复制构造函数初始化string str1=\"Hello\";//string(const char *s);字符指针(字符串)初始化string str2(\"charPointer\"); //string(char *s,int pos,int size);字符指针(字符串)指定位置初始化string str3(\"charPointer\",2,5); 3.操作字符串 3.1.strcpy(a,b):将b复制给a123456789101112//函数实现char* strcpy(char* a,char* b)&#123; assert(a!=NULL &amp;&amp; b!=NULL); char* aHead=a; while(*a !='\\0') *a++ = *b++; return aHead;&#125;//函数操作char a[]=\"i am a student.\";char b[20];strcpy(b,a);cout&lt;&lt;b; //i am a student.3.2.strcat(a,b):将ab连接起来1234567891011121314//函数实现char* strcat(char* a,char* b)&#123; assert(a!=NULL &amp;&amp; b!=NULL); char* head=a; while(*a !='\\0') a++; while(*b!='\\0') *a++ = *b++; *a='\\0'; return head;&#125;//函数操作char a[]=\"i am a student.\";char b[]=\"YES\";strcat(a,b);cout&lt;&lt;a; //i am a student.YES3.3.strncat(a,b,n):在a后追加b的n个字符1234567891011121314//函数实现char* strncat(char* a,const char* b,int n)&#123; assert(a!=NULL &amp;&amp; b!=NULL); char* head=a; while(*a !='\\0') a++; while(n-- &amp;&amp; *b!='\\0') *a++ = *b++; *a='\\0'; return head;&#125;//函数操作char a[]=\"i am a student.\";char b[]=\"YES\";strncat(a,b,2);cout&lt;&lt;a; //i am a student.YES3.4.strcmp(a,b):比较ab字符串，相等返回0、a\\b返回正数","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://harviealwayshere.github.io/tags/C/"},{"name":"字符","slug":"字符","permalink":"https://harviealwayshere.github.io/tags/字符/"},{"name":"字符串","slug":"字符串","permalink":"https://harviealwayshere.github.io/tags/字符串/"}]},{"title":"剑指Offer基础知识(六)面试中的各项能力","slug":"offer6","date":"2018-03-19T12:59:31.000Z","updated":"2018-03-21T14:32:39.145Z","comments":true,"path":"2018/03/19/offer6/","link":"","permalink":"https://harviealwayshere.github.io/2018/03/19/offer6/","excerpt":"","text":"本文主要记录阅读剑指Offer这本书所遇到的算法解释并作一些个人的拓展，其中的算法面试题请看剑指Offer面试题集 6.2沟通和学习能力沟通能力：面试者无论在介绍项目经验还是介绍解题思路时，都需要逻辑清晰明了，语言详略得当，表述时突出重点、观点明确学习能力：计算机知识技术更新换代很快，从业人员需要很强的学习能力，面试官通常有两种方法考擦，第一种是询问最近在看什么书、做什么项目、从中学习到了什么新技术，第二种是抛出一个新概念，接下来观察应聘者能不能在短时间理解新概念并解决相关问题，如丑数、二叉树镜像、逆序对等提问能力：学习能力强的人应该具有主动积极的态度，对未知的领域有强烈的求知欲望，遇到不懂的问题应该主动提问 6.3知识迁移能力知识需要可以变现，即将已有的技术理解迁移到学习新技术的过程中，一般考察方式有两种第一种是将经典问题稍作变换，考察面试者找到和经典问题的联系，并从中受到启发解决新问题如面试题38数字在排序数组中出现的次数，排序数组可以想到二分查找，我们可以把二分查找的思想迁移稍作变换，用二分查找找到排序数组中重复数字的第一个和最后一个，从而得到数字在数组中出现的次数第二种是先问一个简单问题之后追问一个相关的难度更大的问题，考察面试者总结简单问题的思路方法迁移至解决困难问题如面试题40数组中只出现一次的数字，如面试官先问数组中只有一个数字出现一次的情况，后面追问数组中有多个数字出现一次等重要的是举一反三的能力，题目是刷不完的，只有总结题目的特点和思路，才能分析新题目的相关性提高举一反三的能力 6.4抽象建模能力针对实际生产生活，面试官喜欢从其中提炼出问题，考查面试者是否能建立数学模型解决问题建模第一步是选择合理的数据结构来表示问题，需要根据问题的特点考虑性能、编程难度等如面试题44中用一个数组表示一副牌，用11、12、13表示JQK，用0表示大小王在面试题45中用一个环形链表模拟一个圆圈建模第二步是分析模型中的内在规律，只有对问题进行细微的分析，才能找到模型中的规律解决问题如面试题”青蛙跳台阶”内在规律是斐波那契数列如面试题43本质是求数列fn=f(n-1)+f(n-2)+f(n-3)+f(n-4)+f(n-5)+f(n-6)","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://harviealwayshere.github.io/tags/剑指Offer/"},{"name":"解题思路","slug":"解题思路","permalink":"https://harviealwayshere.github.io/tags/解题思路/"}]},{"title":"剑指Offer基础知识(五)优化时间和空间的效率","slug":"offer5","date":"2018-03-17T09:00:11.000Z","updated":"2018-03-19T12:59:02.825Z","comments":true,"path":"2018/03/17/offer5/","link":"","permalink":"https://harviealwayshere.github.io/2018/03/17/offer5/","excerpt":"","text":"本文主要记录阅读剑指Offer这本书所遇到的算法解释并作一些个人的拓展，其中的算法面试题请看剑指Offer面试题集 5.2 时间效率1.细节方面：使用引用(指针)传递复杂类型参数，若采用传值传递参数，从形参到实参会产生一次复制操作 2.实现方式：递归本质是将大的复杂问题分解成小问题解决，若小问题中有重叠部分，则递归时间效率会很差，可采用基于循环+用数组保存中间结果来实现，绝大部分动态规划算法都是分这两个步骤完成 3.数据结构和算法：如查找，不同算法需要的时间效率不同，不同数据结构如哈希表查找的时间不同 5.3时间效率与空间效率的平衡软件开发中我们允许以牺牲一定空间为代价优化时间性能，尽可能缩短软件响应时间面试时我们分配少量辅助空间以提高时间效率通常是可以的如面试题34中用一个数组按照从小到大的顺序保存已经求出的丑数如面试题43中交替使用两个数组求骰子每个点数出现的次数但是时间换空间策略并不一定都是可行，如哈希表的空间消耗过大，我们要根据实际情况权衡如面试题35中数组实现简易哈希表在O(1)查找任意字符，对于ASCII字符总共有256个，因此只需要1K的辅助内存，对于大多数硬件可以接受，但是对于16位的Unicode字符，创建一个长度为2^16的整型数组需要4*2^16就是256K，对于一些嵌入式开发则需要注意 5.4总结降低时间复杂度的方法有两种1.改用更高效的算法：如动态规划、快速排序、摩尔投票算法等2.用空间换时间：如哈希表、递归时有重复子问题可以存储子问题的结果避免重复计算值得一提的是，空间换取时间不一定可行，注意需要的辅助空间的大小，消耗太多内存可能得不偿失","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://harviealwayshere.github.io/tags/剑指Offer/"},{"name":"解题思路","slug":"解题思路","permalink":"https://harviealwayshere.github.io/tags/解题思路/"}]},{"title":"剑指Offer基础知识(四)解决面试题的思路","slug":"offer4","date":"2018-03-12T08:22:11.000Z","updated":"2018-03-17T03:15:30.586Z","comments":true,"path":"2018/03/12/offer4/","link":"","permalink":"https://harviealwayshere.github.io/2018/03/12/offer4/","excerpt":"","text":"本文主要记录阅读剑指Offer这本书所遇到的算法解释并作一些个人的拓展，其中的算法面试题请看剑指Offer面试题集 4.2 画图让抽象问题形象化画图可以帮助面试者分析、推理问题，借以辅助自己观察和思考，使抽象问题具体化，找到解题的关键对于数据结构问题，如二叉树、二维数组、链表等，画图可以让我们容易找出题目中隐含的规律和特点。 如面试题19中画图可以发现求树镜像的过程就是在遍历树的同时交换非叶节点的左右子节点 如面试题20中画图容易发现打印矩阵中的边界条件最后一圈退化的规律 如面试题26中可以发现画出每一步操作时的指针操作写代码会容易得多画图还可以向面试官解释自己的思路，面试官会觉得面试者有良好的沟通交流能力 4.3 举例让抽象问题具体化一眼看不出问题中隐藏的规律时，我们可以试者用一两个具体的例子模拟操作的过程 如面试题22中栈压入弹出序列可以分析一两个序列找到隐含的规律 如面试题24二叉搜索树的后序遍历序列，可以通过分析一两个具体序列找到后续遍历的规律 具体例子还可以帮助我们向面试官解释算法思路 如面试题21包含min函数的栈可以举例模拟压栈和弹出几个数字，分析每次之后的栈、辅助栈、最小值各是什么，能把复杂问题用简单方式说清楚 具体例子还可以确保代码质量，我们可以写完代码用几个测试用例在心里模拟结果，保证正确性 分解让复杂问题简单化我们遇到复杂的大问题，可以分解成若干个简单的小问题，再逐个解决这些小问题分治法采用的就是逐个击破的思想，将小问题各个解决结合起来解决大问题 如面试题26中将复杂链表复制过程分解成三个步骤 面试题27中转换整个二叉树为双向链表是一个大问题，我们将其分解成转换成左子树和右子树，再把左右子树得到的链表和根节点连接起来 面试题28中将整个字符串分为两部分，第一个字符和它后面的所有字符，整个字符串排列是个大问题，第一个字符之后的字符串排列就是个小问题了","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://harviealwayshere.github.io/tags/剑指Offer/"},{"name":"解题思路","slug":"解题思路","permalink":"https://harviealwayshere.github.io/tags/解题思路/"}]},{"title":"剑指Offer基础知识(三)高质量代码","slug":"offer3","date":"2018-03-10T06:32:57.000Z","updated":"2018-03-11T07:56:22.640Z","comments":true,"path":"2018/03/10/offer3/","link":"","permalink":"https://harviealwayshere.github.io/2018/03/10/offer3/","excerpt":"","text":"本文主要记录阅读剑指Offer这本书所遇到的算法解释并作一些个人的拓展，其中的算法面试题请看剑指Offer面试题集 第三章 高质量代码3.2代码的规范性 书写清晰：字母书写清楚，思路清晰 布局清晰：合理的缩进，括号对齐成对 命名合理：完整的英文单词组合3.3代码的完整性 功能测试：首先保证代码完成基本功能，特殊输入等 边界测试：循环结束条件是否正确，递归终止边界值是否正确 负面测试：错误输入，非法输入的处理方式 通常有3种错误处理方式： 1.函数返回值：如Windows的API中返回值为0则调用成功，返回值非0则调用失败，根据非0值可以判断出错原因，但是这种方式不直观且不易传递返回结果给其他函数 2.设置全局变量：我们可以在返回值中传递计算结果了，如果运行出错，可以调用函数分析出错的全局变量，从而得出出错的原因，缺点是调用者容易忘记检测全局变量，在调用出错时忘记做相应错误处理，留下安全隐患 3.抛出异常：函数运行出错我们可以抛出异常，根据不同的出错原因定义不同的异常类型，调用者根据异常类型就能知道出错原因，可以利用try-catch语法抛出异常，逻辑清晰 3.4代码的鲁棒性鲁棒性指程序能付判断输入是否符合要求并对不符合要求的输入给予处理容错性是鲁棒性的一个体现，对于发生异常输入，需要养成防御性编程的习惯，对于异常情况能作出相应处理","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://harviealwayshere.github.io/tags/剑指Offer/"},{"name":"代码质量","slug":"代码质量","permalink":"https://harviealwayshere.github.io/tags/代码质量/"}]},{"title":"剑指Offer面试题集","slug":"offerMianshi","date":"2018-03-09T03:21:35.000Z","updated":"2018-03-22T08:37:29.278Z","comments":true,"path":"2018/03/09/offerMianshi/","link":"","permalink":"https://harviealwayshere.github.io/2018/03/09/offerMianshi/","excerpt":"","text":"本文记录剑指Offer中的50道面试题及一些个人个人拓展大纲 面试题 1：赋值运算符函数 面试题 2：实现Singleton（单例）模式 面试题 3：二维数组中的查找 面试题 4：替换空格 面试题 5：从尾到头打印链表 面试题 6：重建二叉树 面试题 7：用两个栈实现队列 面试题 8：旋转数组的最小数字 面试题 9：斐波那契数列 面试题 10：二进制中1的个数 面试题 11：数值的整数次方 面试题 12：打印1到最大的n位数 面试题 13：在O(1)时间删除链表结点 面试题 14：调整数组顺序使奇数位于偶数前面 面试题 15：链表中倒数第K个结点 面试题 16：反转链表 面试题 17：合并两个排序的链表 面试题 1：赋值运算符函数赋值运算符函数基础4要数:1.返回值类型声明为该类型的引用并在函数结束前返回实例自身引用：只有这样才能实现连续赋值运算2.参数类型声明为常量引用:常量是因为在函数体内不改变传入实参状态，引用是可以减少一次从形参到实参的复制构造函数的调用，节省空间开销提高代码效率3.释放实例自身已有内存:在分配新内存之前释放已有空间，避免内存泄露4.需要判断传入参数和当前实例(*this)是不是同一个实例:若是同一个则不进行赋值直接返回，若没有判断则在释放实例自身内存时传入的参数的内存也被释放了，就再也找不到需要赋值的内容了结合以上4点的解法1234567891011CMyString&amp; CMyString::operator =(const CMyString &amp;str) //返回值+参数(1.2.)&#123; if(this == $str) return *this; //判断是否是自身赋值自身(4.) delete []m_pData; //被赋值的实例的成员变量delete释放内存(3.) m_pData = NULL; //初始化变量 m_pData = new char[strlen(str.m_pData)+1]; //new分配内存 strcpy(m_pData,str.m_pData); //赋值 return *this; //返回自身实例用于连续赋值运算(1.)&#125; 考虑异常安全性:若new char时内存不足导致抛出异常，m_pData将是空指针，程序十分容易崩溃，此时由于被赋值的实例的成员变量已经被delete了，实例改变了自身的状态，违背了异常安全原则。解决方案:1.先new分配内存再delete释放内存，当new失败时我们能确保实例不会被修改原先状态2.先创建一个临时实例，再交换临时实例和原来的实例，如下1234567891011121314CMyString&amp; CMyString::operator =(const CMyString &amp;str) &#123; if(this != $str) &#123; CMyString strTemp(str); //调用复制构造函数新创建一个临时实例 char* pTemp = strTemp.m_pData; //利用一个中间变量pTemp将变量值交换 strTemp.m_pData = m_pData; m_pData = pTemp; &#125; //在if作用域外，由于strTemp是局部变量会自动调用析构函数释放内存，//其中strTemp中的成员变量m_pData所指向的内存就是原来被赋值实例成员函数的内存，刚好一并释放 return *this;&#125; 面试题 3：二维数组中的查找一般的思路是从左上角开始做比较，但是减小排除的范围无规律，若是从右上角或者左下角做比较，则可以以行或者列减小排查范围，而二维数组以连续内存存储的特性让我们可以通过下标访问数组以矩阵形式的空间位置。1234567891011121314151617181920212223bool Find(int* matrix, int rows, int columns, int number)&#123; bool found = false; if(matrix != NULL &amp;&amp; rows &gt;0 &amp;&amp; columns &gt;0) //矩阵有效性检测（若输入空指针） &#123; int row = 0; int column = column -1; while(row &lt; rows &amp;&amp; column &gt;=0) //循环停止条件:最后一行或者第一列 &#123; if(matrix[row * columns + column] == number) //第row行第column列，相当于[row][column] &#123; found = true; break; &#125; else if(matrix[row * columns + column] &gt;number) column--; else row++; &#125; &#125; return found;&#125; 面试题 4：替换空格网络编程中，URL参数中特殊字符串(空格、#等)需要替换成服务器端可以识别的字符，转换的规则是在’%’后面加上字符ASCII码的两位十六进制表示，如空格的ASCII码为32，十六进制为0x20，因此空格被替换成”%20”。解题思路:题目理解有两种，第一种是创建新的字符串并在新的字符串上做替换，则我们可以分配足够多的内存，第二种是在原字符串上做替换，则我们需要保证输入字符串后有足够多的空余内存并且不能覆盖原字符串的内存。解法一:字符串从前往后遍历找到一个空格则空格后的字符集体向后移动两个字节大小。时间复杂度为O(n^2)，多次移动次数，不是好的解决方案。解法二:先遍历一次字符串，统计出字符串中空格总数由此计算出替换后字符串的长度，之后从字符串末尾开始复制和替换，这样所有字符只移动一次，算法的时间效率是O(n)。具体的复制和替换过程为使用两个指针123456789101112131415161718192021222324252627282930313233343536373839404142void ReplaceBlank(char string[], int maxLength)&#123; if(string == NULL &amp;&amp; length &lt;= 0) //输入参数有效性检测性 return; //originalLength为字符串原先长度 int originalLength = 0; int numberOfBlank = 0; int i = 0; while(string[i] != '\\0') &#123; originalLength++; if(string[i] == ' ') numberOfBlank++; i++; &#125; //newLength为替换后的字符串长度 int newLength = originalLength + numberOfBlank * 2; if(newLength &gt; maxLength) //如果替换后字符串长度大于字符串总容量 return; int indexOfOriginal = originalLength; int indexOfNew = newLength; while(indexOfOriginal &gt;= 0 &amp;&amp; indexOfNew &gt; indexOfOriginal)//替换完成条件 &#123; //若是空格则后面的标记添加并前移三个字节 if(string[indexOfOriginal] == ' ') &#123; string[indexOfNew --] = '0'; string[indexOfNew --] = '2'; string[indexOfNew --] = '%'; &#125; else &#123; //若不空格则复制前面指针的字符到后面指针的位置，并前移指针 string[indexOfNew --] = string[indexOfOriginal]; &#125; -- indexOfOriginal; &#125; &#125; 面试题 5：从尾到头打印链表面试中如果我们打算修改输入数据，最好先问面试官允不允许。若允许我们可以将链表中的节点指针反转改变链表方向就可以了。通常打印是一个只读操作，假设面试官要求这个题目不能改变链表结构。思路：遍历是从头到尾，输出却是从尾到头，这是典型的后进先出的栈结构，然后递归的本质就是栈结构，于是我们可以每访问一个节点先递归输出它后面的节点，再输出该节点自身。显示用栈调用代码如下12345678910111213141516171819//Reversingly-倒置地void printListReversingly(ListNode* pHead) //不用改变头指针，可传值&#123; std::stack&lt;ListNode*&gt; nodes; ListNode *pNode = pHead; while(pNode != NULL) &#123; node.push(pNode); //入栈 pNode = pNode-&gt;Next; &#125; while(!node.empty()) &#123; pNode = nodes.top(); //取栈顶元素 cout &lt;&lt; pNode-&gt;Value &lt;&lt; endl; //输出节点值 nodes.pop(); //弹出栈顶元素 &#125;&#125;基于递归的栈调用代码如下12345678910//Recursively-递归地void printListReversinglyRecursively(ListNode* pHead) //不用改变头指针，可传值&#123; if(pHead != NULL) //判断是不是空链表 &#123; if(pHead-&gt;Next != NULL) printListReversinglyRecursively(pHead-&gt;Next); //判断是不是最后一个结点，若是最后一个结点则递归结束 cout &lt;&lt; pHead-&gt;Value &lt;&lt; endl; &#125; &#125;Tips:链表长时，导致函数调用层级很深，有可能导致函数调用栈移除，鲁棒性(程序稳定性)不好。 面试题 6：重建二叉树思路：前序遍历可以确定树的根节点(第一个数字)，中序遍历在知道了根节点的值后可以知道左子树的结点值(根节点左边的所有值)和右子树的结点值(根节点右边的所有值)，之后用递归的方式完成剩下子树的建立12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//树的主构造函数BinaryTreeNode* Construct(int* preorder, int* inorder, int length)&#123; if(preorder == NULL || inorder == NULL || length &lt;= 0) //输入有效性检测 return NULL; return ConstructCore(preorder, preorder+length-1, inorder, inorder+length-1);&#125;//树的核心构造函数，通过传入前序遍历的头尾指针、中序遍历的头尾指针递归建树BinaryTreeNode* ConstructCore(int* startPreorder, int *endPreorder, int* startInorder, int* endInorder)&#123; //前序遍历的第一个数字是根节点的值 int rootValue = startPreorder[0]; BinaryTreeNode* root = new BinaryTreeNode(); root-&gt;m_nValue = rootValue; root-&gt;m_pLeft = root-&gt;m_pRight = NULL; if(startPreorder == endPreorder) &#123; //若是输入的树前序只有一个值、中序也只有一个值且这两个值是同一个值 //则输入的这个值就是这棵树的根节点，否则是无效输入 if(startInorder == endInorder &amp;&amp; *startPreorder == *startInorder) return root; else throw std::exception(\"Invalid input\"); &#125; //在中序遍历中找到根节点的值 int* rootInorder = startInorder; while(rootInorder &lt;= endInorder &amp;&amp; *rootInorder != rootValue) rootInorder++; //如果找到的节点在中序的末尾且值并不是根节点的值，返回错误 if(rootInorder == endInorder &amp;&amp; *rootInorder != rootValue) throw std::exception(\"Invalid input\"); //可以通过找到的节点确定左子树长度和左子树范围 int leftLength = rootInorder - startInorder; int* leftPreorderEnd = startPreorder + leftLength; if(leftLength &gt;0) &#123; //构建左子树 root-&gt;m_pLeft = ConstructCore(startPreorder+1,leftPreorderEnd,startInorder,rootInorder-1); &#125; if(leftLength &lt; endPreorder-startPreorder) &#123; //构建右子树 root-&gt;m_pRight = ConstructCore(leftPreorderEnd+1,endPreorder,rootInorder+1,endInorder); &#125; return root;&#125;让我们来看看ConstructCore做了什么事 面试题 7：用两个栈实现队列思路：插入元素直接插入第一个栈即可，删除元素则若是第二个栈有元素就pop，若是第二个栈没有元素，则将第一个栈的元素全部pop并push进第一个栈，之后按照第二个栈有元素的方式pop123456789101112131415161718192021222324252627//元素入队template&lt;typename T&gt; void CQueue&lt;T&gt;::appendTail(const T&amp; element)&#123; stack1.push(element);&#125;//元素出队template&lt;typename T&gt; T CQueue&lt;T&gt;::deleteHead()&#123; if(stack2.size() &lt;= 0) //stack2空则将stack1全部弹出压如stack2 &#123; while(stack1.size() &gt; 0) &#123; T&amp; data = stack1.top(); stack1.pop(); stack2.push(data); &#125; &#125; //此时若是stack2还是空，则证明队列是空的 if(stack2.size() = 0) throw new exception(\"queue is empty\"); T head = stack2.top(); //否则弹出栈顶元素 stack2.pop(); return head;&#125;两个栈实现一个队列像是一个是插入栈一个是删除栈，而两个队列实现一个栈呢？思路如下 面试题 8：旋转数组的最小数字输入：{3,4,5,1,2}为数组{1,2,|3,4,5}的旋转输出：1思路： 1.直接遍历：时间复杂度为O(n)，但没有利用旋转数组的特性 2.二分查找法：将数组看成两个递增数组，设置两个指针指向第一个元素p和最后一个元素q，由于一开始的数组为递增数组，则array[p]&gt;=array[q]，此时中间元素m若大于array[p]则为前部分递增数组的元素于是将p=m，中间元素若小于array[q]则为后部分递增数组的元素于是将q=m，不断逼近两个递增数组的交界元素，最后若p=q-1则找到了数组交界，此时array[q]为最小元素/array[p]为最大元素 3.特殊情况：若array[p]==array[q]==array[m]则无法确认arrary[m]属于哪部分数组，这种情况如下，需要使用顺序查找1234567891011121314151617181920212223242526272829303132333435//二分查找int Min(int array[],int length)&#123; //输入有效性检测 if(array==NULL || length&lt;=0) throw new std::exception(\"Invaild parameters\"); int p=0; int q=length-1; //m初始化为0，因为若旋转数组是将0个元素放在后面，最小元素则为第一个元素 int m=0; while(array[p]&gt;=array[q]) &#123; if(q-p==1)&#123; m=q; break; &#125; m=(p+q)/2; //若array[p]==array[q]==array[m]转为顺序查找 if(array[p]==array[q] &amp;&amp; array[m]==array[p]) return MinInOrder(array,p,q); if(array[m]&gt;=array[p]) p=m; else q=m; &#125; return array[m];&#125;//顺序查找int MinInOrder(int array[],int p,int q)&#123; int result = array[p]; for(int i=p+1;i&lt;=q;i++) &#123; if(array[i]&lt;result) result = array[i]; &#125; return result;&#125; 面试题 9：斐波那契数列若用递归很简单123456int Fibonacci(int n)&#123; if(n&lt;=0) return 0; else if(n==1) return 1; else return Fibonacci(n-1)+Fibonacci(n-2);&#125;递归实现的效率十分低，而且设计大量的重复计算，如计算F(10)要计算F(9)+F(8)，而计算F(9)又要计算F(8)+F(7)，这样F(8)就重复计算了 改进1：避免重复计算，将计算得到的中间项保存12345678910111213int Fibonacci(int n)&#123; int *result = new int[n];; //将中间项保存至数组中 result[0]=0; result[1]=1; if(n&lt;2) return result[n]; for(int i=2;i&lt;=n;i++) &#123; result[i]=result[i-1]+result[i-2]; &#125; return result[n];&#125;改进2：改进1虽然避免了重复计算，但是空间开辟了太大，我们只需要得到F(n)不关心中间项的结果，因此中间项我们不必保存下来123456789101112131415161718int Fibonacci(int n)&#123; int result[2]; result[0]=0; result[1]=1; if(n&lt;2) return result[n]; int n_1=1; int n_2=0; int n_now=0; for(int i=2;i&lt;=n;i++) //不保存中间项，只保存前面两项，实时替换 &#123; n_now = n_1 + n_2; n_2=n_1; n_1=n_now; &#125; return n_now;&#125;—面试题 10：二进制中1的个数思路1:：1的二进制为0…01，即除了第一位为1其他位均为0，利用这点，任何数与1作与运算，若其第一位为1，则运算结果为1，其第一位为0，则运算结果为0，之后可利用右移运算符验证下一位数直到所有数为0思路1有一个问题是负数右移运算左边补的不是0而是1保证负数性质，因此最后数字会变成1….1陷入死循环思路2:：利用将1左移可避免死循环1234567891011int numberOfNum(int n)&#123; int count=0; unsigned int flag=1; while(flag) &#123; if(n &amp; flag) count++; flag = flag &lt;&lt;1; &#125; return count;&#125;思路2的问题是效率太低，有多少位的整数就要循环移动多少次思路3:：改变原来的数，消除输入数中的1，输入数中至少有一个1，若为xxx1000，则减1为xxx0111，此时减去的数与输入数做与运算，得到的结果是xxx0000，与输入数相比我们消除了其右边第一个1，继续使用这种方法直到输入数所有1被消除为0时停止12345678910int numberOfNum(int n)&#123; int count=0; while(n) &#123; count++; n=n &amp; (n-1); &#125; return count;&#125;总结：把一个整数减去1之后再和原来的整数做与运算，得到的结果相当于把原来整数的二进制表示中的最右边的1变成0，即xxx100 &amp; xxx011 = xxx000面试题 11：数值的整数次方类似于实现pow函数功能思路1：使base与自身相乘循环exponent次数，缺点输入指数为0或者负数无法执行思路2：负数时，可以对指数求绝对值，算出base的次方结果后再取倒数，当然要注意底数base是0的情况，0求倒数程序会运行出错，这时可以使用抛出异常处理12345678910111213141516171819202122232425262728293031323334double Power(double base,int exponent)&#123; //0的负数次幂 if(equal(base,0.0) &amp;&amp; exponent&lt;0) throw new std::exception(\"Invaild Base\"); //0的0次或者正数次幂为0 if(equal(base,0.0)) return 0; double result; //非0的负数次幂，幂取绝对值，算pow，取倒数 if(exponent &lt; 0) &#123; unsigned int absExponent = (unsigned int)(exponent); result = pow(base,absExponent); result = 1.0/result; return result; &#125;else if(exponent &gt; 0)&#123; //非0的整数次幂，算pow result = pow(base,exponent); return result; &#125;else&#123; //非0的0次幂为1 return 1; &#125;&#125;double pow(double base,unsigned int exponent)&#123; double result = 1.0; for(int i=0;i&lt;=exponent;i++) result *= base; return result;&#125;//判断base是否为0函数bool equal(double num1,double num2)&#123; if((num1-num2 &gt;-0.0000001) &amp;&amp; (num1-num2 &lt;0.0000001)) return true; else return false;&#125;思路3：当exponent较大时，pow函数中循环需要做多次乘法，可以优化一下乘方运算，用如下公式求a的n次方12345678910111213141516double pow(double base,unsigned int exponent)&#123; //递归返回条件 if(exponent ==0) return 1; if(exponent ==1) return base; double result = pow(base,exponent &gt;&gt;1); //用右移运算代替除2 //exponent为偶数时 直接相乘即可 result *= result; //exponent为奇数时，还需乘base if(exponent &amp; 0x1 ==1) result*=base; //用位运算代替了求余运算判断是否奇数 return result;&#125;—面试题 12：打印1到最大的n位数陷阱：大数问题，没有规定n的范围，若n位数大于整型(int)或者长整型(long long)时会溢出思路1：在字符串上模拟数字加法，1.申明一个长度为n+1的字符串(最后一个是结束符号’\\0’)，将字符串中数字初始化为’0’2.字符串数字加法函数3.打印字符串函数1234567891011121314151617void PrintToMaxDigits(int n)&#123; if(n&lt;=0) return; char *number = new char[n+1]; memset(number,'0',n); number[n]='\\0'; while(!Increment(number)) PrintNumber(number); delete []number;&#125;bool Increment(char* number)&#123; bool isOverflow = false; &#125;面试题 13：在O(1)时间删除链表结点思路1：从头指针遍历到结点指针的上一个指针，之后将上一个指针的Next指向结点指针的Next指针指向的结点即可，之后在链表中删除该结点，由于是顺序查找，时间复杂度为O(n)不符合要求思路2：将结点指针的下一个指针的内容复制到需要删除的节点上，再把下一个指针删除，注意有两种特殊情况1.结点指针是尾指针：此时没有下一个指针，因此还是需要顺序查找从头遍历2.链表中只有一个结点：我们要删除的也是这个结点，这种情况我们删除掉结点后还要把链表的头结点设置为NULL1234567891011121314151617181920212223242526272829303132void deleteNode(ListNode** pListHead,ListNode* pToBeDelete)&#123; //有效性检测 if(pListHead == NULL || pToBeDelete==NULL) return; //结点指针不是尾指针 if(pToBeDelete-&gt;m_pNext!=NULL) &#123; ListNode* pNext=pToBeDelete-&gt;m_pNext; //结点指针的下一个指针 //将下一个指针的内容全部复制到结点指针 pToBeDelete-&gt;m_nValue=pNext-&gt;m_nValue; pToBeDelete-&gt;m_pNext=pNext-&gt;m_pNext; //删除下一个指针 delete pNext; pNext=NULL; &#125;else if(*pListHead=pToBeDelete) //若节点指针是尾指针也是头指针 &#123; delete pToBeDelete; pToBeDelete=NULL; *pListHead=NULL; //头指针设置为NULL &#125;else //若节点指针是尾指针但不是头指针 &#123; //思路1：顺序遍历删除 ListNode* pNode=*pListHead; while(pNode-&gt;m_pNext!=pToBeDelete) pNode=pNode-&gt;m_pNext; //找到节点指针的上一个指针 pNode-&gt;m_pNext=NULL; delete pToBeDelete; pToBeDelete=NULL; &#125;&#125;时间复杂度：对于n-1个非尾节点，为O(1);对于尾节点，为O(n)；平均为[(n-1)*O(1)+O(n)]/n，结果还是O(1);面试题 14：调整数组顺序使奇数位于偶数前面思路1：维护数组的两个头尾指针，头指针向后移动直到遇到偶数停下，尾指针想前移动直到遇到奇数停下，若停下时头指针在尾指针前面则交换两个指针的值继续移动，否则停止移动调整数组顺序完成1234567891011121314151617181920212223void ReorderArray(int* array,int length)&#123; //有效性检测 if(array==NULL || length &lt;=0) return; int *head=array; //头指针 int *end=array+length-1; //尾指针 while(head&lt;end) &#123; //头指针向后移动直到遇到偶数 while(head&lt;end &amp;&amp; (*head &amp; 0x1) != 0) head++; //尾指针向前移动直到遇到奇数 while(head&lt;end &amp;&amp; (*end &amp; 0x1) == 0) end--; if(head&lt;end) //交换 &#123; int temp=*head; *head=*end; *end=temp; &#125; &#125; &#125;思路2：解耦，可将判断条件封装成一个函数，即可拓展成许多情况，如将正数放在负数前面，将3整除的数放在3不整除的数，如快速排序中的分区函数比基准数小的数放在比基准书大的数的前面123456789101112131415161718192021void ReorderArray(int* array,int length，bool (*func)(int))&#123; if(array==NULL || length &lt;=0) return; int *head=array; int *end=array+length-1; while(head&lt;end) &#123; while(head&lt;end &amp;&amp; func(*head)) head++; while(head&lt;end &amp;&amp; func(*end)) end--; if(head&lt;end) &#123; int temp=*head; *head=*end; *end=temp; &#125; &#125; &#125;bool isEven(int n)&#123; return (n &amp; 1)==0; //偶数与1位运算为0 奇数与1位运算不为0&#125;面试题 15：链表中倒数第K个结点思路1：由于是单向链表，因此无法从尾到头遍历，我们要找倒数第k个结点，若是知道链表中共有n个结点(尾节点为第n-1个结点)，则找的是n-(k-1)就是第n-k+1个结点；我们可以定义两个指针指向头指针，由于倒数第k个结点的指针与尾指针相差k-1个结点，则让第一个指针先走k-1个结点，之后两个指针同时向后走，第一个指针走到尾节点时，第二个指针与其也相差k-1个结点，即是倒数第k个结点鲁棒性检测1.头指针为空指针2.链表总数小于k3.输入k为012345678910111213141516171819202122ListNode* findKToTail(ListNode* head,int k)&#123; if(head==NULL || k&lt;=0) return NULL; ListNode* first=head; ListNode* second=head; for(int i=0;i&lt;k-1;i++) //第一个节点走k-1步 &#123; if(first-&gt;m_pNext != NULL) first=first-&gt;m_pNext; else return NULL; //链表中的元素小于k个 &#125; //第一个节点为尾节点时 第二个节点刚好是倒数第k个结点 while(first-&gt;m_pNext != NULL) &#123; first=first-&gt;m_pNext; second=second-&gt;m_pNext; &#125; return second;&#125;面试题 16：反转链表思路：两个指针反转会出现链表断裂，因此需要三个指针，具体操作为前指针，当前指针，后指针，当前指针指向前指针，当前指针变前指针，后指针变当前指针，当前指针的Next指向为后指针，直到当前指针为尾指针，反转后变成头指针陷阱：1.考虑输入的头指针为NULL情况2.输入的链表仅有一个节点的情况3.输入的链表仅有两个结点的情况4.原先头结点的Next变为NULL，头指针指向原先的尾节点12345678910111213141516171819202122232425262728ListNode* reverseList(ListNode* head)&#123; //有效性检测(针对陷阱1) if(head==NULL) return NULL; ListNode* front=NULL; ListNode* now=head; ListNode* back=now-&gt;m_pNext;; if(back!=NULL) //针对陷阱2 &#123; while(back-&gt;m_pNext!=NULL) &#123; //由于一开始front为NULL，所以当now为头节点时反转后就成尾节点，尾节点的Next刚好为NULL now-&gt;m_pNext=front; //针对陷阱4 front=now; now=back; back=now-&gt;m_pNext; &#125; //now为倒数第二个结点时情况+链表就两个结点的情况(即back的Next为NULL) //针对陷阱3 now-&gt;m_pNext=front; back-&gt;m_pNext=now; head=back; //针对陷阱4 &#125; return back;&#125;面试题 17：合并两个排序的链表思路：类似于归并排序中的并过程，两个子数组通过两个指针比较大小值小的放在一个新数组，直到一个数组的值被遍历完之后另一个数组所有值被复制到新数组的后边链表合并也是如此1.新建一个头指针head和当前指针now指向头指针2.新建两个指向子链表头结点的指针p和q3.循环比较 *p和 *q的大小，值小的赋给now-&gt;Next，now-&gt;Next=p(q)，之后p(q)=p(q)-&gt;Next;now=now-&gt;Next;4.直到p(q)=NULL时，将now-&gt;Next=q(p)就完成了123456789101112131415161718192021222324252627282930313233struct ListNode&#123; int val; ListNode* next;&#125;;ListNode* mergeList(ListNode* head1, ListNode* head2)&#123; //有效性检测 if (head1 == NULL) return head2; else if (head2 == NULL) return head1; ListNode* head = new ListNode; //头指针 ListNode* now = head; //当前指针 ListNode* p = head1; ListNode* q = head2; while (p != NULL &amp;&amp; q!= NULL) &#123; if (p-&gt;val&gt;q-&gt;val) &#123; now-&gt;next = q; //当前指针指向值小的结点 q = q-&gt;next; //结点跳到下一个 &#125; else&#123; now-&gt;next = p; p = p-&gt;next; &#125; now = now-&gt;next; //当前指针跳到下一个 &#125; if (p == NULL) now-&gt;next = q; if (q == NULL) now-&gt;next = p; return head-&gt;next;&#125;面试题 18：树的子结构思路：1.找到树1中与树2根节点的值相同值的结点2.递归判断是否两个相同值的结点有相同的树结构3.否则继续递归遍历其他根节点++1234567891011121314151617181920212223242526272829303132struct BinaryTreeNode&#123; int val; BinaryTreeNode* left; BinaryTreeNode* right;&#125;;//递归遍历执行1.3.步bool HasSubtree(BinaryTreeNode* root1,BinaryTreeNode* root2)&#123; bool result==false; //有效性检测 if(root1 !=NULL &amp;&amp; root2 !=NULL) &#123; if(root1-&gt;val==root2-&gt;val) result=HasSameStruct(root1,root2) if(!result) result=HasSubtree(root1-&gt;left,root2); if(!result) result=HasSubtree(root1-&gt;right,root2); &#125; return result;&#125;//递归遍历执行2.步bool HasSameStruct(BinaryTreeNode* root1,BinaryTreeNode* root2)&#123; if(root2==NULL) return true; //正确遍历到树2的叶节点时，则证明树的结构相同 if(root1==NULL) return false; //遍历到树1的叶节点而不是树2的叶节点时，则证明树的结构不同 if(root1-&gt;val != root2-&gt;val) return false; //遍历到树1的内部结点和树2的内部结点的值不同时，则证明树的结构不同 return HasSameStruct(root1-&gt;left,root2-&gt;left) &amp;&amp; HasSameStruct(root1-&gt;right,root2-&gt;right); //遍历到树1的内部结点和树2的内部结点的值相同时，则继续向下遍历&#125;面试题 19：二叉树的镜像1234567//二叉树结点定义结构struct BinaryTreeNode&#123; int val; BinaryTreeNode* left; BinaryTreeNode* right;&#125;;思路： 画图可以发现，求树的镜像实质就是1.前序遍历(根-左-右)树的每个结点2.遍历到的结点是非叶子节点(有子节点)则交换两个子节点++1234567891011121314void MirrorTree(BinaryTreeNode* root)&#123; //有效性检测 if(root==NULL) return; //遍历到叶子节点时返回 if(root-&gt;left==NULL &amp;&amp; root-&gt;right==NULL) return; //非叶子节点则交换两个子节点 BinaryTreeNode* temp=root-&gt;left; root-&gt;left=root-&gt;right; root-&gt;right=temp; //继续向下遍历 if(root-&gt;left !=NULL) MirrorTree(root-&gt;left); if(root-&gt;right !=NULL) MirrorTree(root-&gt;right);&#125;面试题 20：顺时针打印矩阵思路：通过画图我们知道1.循环打印的圈数是由矩阵matrix[x][y]中的较小的值决定的，并且每次开始循环打印的坐标点都是(start,start)，综合我们知道循环继续的条件是start*2&lt;x并且start*2&lt;y2.打印一圈可分解成四步：3.关于二位数组传参问题，可参考这里，下面的程序其实会执行出错，因为访问number[i][j]需要使用(int*)number+i*columns+j的方式访问，处于程序清晰思路才写成如下访问方式12345678910111213141516171819202122232425void printMatrix(int** numbers,int rows,int columns)&#123; //有效性检测 if(numbers==NULL || rows&lt;=0 || columns&lt;=0) return; for(int start=0;start*2&lt;rows &amp;&amp; start*2&lt;columns;start++) &#123; int i, j; int endRows = rows - start - 1; int endColumns = columns - start - 1; for (i = start; i&lt;=endColumns; i++) cout &lt;&lt; numbers[start][i] &lt;&lt; ends; if (start &lt; endRows) &#123; for (j = start + 1; j &lt;= endRows; j++) cout &lt;&lt; numbers[j][endColumns] &lt;&lt; ends; &#125; if (start&lt;endRows &amp;&amp; start &lt; endColumns) &#123; for (i = endColumns - 1; i &gt;= start; i--) cout &lt;&lt; numbers[endRows][i] &lt;&lt; ends; &#125; if (start&lt;endRows-1 &amp;&amp; start &lt; endColumns) &#123; for (j = endRows-1; j&gt;start; j--) cout &lt;&lt; numbers[j][start] &lt;&lt; ends; &#125; &#125;&#125;面试题 21：包含min函数的栈思路：建立一个辅助栈存储当前栈中的最小值1.若压入栈的数字大于之前栈中的最小值，则辅助栈压入之前栈中的最小值，2.若压入栈的数字小于之前栈中的最小值，则辅助栈压入当前的最小值1234567891011121314151617181920212223#include&lt;stack&gt;using namespace std;static stack &lt;int&gt;dataStack;static stack &lt;int&gt;minStack;template &lt;typename T&gt; void push(const T&amp; value)&#123; dataStack.push(value); if(minStack.size()==0 || value&lt;minStack.top()) minStack.push(value); else minStack.push(minStack.top());&#125;void pop()&#123; if(dataStack.size()&gt;0 &amp;&amp; minStack.size()&gt;0) &#123; dataStack.pop(); minStack.pop(); &#125;else throw new exception(\"stack is empty\"); &#125;template &lt;typename T&gt; T minFunc()&#123; if(dataStack.size()&gt;0 &amp;&amp; minStack.size()&gt;0) return minStack.top(); else throw new exception(\"stack is empty\"); &#125;Tips:编写代码时的两个小错误1.不可用min()命名函数，与系统函数名冲突2.函数模板的使用函数模板是根据传入参数推测出数据类型，因此不能自动推导返回参数类型，要做到自动推到返回参数类型，可使用- 2.1 多次显示使用特定返回值类型重载函数，如 int minFunc(),double minFunc()- 2.2 使用template T Func()，但是调用时要显示指定T类型，如minFunc()，minFunc()面试题 22：栈的压入、弹出序列思路：检测1：面对弹出序列的下一个弹出数字，若压入栈的栈顶元素是下一个弹出数字，则弹出检测2：若下一个弹出数字不在栈顶，则继续将压栈序列中还没有入栈的数字压入，再次执行检测1检测3：若所有数字都压入栈了仍然没有找到下一个弹出数字，则该序列不可能是一个弹出序列1234567891011121314151617181920bool isPopOrder(const int* pushOrder,const int* popOrder,int length)&#123; //有效性检测 if(pushOrder!=NULL &amp;&amp; popOrder!=NULL &amp;&amp; length&gt;0) &#123; stack &lt;int&gt;stackTest; for(int i=0,j=0;i&lt;length;i++) &#123; stackTest.push(pushOrder[i]); while(j&lt;length &amp;&amp; stackTest.top()==popOrder[j]) &#123; stackTest.pop(); j++; &#125; &#125; return stackTest.empty(); &#125;else return false; &#125;面试题 23：从上往下打印二叉树1234567//二叉树结点定义结构struct BinaryTreeNode&#123; int val; BinaryTreeNode* left=NULL; BinaryTreeNode* right=NULL;&#125;;思路：通过举例可以发现，打印结点的顺序是一个队列1.将跟结点放入队列2.打印队列头部的一个结点，若该结点有子节点，就将其左右结点放在打印队列的末尾，3.重复打印队列头部的结点操作，直到队列中没有结点元素Tips.小技巧：STL提供了两端可以进出的队列deque1234567891011121314151617void printFromTopToBottom(BinaryTreeNode* root)&#123; if(root==NULL) return; std::deque&lt;BinaryTreeNode *&gt; printNodeQueue; printNodeQueue.push(root); while(printNodeQueue.size()!=0) &#123; BinaryTreeNode* printNode=printNodeQueue.front(); printNodeQueue.pop_front(); cout&lt;&lt;printNode-&gt;val&lt;&lt;ends; if(printNode-&gt;left) printNodeQueue.push_back(printNode-&gt;left); if(printNode-&gt;right) printNodeQueue.push_back(printNode-&gt;right); &#125;&#125;技巧：广度优先遍历一个图还是一棵树，都要用到队列面试题 24：二叉搜索树的后序遍历1234567//二叉树结点定义结构struct BinaryTreeNode&#123; int val; BinaryTreeNode* left=NULL; BinaryTreeNode* right=NULL;&#125;;解题思路：递归+后续遍历特点+二叉搜索树特点1.后序遍历中，序列最后一个数字为根结点的值2.二叉搜索树中，左子树的值小于根节点的值，因此序列中前部分小于根节点的值的数为左子树的值3.二叉搜索树中，右子树的值大于根节点的值，因此序列中后部分大于根结点的值的树为右子树的值4.基于2.3.找到左子树和右子树序列，并判断左右子树中的值是否符合二叉搜索树规则5.递归遍历左右子树1234567891011121314bool verifySquenceOfBST(int array[],int start,int end)&#123; //输入有效性检测 if(array==NULL || start&lt;end || start&lt;0 || end&lt;0) return false; if(end-start&lt;=1) return true; int root=array[end]; //1.最后一个数字为根节点的值 int curIndex=start; //当前结点 从头遍历 停在右子树开始结点 while(curIndex&lt;end &amp;&amp; array[curIndex]&lt;=root) curIndex++; //2.找到左子树序列 for(int i=curIndex;i&lt;end;i++) //3.4.找到右子树序列并判断是否符合二叉搜索树规则 &#123; if(array[i]&lt;root) return false; &#125; return verifySquenceOfBST(array,start,curIndex-1) &amp;&amp; verifySquenceOfBST(array,curIndex,end-1); //递归遍历左右子树&#125;针对后序遍历可以使用两种方式实现思路1：通过举例可以发现可以使用递归+栈的形式实现。1.将当前遍历到的结点存入栈中2.递归遍历右子树结点3.递归遍历左子树结点12345678910111213141516171819static stack &lt;int&gt;backOrderStack;void backOrderToStack(BinaryTreeNode* root)&#123; if(root==NULL) return; backOrderStack.push(root-&gt;val); if(root-&gt;right) backOrderToStack(root-&gt;right); if(root-&gt;left) backOrderToStack(root-&gt;left); return;&#125;void printBackOrderStackTree(BinaryTreeNode* root)&#123; backOrderToStack(root); int length = backOrderStack.size(); for(int i=1;i&lt;=length.size();i++) &#123; cout&lt;&lt;backOrderStack.top()&lt;&lt;ends; backOrderStack.pop(); &#125;&#125;思路2：通过举例可以发现可以使用递归+队列的形式实现。1.递归遍历左子树结点2.递归遍历右子树结点3.将当前遍历到的结点存入队列中12345678910111213141516171819static std::deque&lt;int&gt; backOrderQueue;void backOrderToQueue(BinaryTreeNode* root)&#123; if(root==NULL) return; if(root-&gt;left) backOrderToQueue(root-&gt;left); if(root-&gt;right) backOrderToQueue(root-&gt;right); backOrderQueue.push_back(root-&gt;val); return;&#125;void printBackOrderQueueTree(BinaryTreeNode* root)&#123; backOrderToQueue(root); int length=backOrderToQueue.size(); for(int i=1;i&lt;=length;i++) &#123; cout&lt;&lt;backOrderToQueue.front()&lt;&lt;ends; backOrderToQueue.pop_front(); &#125;&#125;面试题 25：二叉树中和为某一值的路径解题思路：前序遍历特点+递归+栈1.由于路径是从根节点出发到叶节点，二叉树遍历中只有前序遍历是首先访问根节点的2.遍历到一个结点时是不知道父节点是什么值的，因此遍历的时候要保存结点3.通过举例可以发现，若遍历到子节点这个路径加起来不是某一值时，要回溯到上一个结点，这是利用了递归的思想4.此时要在保存结点计算路径值的和中删除掉这个结点，重新加上后面遍历的结点，因此保存结点的数据结构实际上是一个栈，因为递归调用的本质就是一个压栈和出栈的过程123456789101112131415161718192021#include &lt;vector&gt;static vector&lt;vector&lt;int&gt;&gt; sumPath; //使用一个二维栈保存多个结果序列vector&lt;vector&lt;int&gt;&gt; findPath(BinaryTreeNode* root,int target)&#123; vector&lt;int&gt; path; dfs(root,target,0,path); return sumPath; &#125;void dfs(BinaryTreeNode* node,int target,int curSum,vector&lt;int&gt; path)&#123; if(node==NULL) return; curSum=curSum+node-&gt;val; //1.前序遍历 path.push_back(node-&gt;val); //2.保存结点 //遍历到根节点时 查看是否满足条件 满足则将这个序列放入结果序列中 if(curSum==target &amp;&amp; node-&gt;left==NULL &amp;&amp; node-&gt;right==NULL) sumPath.push_back(path); else &#123; //遍历到中间结点时继续遍历 dfs(node-&gt;left,target,curSum,path); //3.递归 遍历左结点 dfs(node-&gt;right,target,curSum,path); //3.递归 遍历右结点 &#125; path.pop_back(); //遍历到根节点时不满足则去掉这个结点重新回溯&#125;面试题 26：复杂链表的复制123456struct ComplexListNode&#123; int val; ComplexListNode* next=NULL; ComplexListNode* sibling=NULL;&#125;解题思路：拆分：1.插入新节点+2.建立sibling连接+3.拆分12345678910111213141516171819202122232425262728293031323334ComplexListNode* cloneComplexListNode(ComplexListNode* head)&#123; //有效性检测 if(head==NULL) return NULL; //1.插入新节点:在每个结点后面新建新节点 ComplexListNode* cur=head; while(cur!=NULL) &#123; ComplexListNode* cloneNode=new ComplexListNode(); cloneNode-&gt;val=cur-&gt;val; cloneNode-&gt;next=cur-&gt;next; cur-&gt;next=clone; cur=clone-&gt;next; &#125; //2.建立sibling连接:将新节点的sibling接到原结点的sibling-&gt;next cur=head; while(cur!=NULL) &#123; ComplexListNode* clone=cur-&gt;next; if(cur-&gt;sibling!=NULL) clone-&gt;sibling=cur-&gt;sibling-&gt;next; cur=clone-&gt;next; &#125; //3.拆分:奇数偶数位置上的结点拆分成两个链表 cur=head; ComplexListNode* cloneHead=head-&gt;next; while(cur-&gt;next!=NULL) &#123; ComplexListNode next=cur-&gt;next; cur-&gt;next=next-&gt;next; cur=next; &#125; return cloneHead;&#125;面试题 27：二叉搜索树与双向链表解题思路：搜索树特点+中序遍历+vector存储1.搜索树特点+中序遍历：结合搜索树特点，根节点的值大于左子树的值小于右子树的值，使用中序遍历刚好遍历的结点符合这个规律2.vector存储：使用vector将中序遍历的节点存储之后再进行相应处理123456789101112131415161718192021222324vector&lt;BinaryTreeNode*&gt; inOrderVector;void inOrderToVector(BinaryTreeNode* root) //1.将前序遍历的节点存储至Vector中&#123; if (root == NULL) return; if (root-&gt;left) inOrderToVector(root-&gt;left); inOrderVector.push_back(root); if (root-&gt;right) inOrderToVector(root-&gt;right); return;&#125;void changeVectorNode(BinaryTreeNode* root) //2.将Vector中的结点进行处理&#123; inOrderToVector(root); int n = inOrderVector.size(); for (int i = 0; i &lt; n; i++) &#123; if (i != 0 &amp;&amp; i != n - 1) &#123; inOrderVector[i]-&gt;left = inOrderVector[i - 1]; inOrderVector[i]-&gt;right = inOrderVector[i + 1]; &#125; else if (i == 0) inOrderVector[i]-&gt;right = inOrderVector[i + 1]; else if (i == n - 1)inOrderVector[i]-&gt;left = inOrderVector[i - 1]; &#125;&#125;面试题 28：字符串的排列解题思路： 面试题 29：数组中出现次数超过一半的数字 解题思路：摩尔投票算法对于大多数投票问题，可以采用摩尔投票算法(Boyer-Moore Majority Vote Algorithm )，使得时间复杂度为 O(n)摩尔投票算法：1.设置变量majority存储多数元素和count存储此元素的投票数2.遍历数组，若count=0，则majority设为当前数组元素，count++3.遍历数组，若count!=0，则比较majority与当前数组元素，若相等则count++，若不相等则count–4.检测：若数组中超过半数的元素值不存在，则majority返回随机一个元素，因此需要检测123456789101112131415161718192021222324int moreThanHalf(int* array,int length)&#123; //有效性检测 if(array==NULL || length&lt;=0) throw new exception(\"input is invalid!\"); //摩尔投票算法 int majority=array[0],count=1; for(int i=1;i&lt;length;i++) &#123; if(count!=0)&#123; if(majority==array[i]) count++; else count--; &#125;else&#123; majority=array[i]; count=1; &#125; &#125; //4.检测 count=0; for(int i=0;i&lt;length;i++) &#123; if(majority==array[i]) count++; &#125; return count&gt;length/2?majority:0;&#125; 面试题 30：最小的K个数 解题思路：快速排序中的分区函数/容器思想1.对输入的n个数排序：排序之后位于最前面的k个数就是最小的k个数，时间复杂度为O(nlongn)2.快速排序中的分区函数：有限制条件，只有允许修改输入数组时可用，基于第k个数来调整，使比k个数字小的所有数字位于数组左边，比k个数字大的数字位于数组右边，这样数字左边的k个数字就是最小的k个数字(乱序)123456789101112131415161718192021222324252627282930313233343536int Partition(int* input,int start,int end) //分区函数&#123; int i=start,j=end,x=input[start]; while(i&lt;j) &#123; while(i&lt;j &amp;&amp; input[j]&gt;=x) j--; if(i&lt;j) input[i++]=input[j]; while(i&lt;j &amp;&amp; input[i]&lt;=x) i++; if(i&lt;j) input[j--]=input[i]; &#125; input[i]=x; return i;&#125;void getLeastNumbers(int* input,int n,int* output,int k)&#123; //有效性检测 if(input==NULL || output==NULL || n&lt;=0 || k&gt;n || k&lt;=0) return; int start=0,end=n-1; int index=Partition(input,start,end); while(index!=k-1) &#123; if(index&gt;k-1) //若得到正确位置的元素位置大于k-1，则需要在其左分区继续找k-1位置 &#123; end=index-1; index=Partition(input,start,end); &#125; else //若得到正确位置的元素位置小于k-1，则需要在其右分区继续找k-1位置 &#123; start=index+1; index=Partition(input,start,end); &#125; &#125; for(int i=0;i&lt;k;i++) output[i]=input[i];&#125;3.容器k：使用大小为k的数据容器存储最小的k个数字，遍历数组。若容器未满时则填入容器若容器满了，则比较容器中最大的数和遍历到的数字，若容器中最大的数小于遍历的数字则继续遍历，若大于则删除这个数字填入遍历的数字这个容器的数据结构可以采用最大堆或者红黑树 面试题 31：连续子数组的最大和 解题思路：举例+动态规划1.举例：我们可以遍历数组，从数组第一个元素开始，分别计算最大子数组的和和累加子数组的和1.1累加子数组的和可以小于最大子数组的和，但若大于最大子数组的和就会刷新最大子数组的和1.2最大子数组的和为遇到的子数组的最大值123456789101112131415int findGreastestSumOfSubArray(int* array,int length)&#123; if(array==NULL || length&lt;=0) throw new exception(\"input is invalid!\"); int curSum=0; //累加子数组初始化为最大负数，不能初始化为0，防止数组全为负数的情况 int greastestSum=0x80000000; for(int i=0;i&lt;length;i++) &#123; if(curSum&lt;=0) curSum=array[i]; //若此时累加子数组的和小于0，则重新初始化 else curSum=curSum+array[i]; //若此时累加子数组的和大于0，则加上当前值 if(curSum&gt;greastestSum) greastestSum=curSum; //刷新最大子数组的和 &#125; return greastestSum;&#125;2.动态规划：针对第i个数字结尾的子数组，当其前面的子数组的数字和小于0时，此时第i个数字结尾的子数组就是第i个数字本身，若前面的子数组所有数字大于0，则与其相加 面试题 32：从1到n整数中1出现的次数 解题思路：参考这里12345678public int NumberOf1Between1AndN_Solution(int n) &#123; int cnt = 0; for (int m = 1; m &lt;= n; m *= 10) &#123; int a = n / m, b = n % m; cnt += (a + 8) / 10 * m + (a % 10 == 1 ? b + 1 : 0); &#125; return cnt;&#125; 面试题 33：把数组排成最小的数 解题思路：比较规则+大数问题(字符串比较)1.比较规则：若给出两个数字x、y，我们需要确定一个规则判断xy和yx哪个大，而不是比较x、y哪个大2.大数问题(字符串比较)：x、y为int，但是xy或者yx可能会溢出，因此这是一个隐形的大数问题，解决方法时将数字转换成字符串，此时比较xy和yx就可以按照字符串大小比较就可以了3.字符串格式化：将格式化的数据写入字符串的函数sprintf(char* str,char* format[,argument])，str为被写入的字符串，format为格式化字符串，argument为被格式化的变量，常用将整数打印到字符串中，如sprintf(s, “%d”, 123); 把整数123打印成一个字符串保存在s中sprintf(s, “%8x”, 4567); 小写16进制，宽度占8个位置，右对齐1234567891011121314151617181920212223242526272829303132333435363738394041//数字最长位数const int MaxNumberLength=10;//自定义比较规则int compare(const void* x,const void* y)&#123; char* xy=new char[MaxNumberLength*2+1]; strcpy(xy,*(const char**)x); // 复制x到xy中 strcat(xy,*(const char**)y); //将y连接到xy后 char* yx=new char[MaxNumberLength*2+1]; strcpy(yx,*(const char**)y); strcat(yx,*(const char**)x); return strcmp(xy,yx); //比较字符串大小 &#125;void printMinNumber(int* numbers,int length)&#123; //输入有效性检测 if(numbers==NULL || length&lt;=0) return; //用于保存字符数组的数组 char** strNumbers=(char**)(new int[length]); //for循环将数字格式化存储至数组中 for(int i=0;i&lt;length;i++) &#123; strNumbers[i]=new char[MaxNumberLength+1]; sprintf(strNumbers[i],\"%d\",numbers[i]); &#125; //对数组中的字符数组用自定义的规则排序 qsort(strNumbers,length,sizeof(char*),compare); //格式化输出并释放空间 for(int i=0;i&lt;length;i++) &#123; cout&lt;&lt;strNumbers[i]; delete[] strNumbers[i]; &#125; delete[] strNumbers;&#125; 面试题 34：丑数 解题思路：空间换时间(创建数组保存已找到的丑数)1.丑数特点：根据定义，丑数应该是另一个丑数乘2、3、5的结果2.创建数组存储已找到的丑数：将数组的丑数排序，每一个丑数是前面的丑数乘以2、3、5得到的3.丑数排序，已有数组的最大丑数设为M，将之前的每个丑数乘2中的大于M的最小值记作M2，乘3乘5的大于M的最小值记作M3、M5，则下一个丑数为M2、M3、M5中的最小值4.优化：并不需要之前的每一个丑数都作乘法，只需要其找到其中的阈值T2，T3，T5，T前的丑数乘对应数字小于M，T后的丑数乘对应数字大于M1234567891011121314151617181920212223242526int getUglyNumber(int n)&#123; if(n&lt;0) return 0; else if(n&lt;=6) return n; //1,2,3,4,5,6均为丑数 int *uglyNumbers=new int[n]; //创建存储丑数的数组 uglyNumbers[0]=1; int curNumber=1; int t2=0,t3=0,t5=0; //阈值下标 while(curNumber&lt;n) &#123; int m2=uglyNumbers[t2]*2; //通过2的阈值下标找到2的阈值 int m3=uglyNumbers[t3]*3; int m5=uglyNumbers[t5]*5; int min=min(m2, min(m3, m5)); uglyNumbers[curNumber]=min; //最小的数存入数组 curNumber++; if(min==m2) t2++; //最小的数属于乘2找到的，则2的阈值下标加1 if(min==m3) t3++; if(min==m5) t5++; &#125; int ugly=uglyNumbers[n-1]; delete[] uglyNumbers; return ugly;&#125; 面试题 35：第一个只出现一次的字符 解题思路：哈希表1.由于题目与字符有关，我们需要统计字符在字符串出现的次数，需要一个数据容器存放每个字符出现的次数，也就是说这个容器的作用是将一个字符映射成一个数字，哈希表正是这个用途2.定义哈希表的键值(Key)为字符，而值(Value)为字符出现的次数3.扫描字符串两次，第一次每扫描到一个字符就在哈希表对应项次数加1，第二次扫描出第一个出现1次的字符4.实现哈希表：字符(char)是一个长度为8的数据类型，因此共有2^8=256种可能，于是可以创建一个长度为256的数组，每个字符根据其ASCII码值作为数组下标对应的数字是其出现的次数5.时间复杂度：若字符串长度为n，第一次扫描的时间复杂度为O(n)，第二次扫描的时间复杂度也是O(n)，于是中的时间复杂度也是O(n)1234567891011121314151617181920212223char firstCharInStr(char* str)&#123; if(str==NULL) return '\\0'; //创建哈希表 const int tableSize=256; unsigned int hashTable[tableSize]; //初始化哈希表 for(unsigned int i=0;i&lt;tableSize;i++) hashTable[i]=0; //第一次遍历，将遍历到的字符以字符的ASCII码作为下标的数组值加1 char* hashKey=str; while(*(hashKey)!='\\0') hashTable[*(hashKey++)] ++; //第二次遍历，找到第一个出现1次的字符 hashKey=str; while(*(hashKey)!='\\0') &#123; if(hashTable[*hashKey]==1) return *hashKey; hashKey++; &#125; return '\\0';&#125; 面试题 36：数组中的逆序对 解题思路：归并排序时统计1.分解数组：将数组分解直至长度为1的子数组2.统计、合并、排序数组：统计数组：申明P1、P2指向两个子数组的头部，P3指向归并数组的头部，只有*P1&gt;*P2时需要统计，逆序数统计数增加子数组P1到末尾的元素数量，因为*P1后的元素均大于*P1，于是均与*P2形成逆序对合并数组：若*P1&gt;*P2，统计完成后*P3=*P2，P2++，P3++，继续比较*P1和*P2；若P1&lt;\\P2，则无需统计，*P3=*P1，P1++，P3++，继续比较*P1和*P2排序数组：合并完成的数组就是已经排序好的数组，排序数组是因为避免在下次的统计过程中重复统计123456789101112131415161718192021222324252627282930313233343536373839404142//不要使用count名，因为std空间下也有count变量会指代不明，若要使用则要用::count形式int cnt=0; int InversePairs(int* array,int length)&#123; //有效性检测 if(array==NULL || length&lt;=0) return 0; //创建辅助空间 int* temp=new int[length]; split(array,0,length-1,temp); delete[] temp; return cnt;&#125;//1.分解数组void split(int* array,int start,int end,int* temp)&#123; if(end-start&lt;1) return; int mid=start+(end-start)/2; //不要用(start+end)/2溢出风险 split(array,start,mid,temp); split(array,mid+1,end,temp); merge(array,start,mid,end,temp);&#125;//2.统计合并排序数组void merge(int* array,int start,int mid,int end,int* temp)&#123; int p1=start,p2=mid+1,p3=start; int k=0; //合并数组 while(p1&lt;=mid &amp;&amp; p2&lt;=end) &#123; //有等于的情况则不能使用这个方法了 if(array[p1]&lt;array[p2]) temp[k++]=array[p1++]; else &#123; cnt=cnt+mid-p1+1; //统计逆序对 temp[k++]=array[p++]; &#125; &#125; while(p1&lt;=mid) temp[k++]=array[p1++]; while(p2&lt;=end) temp[k++]=array[p2++]; //排序数组 for(int i=0;i&lt;k;i++) array[start+i]=temp[i];&#125; 面试题 37：两个链表的第一个公共节点 解题思路：公共结点链表特点+栈1.若两个链表有公共结点，则它们公共结点后的节点是相同的，拓扑结构是Y而不是X2.栈：因为公共结点后的节点是相同的，我们想从尾遍历两个链表，直到遍历到的节点不一样时，其后一个结点就是第一个公共节点，然而链表只能从前往后遍历，因此我们需要使用栈存储两个链表来实现从尾遍历链表3.时间复杂度：若两个链表长度为m、n，则暴力破解时间复杂度为O(mn)，栈遍历为O(m+n)123456789101112131415161718192021static stack&lt;ListNode*&gt; list1,list2;ListNode* findFirstCommonNode(ListNode* head1,ListNode* head2)&#123; ListNode* l1=head1,l2=head2; while(l1!=NULL)&#123; list1.push(l1); l1=l1-&gt;next; &#125; while(l2!=NULL)&#123; list2.push(l2); l2=l2-&gt;next; &#125; ListNode* firstCommonNode=NULL; while(list1.top()==list2.top()) &#123; firstCommonNode=list1.top(); list1.pop(); list2.pop(); &#125; return firstCommonNode;&#125; 面试题 38：数字在排序数组中出现的次数 解题思路：二分查找法1.由于输入数组是排序的，我们很自然想到利用二分查找算法2.寻找数组中第一个数字k和最后一个数字k，它们的下标作简单的处理就能得出数组中有几个k3.找第一个数字k和最后一个数字k可使用二分查找法，第一个k的特点是上一个数字小于k下一个数字等于k，最后一个k的特点是下一个数数字大于k上一个数字等于k4.注意边界检测(k为第一个和最后一个元素)和有效性检测(k不在数组中)1234567891011121314151617181920212223242526272829303132int getNumberOfK(int* array, int length, int k)&#123; //有效性检测 if (array == NULL || length &lt;= 0 || k&lt;array[0] || k&gt;array[length-1]) return 0; int start = 0, end = length - 1; int cur = (start+end)/ 2; //找第一个k 注意边界检测 k为第一个元素 while (cur!=0 &amp;&amp; cur!=length-1) &#123; if (array[cur] == k &amp;&amp; array[cur - 1]&lt;k) break; if (array[cur]&lt;k) start = cur+1; if (array[cur]&gt;=k) end = cur-1; cur = (start + end) / 2; cout &lt;&lt; \"cur1:\" &lt;&lt; cur &lt;&lt; endl; &#125; int startK = cur; start = 0; end = length - 1; cur = (start + end) / 2; //找最后一个k 注意边界检测 k为最后一个元素 while (cur!=0 &amp;&amp; cur!=length-1) &#123; if (array[cur] == k &amp;&amp; array[cur + 1]&gt;k) break; if (array[cur]&lt;=k) start = cur+1; if (array[cur]&gt;k) end = cur-1; cur = (start + end) / 2; cout &lt;&lt; \"cur2:\" &lt;&lt; cur &lt;&lt; endl; &#125; int endK = cur; return endK - startK + 1;&#125; 面试题 39：二叉树的深度 解题思路：递归分治递归分治：：用递归的思想遍历二叉树，用分治的思想理解二叉树某个节点的深度是max(左子树的深度，右子树的深度)+112345int TreeDepth(BinaryTreeNode* root)&#123; if(root==NULL) return 0; return 1+max(TreeDepth(root-&gt;left),TreeDepth(root-&gt;right));&#125; 解题思路：后续遍历后续遍历：我们在遍历某个节点时，已经遍历了它的左右子节点了，这时我们只需要根据它的左右子节点的深度判断这个节点是否平衡，并得到这个节点的深度，对于判断这个节点的父节点是不是平衡的有关键作用123456789101112131415161718192021222324252627282930bool IsBalancedTree(BinaruTreeNode* root)&#123; int depth=0; return IsBalanceNode(root,&amp;depth);&#125;bool IsBalanceNode(BinaruTreeNode* root,int* depth)&#123; //遍历到叶子节点的子节点时，深度设为0，返回叶子节点 if(root==NULL) &#123; *depth=0; return true; &#125; //左子树深度和右子树深度 int left,right; //若左右子树平衡时，会返回左右子树的深度和true if(IsBalanceNode(root-&gt;left,&amp;left) &amp;&amp; IsBalanceNode(root-&gt;right,&amp;right)) &#123; //计算左右子树的深度差 int diff=left-right; //深度差的绝对值在1以内 则平衡，返回这个节点的深度和true if(diff&lt;=1 &amp;&amp; diff&gt;=-1) &#123; *depth=1+(left&gt;right?left:right); return true; &#125; &#125; //若左右子树不平衡或者这个节点不平衡，直接返回false return false;&#125; 面试题 40：数组中只出现一次的数字 解题思路：分治+异或运算分治：先考虑数组中只有一个只出现一次的数字异或运算：x不等于y，则x^y等于1；x等于y，则x^y等于0异或求解思路：将数组的所有元素异或得到的结果为不存在重复的两个元素异或的结果分治思路：两个不相等的元素在位级表示上必定会有一位存在不同，数组异或的结果为两个只出现一次元素异或的结果，只需要找到异或结果中最右侧不为0的位，可利用这一位区分出这两个数(这两个数这一位一定不等),之后将数组分为两个数组，分别求解出每个数组中不同的那个数即可1234567891011121314151617void FindNumOnce(int array[],int length,int* num1,int* num2)&#123; //有效性检测 if(array==NULL || length&lt;2) return; //数组中所有数异或运算，得到只出现一次的两个元素异或的结果 int resultOR=0; for(int i=0;i&lt;length;i++) resultOR=resultOR^array[i]; //找到结果中最右侧不为0的位(即最右侧为1的位) resultOR=resultOR &amp; (-resultOR); //将数组分成两个部分分别进行异或运算 *num1=*num2=0; for(int i=0;i&lt;length;i++) &#123; if((array[i]&amp;resultOR)==0) num1=num1^array[i]; else num2=num2^array[i]; &#125;&#125; 面试题 41：和为S的两个数字/和为S的连续正数序列 解题思路：根据结果修正根据结果修正：由于数组是排序的，因此可以根据两个数字的和与S大小比较调整组成元素的大小具体实现：申明两个指针start、end指向数组头和尾，若指针所指元素的和下于S，则证明需要增大和，则可以start++，因为数组是排序的，所以array[++start]&gt;array[start]，若和小于S，则需要减小和，可以end–，同理因为array[–end]","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://harviealwayshere.github.io/tags/算法/"},{"name":"数据结构","slug":"数据结构","permalink":"https://harviealwayshere.github.io/tags/数据结构/"},{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://harviealwayshere.github.io/tags/剑指Offer/"}]},{"title":"Redis(四)Redis-PHP实战","slug":"redis4","date":"2018-03-06T01:22:31.000Z","updated":"2018-03-07T09:49:11.304Z","comments":true,"path":"2018/03/06/redis4/","link":"","permalink":"https://harviealwayshere.github.io/2018/03/06/redis4/","excerpt":"","text":"使用PHP操作Redis进行简单的项目开发 简单的字符串缓存分别使用set/hSet方法将对象用json_encode解析成json字符串以String/Hash的数据类型存储在Redis缓存中，并用get/hGet取出数据，用json_decode解码后var_dump输出对象1234567891011121314151617181920212223242526272829303132333435363738&lt;?php$redis = new Redis();$redis-&gt;connect(&apos;39.108.210.229&apos;,6379);$strCacheKey = &apos;stringCacheTest&apos;;//SET应用 存储String类型数据//所缓存的对象$arrCacheData = [ &apos;name&apos; =&gt; &apos;harvie&apos;, &apos;sex&apos; =&gt; &apos;male&apos;, &apos;age&apos; =&gt; &apos;22&apos;];//将对象解析成json字符串存储$redis-&gt;set($strCacheKey, json_encode($arrCacheData)); //设置缓存有效期 30S过期失效$redis-&gt;expire($strCacheKey, 30); //从缓存中取出数据 $json_data = $redis-&gt;get($strCacheKey);//将取出的json字符串解码成对象形式$data = json_decode($json_data);var_dump($data);//HSET应用 存储Hash类型数据$hashCacheKey = &apos;hashCacheTest&apos;;//所缓存的由数组组成的对象$arrWebSite = [ &apos;google&apos; =&gt; [ &apos;google.com&apos;, &apos;google.com.hk&apos; ],];//添加一个Value到Hash中$redis-&gt;hSet($hashCacheKey, &apos;google&apos;, json_encode($arrWebSite));$json_data = $redis-&gt;hGet($hashCacheKey, &apos;google&apos;);$data = json_decode($json_data);var_dump($data);在cli运行后输出为 简单队列使用lpush入队，使用lrange查看队列数据，使用rpop出队1234567891011121314151617181920212223242526&lt;?php$redis = new Redis();$redis-&gt;connect(&apos;39.108.210.229&apos;,6379);$strQueueName = &apos;queueName&apos;;//进队列$redis-&gt;lpush($strQueueName, json_encode([&apos;uid&apos; =&gt; 1,&apos;name&apos; =&gt; &apos;harvie&apos;]));$redis-&gt;lpush($strQueueName, json_encode([&apos;uid&apos; =&gt; 2,&apos;name&apos; =&gt; &apos;ryan&apos;]));$redis-&gt;lpush($strQueueName, json_encode([&apos;uid&apos; =&gt; 3,&apos;name&apos; =&gt; &apos;henry&apos;]));echo &quot;---- 进队列成功 ---- &lt;br /&gt;&lt;br /&gt;&quot;;//查看队列$strCount = $redis-&gt;lrange($strQueueName, 0, -1);echo &quot;当前队列数据为： &lt;br /&gt;&quot;;print_r($strCount);//出队列$redis-&gt;rpop($strQueueName);echo &quot;&lt;br /&gt;&lt;br /&gt; ---- 出队列成功 ---- &lt;br /&gt;&lt;br /&gt;&quot;;//查看队列$strCount = $redis-&gt;lrange($strQueueName, 0, -1);echo &quot;当前队列数据为： &lt;br /&gt;&quot;;print_r($strCount);由于linux对中文适配不好，我采用web远程访问，输入如下 订阅发布系统pub.php中使用publish推送给订阅的客户端消息1234567891011&lt;?phpini_set(&apos;default_socket_timeout&apos;, -1); //不超时$redis = new Redis();$redis-&gt;connect(&apos;39.108.210.229&apos;,6379);$strChannel = &apos;HarvieChannel&apos;;//发布 推送给订阅的客户端$redis-&gt;publish($strChannel,&quot;From &quot;.$strChannel.&quot; Channel Msg!&quot;);echo &quot;---- &#123;$strChannel&#125; ---- Channel Msg Push Success ! &lt;br/&gt;&quot;;$redis-&gt;close();sub.php中使用subscribe方法等待订阅频道的推送1234567891011121314151617181920&lt;?phpini_set(&apos;default_socket_timeout&apos;, -1); //不超时$redis = new Redis();$redis-&gt;connect(&apos;39.108.210.229&apos;,6379);$strChannel = &apos;HarvieChannel&apos;;echo &quot;Wait &#123;$strChannel&#125; Msg Push......&quot;;//订阅 使用subscribe方法接受订阅频道的消息$redis-&gt;subscribe([$strChannel], &apos;callBackFun&apos;);function callBackFun($redis, $channel, $msg)&#123; print_r([ &apos;redis&apos; =&gt; $redis, &apos;channel&apos; =&gt; $channel, &apos;msg&apos; =&gt; $msg ]);&#125;运行sub.php客户端，等待消息推送另外再打开一个终端，运行pub.php服务端推送消息此时可以看到sub.php终端中可以接收到服务器推送的消息 计数器使用INCR方法对指定的Key的Value+11234567891011121314151617&lt;?php$redis = new Redis();$redis-&gt;connect(&apos;39.108.210.229&apos;,6379);$strKey = &apos;commentsCount&apos;;//设置初始值$redis-&gt;set($strKey, 0);//使用INCR方法指定Key增加Value$redis-&gt;INCR($strKey); //+1$redis-&gt;INCR($strKey); //+1$redis-&gt;INCR($strKey); //+1$strNowCount = $redis-&gt;get($strKey);echo &quot;Now the num is &#123;$strNowCount&#125;&quot;; 排行榜使用zSet有序集合数据类型实现排行榜的自动排序，ZREVRANGE/ZRANGE方法取特定范围内从大到小/从小到大排序，可指定是否带分数1234567891011121314151617181920212223&lt;?php$redis = new Redis();$redis-&gt;connect(&apos;39.108.210.229&apos;,6379);$strKey = &apos;rankTest&apos;;//zadd向zSet集合添加数据$redis-&gt;zadd($strKey, &apos;50&apos;, json_encode([&apos;name&apos; =&gt; &apos;Tom&apos;]));$redis-&gt;zadd($strKey, &apos;70&apos;, json_encode([&apos;name&apos; =&gt; &apos;John&apos;]));$redis-&gt;zadd($strKey, &apos;90&apos;, json_encode([&apos;name&apos; =&gt; &apos;Jerry&apos;]));$redis-&gt;zadd($strKey, &apos;30&apos;, json_encode([&apos;name&apos; =&gt; &apos;Job&apos;]));$redis-&gt;zadd($strKey, &apos;100&apos;, json_encode([&apos;name&apos; =&gt; &apos;LiMing&apos;]));//ZREVRANGE取特定范围内从大到小排序的数组，最后一个参数为是否带分数显示$dataOne = $redis-&gt;ZREVRANGE($strKey, 0, -1, true);echo &quot;---- &#123;$strKey&#125;由大到小的排序 ---- &lt;br /&gt;&lt;br /&gt;&quot;;print_r($dataOne);//ZRANGE取特定范围内从小到大排序的数组，最后一个参数为是否带分数显示$dataTwo = $redis-&gt;ZRANGE($strKey, 0, -1, true);echo &quot;&lt;br /&gt;&lt;br /&gt;---- &#123;$strKey&#125;由小到大的排序 ---- &lt;br /&gt;&lt;br /&gt;&quot;;print_r($dataTwo); 字符串悲观锁确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性，以及数据库的统一性，乐观锁和悲观锁是并发控制主要采用的技术手段 悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作 实现机制：查询完数据的时候就把事务锁起来，直到提交事务 实现方式：数据库中的锁机制 实现特点：适合强一致场景，效率较低，特别是并发读的效率低 PHP+Redis实现悲观锁：利用redis中的setnx方法的原子性操作，设置一个LockKey，加锁的实质就是向redis中添加一个这个LockKey和过期时间，每次多个并发事务需要访问数据时，均先获取锁(就是用setnx方法设置LockKey字段)，只有首先设置了字段的事务才会得到锁(就是返回Ture)，进行接下来的数据处理操作，没有设置字段的事务就会阻塞直到锁过期或者获取锁的事务释放锁(就是删除LockKey字段)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?php$redis = new Redis();$redis-&gt;connect(&apos;39.108.210.229&apos;,6379);/** * 获取锁 * @param String $key 锁标识 * @param Int $expire 锁过期时间 * @return Boolean */function lock($key = &apos;&apos;, $expire = 5) &#123; //php函数无法调用外部变量 global $redis; //获取锁 $isLock = $redis-&gt;setnx($key, time()+$expire); //不能获取锁 if(!$isLock)&#123; //判断锁是否过期 $lockTime =$redis-&gt;get($key); //锁已过期，删除锁，重新获取 if (time() &gt; $lockTime) &#123; unlock($key); $isLock = $redis-&gt;setnx($key, time() + $expire); &#125; &#125; return $isLock? true : false;&#125;/** * 释放锁 * @param String $key 锁标识 * @return Boolean */function unlock($key = &apos;&apos;)&#123; //php函数无法调用外部变量 global $redis; return $redis-&gt;del($key);&#125;// 定义锁标识$key = &apos;PessimisticLock&apos;;// 获取锁$isLock = lock($key, 10);while(!$isLock)&#123; //获取锁失败 等待锁释放或者超时再获取 echo &apos;wait..&apos;; sleep(1); $isLock = lock($key, 10);&#125;//获取锁成功开始执行事务echo &apos;get lock success&lt;br&gt;&apos;;echo &apos;do sth..&lt;br&gt;&apos;;sleep(5);echo &apos;success&lt;br&gt;&apos;;unlock($key); 模拟测试：我们打开两个终端模拟并发过程，一个终端先获取锁执行事务，另一个终端获取锁失败之后每隔1s再次获取，直到第一个终端执行完事务(5s)释放锁或者锁超时(10s),这个实例里面是执行完事务就释放锁，另一个终端才开始获取到锁执行事务第一个终端获取锁开始执行事务第二个终端获取锁失败开始等待第一个终端执行完成事务释放锁第二个终端获取锁开始执行事务最后完成 字符串乐观锁乐观锁：假定不会发生并发冲突，只在提交操作时检查是否违反数据完整性 实现机制：在修改数据时将事务锁起来，通过version方式进行锁定 实现方式：使用version版本或者时间戳 实现特点：适合多读写少，并发冲突少的场景 PHP+Redis实现乐观锁：利用redis中的watch($Key)方法(watch可以监视一个KEY在事务提交exec()时是否改变，若改变则exec()会失败)，事务使用multi()开启和exec()批量提交 12345678910111213141516171819202122232425262728293031//optimisticLock.php &lt;?php$redis = new Redis();$redis-&gt;connect(&apos;39.108.210.229&apos;,6379);$strKey = &apos;optimisticLcok&apos;; //类似Mysql中的version//设置其version$redis-&gt;set($strKey,10);//watch监视Key$redis-&gt;watch($strKey);$versionNum = $redis-&gt;get($strKey);echo &quot;---- First Version:&#123;$versionNum&#125; ---- &lt;br/&gt;&lt;br/&gt;&quot;;//multi()开启事务$redis-&gt;multi(); $redis-&gt;set(&apos;ID&apos;,5);sleep(5);//第一个事务执行完准备提交时会发现版本号变了 提交失败$redis-&gt;exec();//查看此时版本号 $versionNum = $redis-&gt;get($strKey);echo &quot;---- Current Version:&#123;$versionNum&#125; ---- &lt;br/&gt;&lt;br/&gt;&quot;; //查看执行的事务设置ID是否回滚$id = $redis-&gt;get(&apos;ID&apos;);echo &quot;Set ID is :&quot;.$id.&quot;&lt;br&gt;&quot;;//当exec时候如果监视的key从调用watch后发生过变化，则整个事务会失败 12345678910&lt;?php//changeVersion.php 模拟并发程序$redis = new Redis();$redis-&gt;connect(&apos;39.108.210.229&apos;,6379);$strKey = &apos;optimisticLcok&apos;; //设置其version$redis-&gt;set($strKey,11); 先试试无并发情况直接执行可以看到版本号没改变而且事务执行设置ID成功，我们先删除所有键可以看到ID键已经清空了，然后试试有并发情况，执行事务时另一个并发程序改变了乐观锁(Version)的值可以看到若有并发程序改变了版本号，则事务并不能执行成功，ID键值设置失败了","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"php项目","slug":"php项目","permalink":"https://harviealwayshere.github.io/tags/php项目/"},{"name":"Redis","slug":"Redis","permalink":"https://harviealwayshere.github.io/tags/Redis/"}]},{"title":"WEB信息系统安全（一）概念与内涵","slug":"webSecurity1","date":"2018-03-04T11:58:31.000Z","updated":"2018-03-05T05:21:21.773Z","comments":true,"path":"2018/03/04/webSecurity1/","link":"","permalink":"https://harviealwayshere.github.io/2018/03/04/webSecurity1/","excerpt":"","text":"本系列是陈春华教授所讲授的信息系统安全课程的个人笔记 大纲 信息系统威胁 脆弱性 安全威胁 恶意代码攻击 窃听攻击 黑客攻击 风险损失(3类4性) 信息系统安全概念 基于通信保密(加密) 基于信息系统防护(被动) 基于信息保障(PDR框架/主动) 信息系统安全体系 5类安全服务 8种安全机制 5种普通安全机制 安全服务与安全机制关系 安全管理 信息系统的威胁：风险=脆弱性+威胁信息系统是开发信息资源的工具，是信息和采集、传输、存储、管理、检索、利用信息的工具的有机整体 脆弱性指信息系统本身具有薄弱环节和漏洞，表现在 1.信息属性的脆弱：易复制、易伪 2.系统结构复杂的结构性脆弱：系统功能庞大，结构复杂，安全反而是最薄弱的环节 3.攻防不对称：防御需要周全，攻击只需单点 4.网络的开放和数据库共享的脆弱：网络协议/应用 安全威胁指对于信息系统组成和功能造成某种损害的潜在可能，如对于用户密码的机密性威胁攻击：是安全威胁的具体实现，如窃听密码，主要形式有 1.恶意代码攻击：病毒、特洛伊木马、蠕虫、逻辑炸弹等 2.窃听攻击：声波、电磁波、手机、网络等窃听 3.黑客攻击：网络欺骗、拒绝服务、数据驱动漏洞、陷门等 恶意代码攻击未授权情况下，以破坏软硬件设备、窃取用户信息、干扰用户使用为目的的软件或代码 1.病毒：引起计算机故障，破坏计算机数据的程序代码，具有传染性、潜伏性、寄生性 2.蠕虫：通过网络随机找寻主机的系统漏洞进行高速繁殖自我复制的独立存在的程序代码 3.特洛伊木马：通过提供一些令人感兴趣的功能欺骗用户隐藏其恶意性功能的恶意程序 窃听攻击使用专有技术设备直接秘密窃取侦查目标的语音、图像等信息，有声波、电磁波、光缆、手机、网络窃听形式 黑客攻击 1.网络欺骗漏洞攻击：主要是对于网络协议的漏洞进行欺骗攻击，如针对以太网地址解析协议(ARP)欺骗、IP源欺骗、TCP会话劫持、DNS欺骗、Web欺骗和钓鱼网站 2.拒绝服务攻击：造成目标系统遭到破坏不能提供正常服务，如IP碎片、死亡之ping、UDP泛洪、SYN泛洪、MAC泛洪攻击 3.DDOS与僵尸网络：DOOS(Distributed Denial Of Service)为分布式拒绝服务攻击，僵尸网络(Botnet)指采用一种或多种传播手段将大量主机感染bot程序病毒从而在控制者与主机之间形成一个一对多的控制网络，DDOS是僵尸网络的一种攻击方式 风险损失信息资源损失可分为三类、四性 1.信息泄密：机密性(C,Confidentiality)损失 2.信息破坏：完整性(I,Integrity)、可用性(A,Availability)损失 3.假冒或否认：真实性(Authenticity) 信息系统安全信息系统安全可分为信息安全(内容安全) + 网络安全(网络基础设施安全) 基于通信保密的信息系统安全信息系统安全的基本概念和内涵是信息保密，采用的技术是加密(密码技术) 早期密码技术：替代密码术、换位密码术 计算机时代：密码学、数据加密标准(DES) ####基于信息系统防护的信息系统安全信息系统防护是一种被动防御的思想，目标有系统保护和信息内容保护，可分为两个阶段 1.计算机安全阶段：计算机本身的安全，如软硬件、自然灾害、病毒、数据库中的数据完整性保护 2.计算机网络安全阶段：计算机网络安全影响了信息系统的安全 基于信息保障的信息系统安全PDR(Protection-Detection-Response)：防护-检测-响应框架保障信息安全，检测是一种主动防御的思想，信息系统安全增加了可验证性和不可否认性等属性 信息系统安全体系包括两大部分： 1.安全服务：安全机制提供对付威胁的功能及其配备位置 2.安全机制：安全服务的具体实现 OSI/IEC 7498-2安全标准提出了一个建立在OSI参考模型7层协议上的信息安全体系结构标准，定义了5类安全服务，8种安全机制，5种普通安全机制，确定了安全服务于安全机制的关系，确定了安全管理 5类安全服务 1.鉴别服务：对于通信主体和数据源的鉴别，如网络层-主机地址、传输层-进程地址、应用层-人员账户 2.访问控制服务：防止非授权访问，对于访问主体与资源形成授权机制，对于用户进行访问控制 3.机密性服务：防止数据的非授权泄露，如攻击者难以通过观察业务流推断出敏感信息 4.完整性服务：对抗主动攻击，保护数据在存储、传输等过程中不被非授权修改，以提供真实准确的数据 5.抗抵赖服务：提供证据来证实通信实体的诚实性，如数据原发证明、数据交付证明 8种安全机制 安全机制与安全服务的关系 5种普通安全机制 信息系统的安全标准","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"WEB安全","slug":"WEB安全","permalink":"https://harviealwayshere.github.io/tags/WEB安全/"},{"name":"校园课程","slug":"校园课程","permalink":"https://harviealwayshere.github.io/tags/校园课程/"}]},{"title":"Redis(三)PHP操作Redis","slug":"redis3","date":"2018-03-04T07:49:05.000Z","updated":"2018-03-06T01:23:31.335Z","comments":true,"path":"2018/03/04/redis3/","link":"","permalink":"https://harviealwayshere.github.io/2018/03/04/redis3/","excerpt":"","text":"使用PHP拓展操作Redis 下载安装PHP-Redis拓展1.下载压缩文件包[https://github.com/phpredis/phpredis]2.将文件上传到服务器并解压unzip phpredis-develop.zip若出现-bash: unzip: command not found则需要安装unzip3.进入并phpize处理cd phpredis-developphpize4.指定配置文件若不知道php-config在哪里，可以使用命令查找find / -name “php-config”指定配置文件路径./configure –with-php-config=/usr/bin/php-config5.编译和安装make &amp;&amp; make install成功后会显示6.修改PHP配置文件php.ini添加.so拓展文件查找php.ini文件并进入vi编辑模式类似添加Swoole拓展一样，在底下添加extension = /usr/lib64/php/modules/redis.so7.查看是否安装成功php -m 使用PHP拓展操作Redis简单连接、授权密码、设置字符串、读取字符串测试在服务端运行该脚本可看到 修改redis_6379.conf配置文件将bind语句加上#注释掉在redis3.2后增加了保护模式，在这个模式下也不允许外网访问，需要设置成protected-mode no重启Redis [三个小时踩了一个坑]我用http://39.108.210.229/redis.php 无法访问，于是我在redis.php文件上加上ini_set(‘display_errors’,1);ini_set(‘display_startup_errors’,1);error_reporting(-1);打印出错误信息，发现错误信息为Fatal error: Uncaught Error: Class ‘Redis’ not found in /var/www/html/redis.证明找不到这个类，可是明明已将拓展添加到php.ini中了，于是我在cli下执行php -m可以看到有redis拓展，在web下访问phpinfo()，发现竟然没有redis拓展，难怪找不到Redis类于是我百度了下php -m和phpinfo()不一致，发现可能是cli加载的配置文件和web加载的php配置文件不同，于是在cli下输入which php发现与phpinfo()出现的版本相同，那看来cli下的php和web下的php是相同的，但是为什么拓展不同呢，最后才明白，因为没有重新启动httpd服务器，重新启动后phpinfo()中就有redis拓展了，访问http://39.108.210.229/redis.php 也成功打印出了数据","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"php项目","slug":"php项目","permalink":"https://harviealwayshere.github.io/tags/php项目/"},{"name":"Redis","slug":"Redis","permalink":"https://harviealwayshere.github.io/tags/Redis/"}]},{"title":"Redis(二)客户端操作(cli)","slug":"redis2","date":"2018-03-04T07:48:40.000Z","updated":"2018-03-05T09:34:13.965Z","comments":true,"path":"2018/03/04/redis2/","link":"","permalink":"https://harviealwayshere.github.io/2018/03/04/redis2/","excerpt":"","text":"在命令行通过客户端操作Redis 客户端常用命令ping: 查看服务器是否允许quit: 关闭当前连接auth: 验证密码select: 选择数据库，0-15，共16个，默认使用0flushdb: 删除当前数据库flushall: 删除所有数据库del: 删除键exists: 检查键是否存在 ping/auth测试set/get/select/flushdb/flushall测试del/exists测试 数据类型Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储 1.字符串(String)：最基本的数据类型，Key-Value结构 设置：set key value 获取：get key 2.哈希(Hash)：键值对的集合，适合存储对象 设置：hmset objectName key1 value2 key2 value 2… 获取单个对象所有信息：hgetall objectName 获取单个对象单个信息：hget objectName key 3.列表(List)：按照插入顺序排序，可以添加元素到列表头部（左边）或尾部（右边） 左侧压入数据：lpush key value1 value2… 左侧弹出数据：lpop 右侧压入数据：rpush key value1 value2… 右侧弹出数据：rpop 范围显示：lrange key start stop 显示个数：llen key 4.集合(Set)：string类型的无序集合，集合中元素时唯一的 添加数据：sadd key value1 value2… 显示数据：smembers key 显示总数：scard key 随机移除：spop key [count] 5.有序集合(Zset:SortSet)：每个元素都需要关联一个double类型的分数，redis根据分数为集合中的成员进行排序 添加数据：zadd key score value 显示数据：zrange key start stop 显示总数：zcard key 显示范围：zcount key start stop 显示序号：zrank key member 显示分数：zscore key member","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"php项目","slug":"php项目","permalink":"https://harviealwayshere.github.io/tags/php项目/"},{"name":"Redis","slug":"Redis","permalink":"https://harviealwayshere.github.io/tags/Redis/"}]},{"title":"Redis(一)安装","slug":"redis1","date":"2018-03-04T07:48:12.000Z","updated":"2018-03-05T11:31:30.520Z","comments":true,"path":"2018/03/04/redis1/","link":"","permalink":"https://harviealwayshere.github.io/2018/03/04/redis1/","excerpt":"","text":"Redis是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。 Redis特点： 1.Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。 2.Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。 3.Redis支持数据的备份，即master-slave模式(主从模式)的数据备份。 Redis在Linux下的安装与配置1.安装Redis：1.1下载安装包：在[https://redis.io/download] 中选择你想要的版本下载压缩包并上传到服务器1.2解压：tar -zxvf redis-3.2.11.tar.gz1.3移动：cp -R redis-3.2.11 /usr/local/redis1.4切换到移动后的地址：cd /usr/local/redis/redis-3.2.111.5安装：make install完成后可看到如下可进入目录下的src资源文件夹看到两个服务程序：redis-cli（客户端） redis-server（服务端） 2.配置Redis2.1测试Redis客户端(前台执行)：./redis-server 2.2添加环境变量：可全局执行命令pwd ##查看当前目录，即使需要添加的环境变量的目录vi /etc/profile ##打开环境变量配置文件export PATH=$PATH:/usr/local/redis/redis-3.2.11/src ##在最底下添加这一行source /etc/profile ##立即生效此时切换到别的目录可以看到可以使用redis命令 2.3修改Redis后台启动cd /usr/local/redis/redis-3.2.11其中的redis.conf就是配置文件cp redis.conf redis_6379.conf ##拷贝配置文件vi redis_6379.conf ##编辑新的配置文件将daemonize no =&gt; daemonize yes ##修改成以守护进程(后台)方式运行 2.4修改Redis启动脚本cd /user/local/redis/redis-3.2.11/utils其中的redis_init_script就是启动脚本cp redis_init_script redis_init_script_6379 ##拷贝启动脚本vi redis_init_script_6379 ##编辑新的启动脚本修改服务器路径、客户端路径、配置文件路径如下 2.5测试启动脚本cd /usr/local/redis/redis-3.2.11/utils./redis_init_script_6379 start ##运行启动脚本ps aux | grep redis ##查看进程 查看是否启动Redis服务成功 2.6设置开机启动vi /etc/re.local 添加/usr/local/redis/redis-3.2.11/utils/redis_init_script_6379 start 2.7使用客户端访问（测试是否启动Redis服务成功）redis-cli ##启动客户端连接Redis服务器>pingPONG ##则启动服务成功 2.8客户端连接参数redis-cli连接参数：-h 指定主机 -p 指定端口号 -a 指定密码默认情况下无密码，使用密码有两种方式1.单次生效，通过命令配置 设置密码：config set requirepass 123456 获取密码：config get requirepass 授权使用：auth 123456 2.永久生效，通过修改配置文件 vi redis_6379.conf 取消’requirepass’的注释，加上密码，如requirepass 123456 Tips:无论单次还是永久密码，启动密码后，无密码也可以连接，但无权限进行操作 3.总结3.1启动Redis服务：cd /usr/local/redis/redis-3.2.11/utils./redis_init_script_6379 start3.2停止Redis服务：redis-cli>shutdown3.2客户端连接Redis服务：redis-cli","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"php项目","slug":"php项目","permalink":"https://harviealwayshere.github.io/tags/php项目/"},{"name":"Redis","slug":"Redis","permalink":"https://harviealwayshere.github.io/tags/Redis/"}]},{"title":"数据结构与算法总结（一） 排序","slug":"suanfa1","date":"2018-03-02T09:11:07.000Z","updated":"2018-03-19T10:32:37.214Z","comments":true,"path":"2018/03/02/suanfa1/","link":"","permalink":"https://harviealwayshere.github.io/2018/03/02/suanfa1/","excerpt":"","text":"本文主要用来系统归纳并总结所遇到的算法及其实现方法 大纲 1.冒泡排序 2.插入排序 3.选择排序 4.希尔排序 5.归并排序 6.快速排序 7.堆排序 算法复杂度 1.冒泡排序原始版本：冒泡排序思想(从小到大)： 1.比较相邻的前后两个数据，若前面的数据大于后面的数据，就交换两个数据位置 2.对数组第0个数据到N-1个数据进行一次遍历后，第N-1位置上的就为最大的数据 3.N=N-1，若N!=0则对剩下的数组执行12步，否则排序完成123456789void bubbleSort(int a[],int n)&#123; for(int i=0;i&lt;n;i++) //i表示整体遍历次数，即排好数据的个数 for(int j=1;j&lt;n-i;j++) //j表示每次的比较遍历，每完成一次i就减少j遍历的域一个，因此j只遍历到n-i if(a[j-1]&gt;a[j]) Swap(a[j-1],a[j]); &#125;//Tips：若用j与j+1比较，则内部循环为//for(int j=0;j&lt;n-i-1;j++) // if(a[j]&gt;a[j+1]) Swap(a[j],a[j+1]); 改良1：冒泡排序比较刻板，有时候已经排序好了缺还继续遍历，导致后面的多次遍历都是读取值不交换，浪费了时间，因此我们可以改良一下，设置一个标志，若有一次遍历没有发生交换，则表示排序完成 1.外层循环不再以整体遍历次数作为循环结束条件，而是以是否交换的标志作为循环结束条件 2.控制内层循环还是需要使用i作为整体循环次数，减少遍历已经排好位置的值的多余遍历1234567891011121314151617void bubbleSort(int a[],int n)&#123; bool signal=true; int i=0; //排好数据的个数 while(signal) //1. &#123; signal=false; for(int j=1;j&lt;n-i;j++) //2. if(a[j-1]&gt;a[j]) &#123; Swap(a[j-1],a[j]); signal=true; &#125; i++; //2. &#125; &#125; 改良2：若每次进行遍历时，后面部分的数组已经排好序了且都大于前面的数组，在每次遍历就只需要遍历前面的数组即可，我们可以记录最后交换的位置确定下次循环的范围，下次循环到这个位置即可1234567891011121314151617void bubbleSort(int a[],int n)&#123; int signal=n; //最后交换的位置 int i; //排好数据的个数 while(signal&gt;0) //1. &#123; i=signal; signal=0; //signal初始化为0，因为一开始交换的位置不知道 for(int j=1;j&lt;i;j++) if(a[j-1]&gt;a[j]) &#123; Swap(a[j-1],a[j]); signal=j; //记录最后交换的位置 &#125; &#125; &#125; 2.插入排序基本思想：每次将一个待排序的值插入到已排序的序列中的正确位置，直到全部记录插入完成原始版本：由小到大 1.初始时数组第一个数组成了已排序序列 2.搜索过程：将待排序的值与已排序的序列比较，找到其正确位置 3.数据后移过程：将大于待排序的值的数向后移一个单位，空出位置填入待排序的值123456789101112131415161718192021void insertSort(int a[],int n)&#123; int i,j,k; for(int i=1;i&lt;n;i++) //1.从i=1开始遍历 &#123; for(j=i-1;j&gt;=0;j--) //2.搜索过程 &#123; if(a[j]&lt;a[i]) break; &#125; if(j!=i-1) //若找到合适位置(若j=i-1则这个值已排好序) &#123; int temp=a[i]; for(k=i-1;k&gt;j;k--) //3.数据后移过程 &#123; a[k+1]=a[k]; &#125; a[j+1]=temp; &#125; &#125;&#125; 改良1：原始版本3个for循环太不清晰简洁，将搜索与数据后移过程合并可减少一个循环 1.待排序的值大于已排序序列中的最大值(最后一位)，则无需插入 2.搜索+数据后移：搜索的时候将已排序序列值与待排序的值比较，若大则往后移，直到找到比待排序的值小的值，此时直接插入其后一位即可1234567891011121314151617void insertSort(int a[],int n)&#123; int i,j; for(i=1;i&lt;n;i++) &#123; if(a[i]&lt;a[i-1]) //1.判断是否需要插入排序 &#123; int temp=a[i]; //保存待排序的值 for(j=i-1;j&gt;=0;j--) &#123; if(a[j]&gt;temp) a[j+1]=a[j]; //若已排序序列的值比待排序的值大，则后移 else break; //若已排序序列的值比待排序的值小，则停止循环 &#125; a[j+1]=temp; //直接插入其后一位 &#125; &#125;&#125; 3.选择排序基本思想：与插入排序类似，都将数据分为有序区和无序区，不同的是，插入排序是将无序区第一个元素直接插入有序区形成更大的有序区，选择排序是从无序区选择最小(大)的元素放入有序区的最后原始版本： 1.无序区最大数的下标初始化为有序区的最大数下标，便于写循环函数，若初始化为无序区第一个数下标，则循环从无序区第二个数开始 2.交换函数最好使用中间变量，因为有可能自己与自己交换,不使用中间变量需判断12345678910111213141516171819202122232425262728void selectSort(int a[],int n)&#123; int i,j,maxIndex; for(i=0;i&lt;n;i++) &#123; maxIndex=i; //1. for(j=i+1;j&lt;n;j++) &#123; if(a[j]&gt;a[maxIndex]) maxIndex=j; &#125; Swap(a[i],a[maxIndex]); &#125;&#125;void Swap(int &amp;a,int &amp;b) //2.使用中间变量无需判断&#123; int c=a; a=b; b=c;&#125;void Swap(int $a,int &amp;b) //2.不使用中间变量需判断&#123; if (a != b) &#123; a ^= b; b ^= a; a ^= b; &#125; &#125; 4.希尔排序基本思想：实质是分组插入排序，先将待排序元素分割成若干个子序列(相隔某个增量)，分别进行插入排序，然后依次缩小增量再进行排序，最后对全体元素进行插入排序，由于此时序列的有序程度已经很高了，因此效率较高原始版本： 1.计算步长：通常是数组长度/2 2.确定分组个数：从0到一个步长的元素个数为分组个数，这些元素都是分组中的第一个元素 3.每个分组进行插入排序(两个for循环)123456789101112131415161718192021222324void shellSort(int a[],int n)&#123; int i,j,gap,k; for(gap=n/2;gap&gt;0;gap=gap/2) //1.计算步长 &#123; for(i=0;i&lt;gap;i++) //2.确定分组个数 &#123; for(j=i+gap;j&lt;n;j=j+gap) //3.每个分组进行插入排序 &#123; if(a[j]&lt;a[j-gap]) &#123; int temp=a[j]; for(k=j-gap;k&gt;=0;k=k-gap) &#123; if(a[k]&gt;temp) a[k+gap]=a[k]; else break; &#125; a[k+gap]=temp; &#125; &#125; &#125; &#125;&#125; 5.归并排序归并排序是基于分治法，基本思想是归：将数组一直拆分，直到拆分成一个数据的时候，可以认为这个子数组为有序的并：若两个子数组均有序，按顺序合并成一个数组就是有序的原始版本： 1.合并函数：设定两个指针指向两个已排序数组的起始位置，比较指针所指元素，选择小的元素放入合并空间中并移动指针到下一个位置，若某一指针超出自身子数组的序列范围，则将另一子数组剩下所有元素赋值到合并序列中，最后将合并序列的元素覆盖原先数组元素的位置 2.分解函数：将传入的数组分解成两个数组，之后继续分解分解出来的两个子数组，直到分解出来的数组中仅有一个元素则可认为有序，之后调用合并函数合并子数组 3.归并排序：先申请空间，用来存放合并序列，调用分解函数后释放空间123456789101112131415161718192021222324252627282930313233343536373839void mergeArray(int a[],int start,int mid,int end,int temp[]) //1.合并函数&#123; int i=start,j=mid+1; //两个子数组的头元素 int m=mid,n=end; //两个子数组的尾元素 int k=0; //temp数组所赋值的位置 while(i&lt;=m&amp;&amp;j&lt;=n) &#123; if(a[i]&lt;a[j]) temp[k++]=a[i++]; else temp[k++]=a[j++]; &#125; while(i&lt;=m) temp[k++]=a[i++]; while(j&lt;=n) temp[k++]=a[j++]; for(i=0;i&lt;k;i++) &#123; a[start+i]=temp[i]; &#125;&#125;void splitArray(int a[],int start,int end,int temp[]) //2.分解函数&#123; if(start&lt;end) &#123; int mid=(start+end)/2; splitArray(a,start,mid,temp); splitArray(a,mid+1,end,temp); mergeArray(a,start,mid,end,temp); &#125;&#125;bool mergeSort(int a[],int n) //3.归并排序&#123; int *p = new int[n]; if(p==NULL) return false; splitArray(a,0,n-1,p); delete[] p; return true;&#125; 6.快速排序快速排序基于分治法剑指offer上给出的是分区(Partition)方法是 1.随机找基准值 2.将基准值移至数组尾部 3.从数组头部开始遍历数组，找到一个小于基准值的数就将其移到数组前方 4.将基准值移到最后一个小于基准值的数的下一个位置上 5.返回基准值位置 之后便是快速排序(QuickSort)： 1.若传入数组为一个数，则表示排序完成 2.否则调用分区(Partition)函数 3.分区完成后，对于左分区(小于基准值)右分区(大于基准值)再递归调用快速排序(QuickSort)方法，直到排序完成1234567891011121314151617181920212223242526272829303132333435363738//分区(Partition)int Partition(int data[], int length, int start, int end)//分区&#123; if(data==NULL || length&lt;=0 || start&lt;0 || end&gt;=length) //输入参数有效行检验 throw new std::exception(&quot;Invalid Parameters&quot;); int index = RandomInRange(start,end); //1.随机找基准值 Swap(&amp;data[index], &amp;data[end]); //2.将基准值移至数组尾部 int small = start-1; //small位置表示小于基准数的值要填入的位置 //3.从数组头部开始遍历数组，找到一个小于基准值的数就将其移到数组前方 for(index=start; index&lt;end; index++) &#123; if(data[index]&lt;data[end]) //如果找到一个小于基准数的值 &#123; small++; //先small++找到应该放入数组的位置 if(small!=index) Swap(&amp;data[index], &amp;data[small]); //若small位置等于index位置，证明index位置的值是处于正确位置上不需要交换 //否则证明index位置上的值小于基准数还不处于应该填入的位置上，需要交换到small位置上 &#125; &#125; small++; Swap(&amp;data[small], &amp;data[end]); //4.将基准值移到最后一个小于基准值的数的下一个位置上 return small; //5.返回基准值位置，此时small左边为小于基准数的值，small右边为大于基准数的值&#125;//快速排序(QuickSort)void QuickSort(int data[],int length,int,start,int end)&#123; if(start==end) return; //1.若传入数组为一个数，则表示排序完成 int index=Partition(data,length,start,end); //2.否则调用分区(Partition)函数 3.分区完成后，对于左分区(小于基准值)右分区(大于基准值)再递归调用快速排序(QuickSort)方法，直到排序完成 if(index&gt;start) QuickSort(data,length,start,index-1); if(index&lt;end) QuickSort(data,length,index+1,end);&#125; MoreWindows博客大大提出了另一种实现方法，较为简洁，与剑指Offer提出的实现方法相比，有如下改动 1.直接选取第一个数作为基准数(也可以随机选择) 2.有前后指针同时遍历数组，而不是单一从前往后遍历 3.采用挖坑填数思想：将基准数保存，之后尾指针遍历，若是所指向的值比基准数小则填入头指针所指向的位置，之后头指针遍历，若是所指向的值比基准数大则填入尾指针所指向的位置，直到头指针与尾指针指向同一个位置，在这个位置填入基准数即可123456789101112131415161718192021222324//快速排序 void quick_sort(int s[], int l, int r) //l为头指针，r为尾指针&#123; if (l &lt; r) //递归停止条件：若l=r即为数组只有一个元素时则停止递归 &#123; //Swap(s[l], s[RandomInRange(l,r)]); //1.直接选取第一个数作为基准数(也可以随机选择) int i = l, j = r, x = s[l]; //将基准数保存在x里面，i为头指针，j为尾指针 while (i &lt; j) &#123; while(i &lt; j &amp;&amp; s[j] &gt;= x) // 从尾向头找第一个小于基准数的数 j--; if(i &lt; j) // 填入头指针所指向的位置并头指针指向下一个位置 s[i++] = s[j]; while(i &lt; j &amp;&amp; s[i] &lt; x) // 从头向尾找第一个大于等于x的数 i++; if(i &lt; j) // 填入尾指针所指向的位置并尾指针指向下一个位置 s[j--] = s[i]; &#125; s[i] = x; //将基准数填入头尾指针所指向的位置 quick_sort(s, l, i - 1); // 将左分区递归调用排序 quick_sort(s, i + 1, r); // 将右分区递归调用排序 &#125; &#125; Python实现更加简单，因为python在分治中很容易找到比基准值大或者小的数并放在一个数组里，而且Python合并数组也十分简单123456789//Python实现快速排序def quicksort(array): if(len(array)&lt;2): return array else: pivot=array[0] less=[i for i in array[1:] if i &lt;= pivot] greater=[i for i in array[1:] if i&gt; pivot] return quicksort(less)+[pivot]+quicksort(greater) 7.堆排序二叉堆：是完全二叉树或者近似完全二叉树，满足两个特点 1.父节点的键值总是大于(小于或者等于)任何一个子节点的键值，是一个最大堆(最小堆) 2.每个节点的左子树和右子树都是一个二叉堆 堆的存储：从上到下、从左到右遍历堆存储，一般用数组存储，这样节点有这样的规律：对于i节点：其父节点下标为(i-1)/2，其左右子节点为2*i+1和2\\i+2插入堆：总是将插入的数据放在数组最后，可通过将其与父节点比较调整位置，从而让数组满足堆的条件1234567891011121314151617void insertHeap(int a[],int n,int newData)&#123; a[n]=newData; //将插入的数据放在数组最后 int j=n; //子节点下标 int i=(j-1)/2; //父节点下标 while(i &gt;=0 &amp;&amp; j !=0) &#123; //若父节点的值大于子节点，则交换并继续比较新的父节点与子节点(最小堆) if(a[i]&gt;a[j]) &#123; Swap(a[i],a[j]); j=i; //交换后的父节点变新的子节点 i=(j-1)/2 //新的子节点的父节点 &#125; else break; //若父节点的值小于等于子节点，则停止交换 &#125;&#125;删除堆：按照定义每次只能删除第0个数据，为了便于重建堆，实际是将最后一个数据的值赋给根节点，再将根节点与其子节点比较调整位置，从而让数组满足堆的条件123456789101112131415161718void deleteHeap(int a[],int n)&#123; Swap(a[0],a[n-1]); //最后一个数据的值赋给头节点，此时尾节点下标为n-2 int i=0; //父节点下标 int j=2*i+1; //左子树节点 while(j&lt;=n-2) &#123; if(j+1&lt;=n-2 &amp;&amp; a[j+1]&lt;a[j]) j++; //在左右子树节点找到最小的 //若父节点的值大于子节点，则交换并继续比较新的父节点与子节点(最小堆) if(a[i]&gt;a[j]) &#123; Swap(a[i],a[j]); i=j; //交换后的子节点变为新的父节点 j=2*i+1; //新的父节点的子节点 &#125; else break; //若父节点的值小于等于子节点，则停止交换 &#125;&#125;堆化数组：只要将非叶子节点从下往上从右往左遍历，进行下沉调整即可下沉函数：类似于删除堆中的操作，即父节点其子节点比较调整位置，从而让数组满足堆的条件123456789101112131415161718192021222324//下沉函数void sink(int a[],int i,int n) //参数：数组，需要调整的父节点，数组长度&#123; int j=2*i+1; while(j&lt;=n-1) &#123; if(j+1&lt;=n-1 &amp;&amp; a[j+1]&lt;a[j]) j++; if(a[i]&gt;a[j]) &#123; Swap(a[i],a[j]); i=j; j=2*i+1; &#125; else break; &#125;&#125;//建立最小堆void makeHeap(int a[],int n)&#123; for(int i=n/2-1;i&gt;=0;i--) &#123; sink(a,i,n); &#125;&#125;堆排序：建立好的最小堆中第0个数据时堆中最小的数据，取出这个数据再执行下堆的删除，这样堆中第0个数据又是最小的数据，重复上述步骤直到堆中只有一个数据就直接取出，则取出的数据就是有序序列了12345678void heapSort(int a[],int n)&#123; for(int i=n-1;i&gt;0;i--) &#123; makeHeap(a,i+1); deleteHeap(a,i+1); &#125;&#125;","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://harviealwayshere.github.io/tags/算法/"},{"name":"数据结构","slug":"数据结构","permalink":"https://harviealwayshere.github.io/tags/数据结构/"}]},{"title":"剑指Offer基础知识(二)算法","slug":"offer2","date":"2018-03-02T09:06:07.000Z","updated":"2018-03-10T02:59:44.186Z","comments":true,"path":"2018/03/02/offer2/","link":"","permalink":"https://harviealwayshere.github.io/2018/03/02/offer2/","excerpt":"","text":"本文主要记录阅读剑指Offer这本书所遇到的算法解释并作一些个人的拓展，其中的算法面试题请看剑指Offer面试题集 第二章2.4 算法和数据操作排序和查找是面试时考查算法的重点，如二分查找、归并排序、快速排序等。递归和循环是两种算法实现的方式，基于递归的实现较整洁但性能不如基于循环实现的方法，我们应该根据题目特点来选择使用哪种实现方式。位运算可以看做一类特殊的算法，共有与、或、异或、左移和右移五种位运算 2.4.1 查找和排序查找不外乎：顺序查找、二分查找、哈希表查找和二叉排序树查找，无论用递归还是循环都需要掌握这些查找方法的实现。排序则复杂一些：插入排序、冒泡排序、归并排序、快速排序等不同算法的优劣，能够从额外空间消耗、平均时间复杂度和最差时间复杂度等方面去比较它们的优缺点。值得一提的是，快速排序的实现代码是面试官钟爱的。快速排序思路:选择一个数字(有多种选择法)，接下来把数组中的数字分成两部分，比选择的数字小的数字移到数组的左边，比选择数字大的数字移到数组右边接下来看一个年龄排序问题若对员工年龄排序，数字大小在一个较小范围内，可以使用辅助内存思路：由于员工年龄有一个范围，则可以使用有限数组作为辅助空间换取排序效率，用timesOfAge数组统计每个年龄出现次数，用ages数组设置年龄排序12345678910111213141516171819202122232425262728void sortAges(int age[],int length)&#123; //1.有效性检测 if(age==NULL || length&lt;=0) return; //2.设置timesOfAge数组，下标为年龄，值为在该年龄的人数 int oldestAge = 99; int timesOfAge[oldestAge+1]; for(int i=0;i&lt;=oldestAge;i++) timesOfAge[i] =0; //初始化 for(int i=0;i&lt;length;i++) &#123; int age = age[i]; if(age&lt;0 || age &gt;99) throw new std:exception(&quot;age out of range.&quot;); else timesOfAge[age]++; &#125; //3.重新设置age数组，将年龄重排 int ageIndex = 0; for(int i=0;i&lt;=oldestAge;i++) //i为年龄 &#123; for(int j=0;j&lt;timesOfAge[i];j++) //j为i年龄的人数 &#123; age[ageIndex]=i; ageIndex++; &#125; &#125;&#125; 2.4.2 递归和循环多次重复计算，可以使用递归和循环。递归：在函数内部调用函数自身直到递归停止return循环：设置计算初始值和终止条件如计算1+2+3….n，我们可以使用递归或者循环求出结果12345678910111213141516//递归int Add(int n)&#123; if(n&gt;=0) return n+Add(n-1); else return 0;&#125;//循环int add(int n)&#123; int sum=0; for(int i=0;i&lt;=n;i++) &#123; sum += i; &#125; return sum;&#125;递归与循环的选择： 1.递归简洁，若面试官无特殊要求，可以优先采用递归 2.循环高效，递归是函数调用，需要时间和空间的消耗，需要在内存栈分配空间保存参数，另外递归可能存在重复计算 3.递归有严重问题：调用栈溢出，栈容量是有限的，不可能无限调用，溢出则会出错 2.4.3 位运算位运算是将数字用二进制表示之后对每一位上的0/1进行运算二进制就是指数字的每一位都是0/1，其他进制如表示时间分秒的六十进制，针对进制，有许多面试题，如在Excel 2003中，A表示1列，B表示2列…Z表示26列，AA表示27列，AB表示28列，请写出一个函数，输入字母，输出第几列思路：这题本质上是10进制转26机制用A-Z表示，输入字母，如ABC，首先分解成A/B/C，A-1，B-2，C-3，则数字为26^2 *1 + 26^1 *2 + 26^0 *3 = 676 * 1+26 * 2+1 * 3=731","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://harviealwayshere.github.io/tags/算法/"},{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://harviealwayshere.github.io/tags/剑指Offer/"}]},{"title":"JS（四）JS常用对象","slug":"js4","date":"2018-02-27T07:21:19.000Z","updated":"2018-03-01T14:30:28.224Z","comments":true,"path":"2018/02/27/js4/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/27/js4/","excerpt":"","text":"JavaScript 中的所有事物都是对象：字符串、数值、数组、函数… JS对象基本概念JS对象由花括号分隔，对象属性以名称和值对的形式(name:value)来定义，对象属性由逗号分隔JS提供多个内建对象，如String、Date、Array等，对象是一种特殊的数据类型拥有属性和方法对象属性：是与对象有关的值，可用object.att或者object[“att”]访问，如var message=”hello world”;var length=message.length;对象方法：是能够在对象上执行的动作，可用objectName.methodName()访问，如var message=”hello world”;var upperMsg=message.toUpperCase(); JS对象创建JS创建对象有种方式 字面量创建使用{ }包围1var Person=&#123;firstName:&quot;John&quot;, lastName:&quot;Doe&quot;, id:5566&#125;; Object创建1234var Person=new Object();Person.firstName:&quot;John&quot;;Person.lastName:&quot;Doe&quot;;Person.id:5566; 工厂模式创建12345678910function createPerson(firstName,lastName,id)&#123; var obj=new Object(); obj.firstName=firstName; obj.lastName=lastName; obj.id=id; return obj;&#125;var Person1=createPerson(&quot;John&quot;,&quot;Doe&quot;,5566);var Person2=createPerson(&quot;Arvin&quot;,&quot;Harvie&quot;,7788); 构造函数创建12345678function Person(firstName,lastName,id)&#123; this.firstName=firstName; this.lastName=lastName; this.id=id;&#125;var Person1=new Person(&quot;John&quot;,&quot;Doe&quot;,5566);var Person2=new Person(&quot;Arvin&quot;,&quot;Harvie&quot;,7788); 原型创建对象123456789function Person()&#123;&#125;Person.prototype.firstName=&quot;John&quot;;Person.prototype.lastName=&quot;Doe&quot;;Person.prototype.id=5566;var person1=new Person();var person2=new Person();person2.firstName=&quot;Arvin&quot;;person2.lastName=&quot;Harvie&quot;;person2.id=7788; 组合构造函数和原型创建对象1234567891011function Person(firstName,lastName,id)&#123; this.firstName =firstName; this.lastName = lastName; this.id = id;&#125;Person.prototype = &#123; constructor:Person, showId: function()&#123; alert(this.id); &#125;;&#125; 总结：第1/2种字面量和Object构建对象，对于简单属性的对象而言十分简单明了，但是它们都是用了同一个接口创建很多对象，会产生大量的重复代码，就是如果你有100个对象，那你要输入100次很多相同的代码第3种工厂模式创建对象，将创建对象过程封装在函数体内，通过函数调用生成对象，但是无论哪个对象的生成函数返回的都是一个对象，我们无法判断返回的对象是哪个类型第4种构造函数创建对象，没有显式创造对象，没有return语句，而且可以识别对象类型，使用instanceof操作符进行检测(person insanceof Person);但是若对象中含有方法，则每个方法都要在实例中创建一遍，然而每个对象的方法应该是相同的才对，若是方法的数量很多，就会占用很多不必要的内存第5中原型创建对象，可以让所有对象实例共享它所包含的属性和方法，若为对象实例添加一个属性，这个属性会覆盖原型对象中的属性，但是这样子每个对象实例的属性一般都是不同的，创建起来就很复杂第6中原型和构造函数结合创建对象，是最好的，构造函数用于定义实例属性使每个对象实例有自己的属性，原型模式用于定义方法和共享的属性使每个对象相同的方法和属性共用同一片内存，节省空间 JS遍历对象可以使用for…in…循环遍历对象属性，语法：for (name in object){ text=text+name+”=&gt;”+object[name]+”\\n”;} JS Number对象JS中的数字可以使用小数点，也可以不使用小数点，如var x=314;var y=3.14;JS中数字均为浮点型，采用IEEE754标准定义的64位浮点格式表示JS中八进制前缀为0，十六进制前缀为0x，可以使用Number.toString(8/16/2)转换进制JS中的数字运算超出了数字上限，则以Infinity表示JS中的数字运算发生错误产生了非数字值，则以NaN表示，可以用isNaN()Number对象属性**： object.constructor：返回创建此对象的函数引用 Number.MAX_VALUE：返回Number可表示的最大的数 Number.MIN_VALUE：返回Number可表示的最小的数 Number.NaN：返回NaN Number对象方法： NumberObject.toString(radix=10)：将Number对象转换为radix进制的字符串 NumberObject.toLocaleString()：将Number对象转换为本地格式的字符串 NumberObject.toFixed(num=0)：将Number四舍五入为num(0-20)小数位数的数字 NumberObject.toExponential(num)：将Number转换成num(0-20)小数位的指数计数 NumberObject.valueOf()：返回Number对象的值的字符串 JS String对象String对象属性： object.constructor：返回创建此对象的函数引用 stringObject.length：返回字符串中字符数目 String对象方法： stringObject.indexOf(searchvalue,fromindex)：返回searchvalue在stringObject中首次出现的位置，fromindex为开始检索的位置(可选)，方法大小写敏感且无检索结果返回-1 stringObject.match(searchvalue/regexp)：返回stringObject中匹配searchvalue的字符串或者匹配regexp正则表达式的字符串，若regexp具有标志g则为多次匹配返回所有匹配字符串的数组 stringObject.replace(regexp/substr,replacement)：返回用replacement替换了regexp/substr匹配的字符串的新字符串 stringObject.toLocaleUpperCase()/toLocaleLowerCase()：返回大写/小写字符串 stringObject.split(separator,howmany)：返回以separator字符串或正则表达式分割的howmany个数的字符串数组，若用””分割则每个字符都会分割 更多对象方法可查看这里 JS Date对象new Date();会自动把当前日期和时间保存为其初始值，可调用对象方法更改Date对象属性Date对象方法： dateObject.getFullYear()/getMonth()/getDate()/getDay()：返回年份/月份(0-11)/日期/星期(0-6) dateObject.getHours()/getMinutes()/getSeconds()：返回小时(0-23)/分钟(0-59)/秒数(0-59) dateObject.getTime()：返回距 1970 年 1 月 1 日之间的毫秒数 dateObject.setFullYear(year,month,day)/setMonth(month,day)/setDate(day)：设置年份/月份/日期 dateObject.toUTCString()/toString()/toDateString()/toTimeString()：将日期转换为UTC世界时/本地时间/日期部分本地时间/时间部分本地时间的字符串 在页面上显示时钟(Date+onload事件)123456789101112131415161718192021&lt;script&gt;function startTime()&#123; var today=new Date(); var h=today.getHours(); var m=today.getMinutes(); var s=today.getSeconds();// 在小于10的数字前加一个‘0’ m=checkTime(m); s=checkTime(s); document.getElementById(&apos;block&apos;).innerHTML=h+&quot;:&quot;+m+&quot;:&quot;+s; t=setTimeout(function()&#123;startTime()&#125;,500);&#125;function checkTime(i)&#123; if (i&lt;10)&#123; i=&quot;0&quot; + i; &#125; return i;&#125;&lt;/script&gt;&lt;body onload=&quot;startTime()&quot;&gt; &lt;div id=&quot;block&quot;&gt;&lt;/div&gt; JS Array对象JS数组可以有三种声明赋值方式 创建数组再一一赋值:1234var cars=new Array();cars[0]=&quot;Saab&quot;;cars[1]=&quot;Volvo&quot;;cars[2]=&quot;BMW&quot;; 创建时就赋值(Condensed Array):使用( )包围1var cars=new Array(&quot;Saab&quot;,&quot;Volvo&quot;,&quot;BMW&quot;); 不创建直接赋值(Literal Array):使用[ ]包围1var cars=[&quot;Saab&quot;,&quot;Volvo&quot;,&quot;BMW&quot;]; 总结：1/2方式在于先创建一个空的多维数组，之后可使用for循环根据需求赋值，3对于枚举数据比较简单易用由于JS的弱检查特性，因此在JS数组中可以同时存储不同类型的变量，比如你可以把数字、字符串、字符、对象等内容放在同一个数组中。 Array对象属性： arrayObject.length：返回数组中元素数目 Array对象方法： arrayObject.concat(arrayX,arrayX,……,arrayX)：连接两个或多个数组，不会改变现有数组而是产生一个新的连接结果数组 arrayObject.join(separator)：把arrayObject中所有元素放入一个字符串以separator分割，默认以，分割 arrayObject.pop()：删除数组最后一个元素并返回元素的值，若数组为空则返回undefined arrayObject.push(newelement1,newelement2,….,newelementX)：向数组末尾增加一个或多个元素并返回新的数组长度 arrayObject.reverse()：将arrayObject数组元素颠倒顺序，会改变原数组 arrayObject.shift()：删除并返回第一个数组元素并返回元素的值，若为空则返回undefined arrayObject.slice(start,end)：返回arrayObject数组中下标从start到end的子数组，不改变原数组，可用负值表示从尾部选取元素 arrayObject.sort(sortby)：以sortby函数对数组排序，若无排序函数则以字符编码的顺序进行排序，排序函数有两个参数ab，若a在b前则返回小于0，a在b后则返回大于0 arrayObject.splice(index,howmany,item1,…..,itemX)：若howmany=0，则向数组中从index开始添加item1,…..,itemX个元素，若howmany&gt;0，则会删除从index开始后howmany个元素并以item1,…..,itemX代替，返回删除的元素数组，会改变原数组 arrayObject.toString()：返回，分割数组元素的字符串 arrayObject.unshift(newelement1,newelement2,….,newelementX)：向数组开头添加一个或多个元素并返回新的长度 JS Math对象Math对象无需创建可静态使用Math对象属性：Math.E(自然底数)/.LN2/.LN10(2/10的自然对数)/.LOG2E/.LOG10E(以2/10为底的e的对数)/.PI(圆周率)/.SQRT1_2/.SQRT2(返回2的平方根的倒数/返回2的平方根)Math对象方法：几乎所有的算数运算都有，详情见这里Math.round(x)：返回x最接近的整数Math.random()：返回0.0-1.0之间的伪随机数 JS RegExp对象RegExp 对象表示正则表达式，直接量语法：/pattern/attributes，创建RegExp对象的语法：new RegExp(pattern, attributes); 参数pattern是一个字符串，指定了正则表达式的模式或其他正则表达式。 参数attributes是一个可选的字符串，包含属性 “g”、”i” 和 “m”，分别用于指定全局匹配、区分大小写的匹配和多行匹配。Tips：pattern是正则表达式，而不是字符串，则必须省略该参数attributes。具体使用可查阅这里","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://harviealwayshere.github.io/tags/JavaScript/"},{"name":"Web前端","slug":"Web前端","permalink":"https://harviealwayshere.github.io/tags/Web前端/"}]},{"title":"JS（三）HTML DOM对象","slug":"js3","date":"2018-02-26T07:49:29.000Z","updated":"2018-02-27T07:57:58.195Z","comments":true,"path":"2018/02/26/js3/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/26/js3/","excerpt":"","text":"JS中若要动态改变页面信息和与用户交互，几乎都要使用HTML DOM对象 HTML DOM对象通过DOM，JS可以创建动态的HTML，如 改变页面中所有HTML元素(改变内容属性等) 改变页面中所有CSS样式 对页面中所有HTML DOM事件作出响应 对页面中所有HTML元素添加删除 JS HTML DOM-查找HTML元素1.使用元素Id(最常用)：document.getElementById(id)2.使用标签名TagName：document.getElementsByTagName(tagName)3.使用类名CalssName：document.getElementsByClassName(className) JS HTML DOM-改变HTML改变HTML输出流：document.write()用于直接向HTML输出流写内容改变HTML内容：通过改变HTML元素的innerHTML属性1document.getElementById(id).innerHTML=newHTML;改变HTML属性：通过改变HTML元素的attribute属性1document.getElementById(id).attribute=newValue; JS HTML DOM-改变CSS改变HTML样式：通过改变HTML元素的style子属性12345//document.getElementById(id).style.property=newValue;document.getElementById(&quot;p1&quot;).style.color=&quot;blue&quot;;document.getElementById(&quot;p1&quot;).style.visibility=&quot;hidden&quot;; //元素隐藏document.getElementById(&quot;p1&quot;).style.visibility=&quot;visible&quot;; //元素显示改变 JS HTML DOM-事件响应我们可以在事件发生时执行JavaScript，如用户点击、移动鼠标、提交HTML表单等。为HTML事件属性添加JS代码：onEvent=JSCodeonEvent(HTML事件属性)： onload/onunload事件：在用户进入或离开页面时被触发，可用于检测访问者浏览器类型和版本用于加载网页的正确版本，可用于处理cookie onchange事件：在用户改变输入字段（文本框的文本，选择框的选项等）被触发，可用于对输入字段的验证检测 onmouseover/onmouseout事件：用户鼠标进入或离开HTML元素时触发 onmousedown/onmouseup/onclick事件：用户点击鼠标/释放鼠标/完成点击HTML元素时被触发 onfocus事件：输入字段获得焦点时被触发更多DOM对象事件可查看这里 JSCode：可以直接JS代码，也可以是JS函数，参数可传递(this) JS HTML DOM-EventListener监听事件addEventListener()用于向指定HTML元素添加事件句柄，新添加的事件句柄不会覆盖已存在的事件句柄，可向一个元素添加多个无论是否是同类型的时间句柄语法：element.addEventListener(event, function, useCapture);event：事件类型，如”click”/“mousedown”，不使用on前缀function：事件触发的回调函数useCapture：布尔值，描述事件是冒泡还是捕获，可选参数 removeEventListener()：用于移除事件的监听语法：element.removeEventListener(event, function);event：移除的事件类型function：移除的回调函数 JS HTML DOM-添加删除HTML元素创建HTML元素：创建该元素（元素节点），然后向一个已存在的元素追加该元素，如12345var element=document.getElementById(&quot;div1&quot;); //找到已存在的元素var para=document.createElement(&quot;p&quot;); //创建新元素var node=document.createTextNode(&quot;这是一个新段落。&quot;); //创建文本节点para.appendChild(node); //为新元素添加文本节点element.appendChild(para); //向已存在的元素添加新元素节点删除HTML元素：找到需要删除的元素和它的父元素才能删除该元素，如123var child=document.getElementById(&quot;p1&quot;); //找到需要删除的元素var parent=document.getElementById(&quot;div1&quot;); //找到需要删除的元素的父元素parent.removeChild(child); //删除元素","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://harviealwayshere.github.io/tags/JavaScript/"},{"name":"Web前端","slug":"Web前端","permalink":"https://harviealwayshere.github.io/tags/Web前端/"}]},{"title":"JS（二）HTML 浏览器BOM对象","slug":"js2","date":"2018-02-26T07:49:15.000Z","updated":"2018-03-02T08:06:08.793Z","comments":true,"path":"2018/02/26/js2/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/26/js2/","excerpt":"","text":"浏览器对象模型（Browser Object Model (BOM)使 JavaScript 有能力与浏览器”对话”。所有浏览器都支持window 对象，它表示浏览器窗口。window对象的成员：所有JavaScript全局对象、函数以及变量window对象的属性：全局变量window对象的方法：全局函数Tips：所有Window对象方法都可以不使用window前缀，直接调用全局方法 Window Screen：包含有关用户屏幕的信息window.screen对象在编写时可以不使用window这个前缀screen对象属性： screen.availWidth：可用的屏幕宽度，以像素计，减去界面特性，比如窗口任务栏 screen.availHeight：可用的屏幕高度，以像素计，减去界面特性，比如窗口任务栏 Window Location：包含URL信息window.location对象用于获得当前页面的地址(URL)，并把浏览器重定向到新的页面location对象属性： location.href：返回当前界面的完整URL，如http://www.w3school.com.cn/js/js_window_location.asp location.hostname：返回web主机的域名， location.pathname：返回URL的路径名，如/js/js_window_location.asp location.port：返回web主机的端口(80或443) location.protocol:返回所使用的web协议（http:// 或 https://） location对象方法： location.assign(URL)：加载新的文档，打开URL地址新界面 location.reload(boolean)：重新加载当前文档，false则会根据文档是否改变决定是否使用缓存加载，true则无论文档是否改变均会会绕过缓存重新加载文档 Window History：包含浏览器历史history对象方法： history.back()：加载历史列表中的前一个URL界面 history.forward()：加载历史列表中的下一个URL界面 Window Navigator：包含有关访问者浏览器的信息由于Navigator信息可被浏览器使用者更改或者浏览器对于测试站点识别错误，所以信息具有误导性，不应该用于检测浏览器版本navigator对象方法： navigator.appCodeName：浏览器代号，如Mozilla navigator.appName：浏览器名称，如Netscape navigator.appVersion：浏览器版本，如Chrome/61.0.3163.100 navigator.cookieEnabled：是否启动启用Cookies，true navigator.platform：硬件平台，如Win32 navigator.userAgent：用户代理，如Mozilla/5.0 navigator.systemLanguage：用户代理语言，如undefined Window PopupAlert:弹窗1.window.alert()：警告框，确保用户得到某些消息，用户需点击确定才能继续操作2.window.confirm(“sometext”);：确认框，验证用户是否接受操作，用户可以点击确认或者取消，相应返回true/false3.window.prompt(“sometext”,”defaultvalue”);：提示框，提示用户需要输入某些值，然后点击确认或者取消，相应返回输入的值/null4.window.open(URL,name,features,replace)：打开一个URL新窗口并可以通过features控制其外观或者利用name查找一个已命名窗口 Window Timing：计时JS中设定一个时间间隔之后来执行代码，我们称之为计时事件，主要使用两个关键方法1.window.setInterval(callback function,milliseconds);：在指定milliseconds毫秒数不断执行callback function回调函数，返回计时器id，可用clearInterval(id)停止计时器2.window.setTimeout(callback function,milliseconds);：在milliseconds毫秒后执行一次callback function回调函数，返回计时器id，可用clearTimeout(id)在函数执行前停止计时器Tips：可使用setTimeout回调自身函数来实现无穷循环Tips：利用setInterval创建一个时钟(每秒钟更新一次时间)123456789&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script&gt;var myVar=setInterval(function()&#123;myTimer()&#125;,1000);function myTimer()&#123; var d=new Date(); var t=d.toLocaleTimeString(); document.getElementById(&quot;demo&quot;).innerHTML=t;&#125;&lt;/script&gt; Window Cookie：存储Web页面用户信息cookie是存储于访问者的计算机中的变量，当web服务器向浏览器发送web页面时，在连接关闭后，服务端不会记录用户的信息，可以利用Cookie记录客户端的用户信息用户信息在Cookie中以键值对的形式存储，如name=key，多个信息可用;分割1.创建Cookie：document.cookie=”username=harvie;expires=”+Date();2.读取Cookie：var x = document.cookie;，以字符串形式返回所有cookie3.删除Cookie：即使Cookie过期，即设置expires属性为以前的时间，如expires=Thu, 01 Jan 1970 00:00:00 GMTTips：我们使用函数设置、获取、检测Cookie123456789101112131415161718192021222324252627282930//设置Cookie（name+exdays）function setCookie(cname,cvalue,exdays)&#123; var d = new Date(); d.setTime(d.getTime()+(exdays*24*60*60*1000)); var expires = &quot;expires=&quot;+d.toGMTString(); document.cookie = cname+&quot;=&quot;+cvalue+&quot;; &quot;+expires;&#125;//获取Cookiefunction getCookie(cname)&#123; var name = cname + &quot;=&quot;; var ca = document.cookie.split(&apos;;&apos;); for(var i=0; i&lt;ca.length; i++) &#123; var c = ca[i].trim(); if (c.indexOf(name)==0) &#123; return c.substring(name.length,c.length); &#125; &#125; return &quot;&quot;;&#125;//检测Cookie(可在页面载入onload时执行checkCookie函数)function checkCookie()&#123; var user=getCookie(&quot;username&quot;); if (user!=&quot;&quot;)&#123; alert(&quot;欢迎 &quot; + user + &quot; 再次访问&quot;); &#125; else &#123; user = prompt(&quot;请输入你的名字:&quot;,&quot;&quot;); if (user!=&quot;&quot; &amp;&amp; user!=null)&#123; setCookie(&quot;username&quot;,user,30); &#125; &#125;&#125;","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://harviealwayshere.github.io/tags/JavaScript/"},{"name":"Web前端","slug":"Web前端","permalink":"https://harviealwayshere.github.io/tags/Web前端/"}]},{"title":"JS（一）基本语法","slug":"js1","date":"2018-02-25T03:28:57.000Z","updated":"2018-02-27T07:57:38.915Z","comments":true,"path":"2018/02/25/js1/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/25/js1/","excerpt":"","text":"JavaScript 是一种轻量级的脚本编程语言，是可插入 HTML 页面的编程代码，几乎可由所有的现代浏览器执行。 JavaScript能做什么？12345678910111213141516171819202122232425262728293031323334353637383940414243//1.直接写入 HTML输出流document.write(&quot;&lt;h1&gt;这是一个标题&lt;/h1&gt;&quot;);//2.对事件的反应函数&lt;button type=&quot;button&quot; onclick=&quot;alert(&apos;欢迎!&apos;)&quot;&gt;点我!&lt;/button&gt;//3.改变HTML内容样式（DOM (Document Object Model)（文档对象模型））&lt;script&gt;function myFunction()&#123; x=document.getElementById(&quot;demo&quot;); // 找到元素 x.innerHTML=&quot;Hello JavaScript!&quot;; // 改变内容 x.style.color=&quot;#ff0000&quot;; // 改变样式&#125;&lt;/script&gt;//4.改变HTML图像&lt;script&gt;function changeImage()&#123; element=document.getElementById(&apos;myimage&apos;) if (element.src.match(&quot;bulbon&quot;)) &#123; element.src=&quot;/images/pic_bulboff.gif&quot;; &#125; else &#123; element.src=&quot;/images/pic_bulbon.gif&quot;; &#125;&#125;&lt;/script&gt;//5.验证输入&lt;script&gt;function myFunction()&#123; var x=document.getElementById(&quot;demo&quot;).value; if(x==&quot;&quot;||isNaN(x)) &#123; alert(&quot;不是数字&quot;); &#125;&#125;&lt;/script&gt; JS用法JS需要被放置在&lt; script&gt;标签内&lt; script&gt;标签可位于或者标签内我们可以直接在&lt; script&gt;标签内编写JS代码或者使用&lt; script src=”xxx.js”&gt;引用外部JS代码Tips：有些老旧的实例可能会在&lt; script&gt;便签中使用type=”text/javascript”，现在已经不必了，因为JS已经是所有现代浏览器和HTML5中默认的脚本语言了 JS输出有不同方式输出，大致有四种1.使用window.alert()弹出警告栏2.使用document.write()将内容写入HTML文档中(页面加载前)3.使用x.innerHTML写入x元素的HTML内容4.使用console.log()写入浏览器的控制台Tips：console.log()用于调试JS是十分方便的，因为它可以显示结构化的数据，如Array、Object可以看到数组和对象的内容，而且不会打断页面操作，页面可以继续执行接下来的操作 JS语法JS字面量：固定值，如 数字(Number)：整数小数科学计数，314,3.14,123e5** 字符串(String)：单引号双引号字符，’Harvie’,”Harvie” 表达式字面量：带运算符，5+6，5*6 数组(Array)：[40,50,60] 对象(Object)：{firstName:”Harvie”,lastName:”Ryan”,age:50} 函数(function)：function myfunction(a,b){return a*b} JS变量：存储数据值，使用关键字var声明变量，使用=为变量赋值 JS操作符：分为赋值/算数/位运算符(=,+,-,*,/)和条件/比较/逻辑运算符(==,!=,&lt;,&gt;) JS语句：向浏览器发出命令，用;(分号)分隔 JS注释：不是命令的语句，用//(双斜杠)分隔 JS数据类型：数字、字符串、数组、对象等，使用相应的字面量赋值，是弱类型的，都是通过var声明 JS大小写和字符集：JS对于大小写敏感，使用Unicode字符集 JS语句JavaScript语句通常以一个语句标识符为开始，并执行该语句，如下。 JS注释//…单行注释，/…/多行注释，…//行末注释 JS变量变量是用于存储信息的”容器”，可以使用短名称(x,y)，也可以使用描述性名称(age,num),但是要符合一下规则Tips：如果重新声明 JavaScript 变量，该变量的值不会丢失，如var x=1;var x;，x的值仍为1Tips：let变量，作用域被限制在块级中的变量、语句或者表达式，在Function中局部变量使用let变量可避免变量名冲突，var变量作用域是整个封闭函数1234567891011121314151617function varTest() &#123; var x = 1; if (true) &#123; var x = 2; // 同样的变量 console.log(x); //2 &#125; console.log(x); // 2&#125;function letTest() &#123; let x = 1; if (true) &#123; let x = 2; // 不同的变量 console.log(x); // 2 &#125; console.log(x); // 1&#125; JS数据类型JS拥有动态类型，声明的变量类型均为弱类型，可随意切换，如1var x; x=1; x=&quot;HARVIE&quot;; x=[1,2,3];JS字符串中使用单引号和双引号需要使用+引号，如1var x=&quot;His name is \\&quot;Harvie\\&quot;&quot;;JS只有一种数字类型，可以带小数点，可以使用科学计数(e)，如1var x=314; x=3.14; x=314e-2;JS布尔类型只有两个值，true或者false1var x=true; var y=false; JS对象和数组：详情见博文JS（二）JS空类型Undefined表示变量不含有值，如变量刚声明时为UndefinedNull表示变量为空，可通过将变量的值设为null来清空变量 JS函数由事件驱动的或者当它被调用时执行的可重复使用的，使用关键词function，包裹在{ }中的代码块 JS作用域局部作用域：变量在函数内声明，变量为局部作用域，只能在函数内部访问全局作用域：变量在函数外声明即为全局变量，若变量在函数内没有声明(没有使用var关键字)，该变量自动升级为全局变量HTML中的全局变量：在HTML中，所有全局变量都属于window对象，都可以使用window.变量名访问let关键字变量：可将变量作用域限制在当前代码块中const关键字变量：所声明的是常量，其值不可以更改 JS字符串用于存储一系列字符，用单引号或双引号包裹可以在字符串中添加转义字符来使用引号等符号，如var x = ‘It\\’s alright’;可以使用内置属性length来计算字符串长度，如x.length;更多字符串方法可以看这里 JS条件语句 JS循环语句介绍一下For/In循环，主要用来遍历对象的属性(name+value)，如12345var Person=&#123;firstName:&quot;John&quot;, lastName:&quot;Doe&quot;, id:5566&#125;;var txt=&quot;&quot;;for (x in Person)&#123; txt=txt+x+&quot;=&gt;&quot;+Person[x]+&quot;\\n&quot;;&#125; JS typeof操作符typeof操作符：用于检测变量的数据类型，如typeof x，返回x的数据类型null：JS中一个只有一个值的数据类型，表示一个空对象的引用，typeof null为object，可以将对象设为null来清空对象undefined：JS中一个没有设置值的变量，typeof undefined为undefined，可以将任何变量设置为undefined来清空变量Tips：instanceof用于判断对象具体类型，如var result = objectName instanceof objectType，若objectName属于ObjectType类型则返回true，否则返回false JS类型转换JS有5种数据类型：string/number/boolean/object/function3种对象类型：Object/Date/Array2个不包含任何值的类型：null/undefinedTips:NaN指示该值不是数字值，某些算数运算(如求负数平方根)结果或者类型转换结果(parseInt()/parseFloat())，可用isNaN()判断一个值是否是NaN值Tips:数组Array/日期Date/null的数据类型均是object 变量的constructor属性：返回所有JS变量的构造函数，可用来判断对象是否为数组、日期，如123456function isArray(myArray) &#123; return myArray.constructor.toString().indexOf(&quot;Array&quot;) &gt; -1;&#125;function isDate(myDate) &#123; return myDate.constructor.toString().indexOf(&quot;Date&quot;) &gt; -1;&#125; JS变量的类型转换：有2种方法，1.通过使用JS函数，2.通过JS的自身自动转换JS函数：全局方法String()可将变量转为字符串，如Srting(123)/String(false)/String(new Date())全局方法Number()可将变量转为数字，如Number(“3.14”)/Number(“99 88”)=&gt;返回NaN/Number(new Date())全局方法parseFloat()/parseInt()将字符串转为一个浮点数/整数自动转换:一元运算符+：自动统一表达式两边变量类型转换成同一数据类型.innerHTML：输出一个对象或者变量时，JS会自动调用该变量的toString()方法，将改变量转换成String JS正则表达式正则表达式是使用字符串来描述、匹配一系列符合某个句法规则的字符串搜索模式，可用于文本搜索和文本替换JS正则语法格式：/正则表达式主体/修饰符(可选)修饰符：i=&gt;对大小不敏感，g=&gt;全局匹配，m=&gt;多行匹配字符串方法使用正则：1.serach()：检索字符串中指定的子字符串，若匹配则返回子串的起始位置2.replace()：用于在字符串中用一些字符替换另一些字符RegExp对象使用正则：1.test()方法用于检测一个字符串是否匹配某个模式，若字符串中含有匹配的文本，则返回true，否则返回false，如1234567891011121314151617181920212223242526272829/*是否带有小数*/function isDecimal(strValue ) &#123; var objRegExp= /^\\d+\\.\\d+$/; return objRegExp.test(strValue); &#125; /*校验是否中文名称组成 */function ischina(str) &#123; var reg=/^[\\u4E00-\\u9FA5]&#123;2,4&#125;$/; /*定义验证表达式*/ return reg.test(str); /*进行验证*/&#125;/*校验是否全由8位数字组成 */function isStudentNo(str) &#123; var reg=/^[0-9]&#123;8&#125;$/; /*定义验证表达式*/ return reg.test(str); /*进行验证*/&#125;/*校验电话码格式 */function isTelCode(str) &#123; var reg= /^((0\\d&#123;2,3&#125;-\\d&#123;7,8&#125;)|(1[3584]\\d&#123;9&#125;))$/; return reg.test(str);&#125;/*校验邮件地址是否合法 */function IsEmail(str) &#123; var reg=/^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+(\\.[a-zA-Z0-9_-])+/; return reg.test(str);&#125;2.exec()方法用于检索字符串中正则表达式的匹配，若找到匹配的结果则返回一个数组存放，若未找到则返回null JS错误try语句测试代码块的错误catch语句处理错误（系统发现的错误）throw语句创建或抛出异常(自己发现的错误)语法：1234567try &#123; //在这里运行代码 if(x==y) throw &quot;error!&quot;;&#125; catch(err) &#123; //在这里处理错误，如 alert(err.message);&#125; JS调试1.console.log()方法：在浏览器控制台打印关键信息2.debugger关键字：设置断点调试，如var x=1;debugger;var y=1; JS变量提升(Hoisting)JS中，函数及变量的声明都将被提升到函数的最顶部，因此变量可以在使用后声明。但是只有声明的变量会提升，初始化的变量不会提升 JS严格模式(Strict Mode)使用命令“use strict”;进入严格模式，可以消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为，1.增加代码安全性，2.提高编译器效率，3.为未来新版本的JS做好铺垫 JS表单验证1.表单事件验证：可以利用表单的onsubmit事件，在表单提交时被触发，执行验证函数，验证表单数据，若为return false则可阻止表单提交获取表单的数据可用document.forms[“formName”][“valueName”].value;获取表单数据如非空验证1234567891011121314&lt;form name=&quot;myForm&quot; action=&quot;demo_form.php&quot;onsubmit=&quot;return validateForm()&quot; method=&quot;post&quot;&gt;名字: &lt;input type=&quot;text&quot; name=&quot;fname&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;script&gt;function validateForm() &#123; var x = document.forms[&quot;myForm&quot;][&quot;fname&quot;].value; if (x == null || x == &quot;&quot;) &#123; alert(&quot;需要输入名字。&quot;); return false; &#125;&#125;&lt;/script&gt;如E-mail验证(必须包含@符号和点号(.)/@不可以是邮件地址的首字符/@后至少一个点号)1234567891011&lt;script&gt;function validateForm()&#123; var x=document.forms[&quot;myForm&quot;][&quot;email&quot;].value; var atpos=x.indexOf(&quot;@&quot;); var dotpos=x.lastIndexOf(&quot;.&quot;); if (atpos&lt;1 || dotpos&lt;atpos+2 || dotpos+2&gt;=x.length)&#123; alert(&quot;不是一个有效的 e-mail 地址&quot;); return false; &#125;&#125;&lt;/script&gt; 2.HTML约束验证：可在HTML元素中直接增加约束，如required=”required”/disabled/pattern/max/min/type等详情可见这里 3.服务器端数据验证：数据提交到服务器后再验证 JS JSONJSON全称JavaScript Object Notation，轻量级存储和传输数据的格式，通常用于服务端向网页传递数据。JSON格式：1.数据为键值对(“key”:”value”)，由逗号分隔，如”name”:”Runoob”2.大括号{}保存对象，{“name”:”Runoob”, “url”:”www.runoob.com”}3.方括号[]保存数组，数组中可保存对象，如 JSON字符串转换为JS对象：我们从服务器中接收JSON数据并利用JSON.parse(text[, reviver])将JSON字符串转换为JS对象，reviver为转换结果函数将会调用对象的每个成员，如function(k,v)1234567var text = &apos;&#123; &quot;sites&quot; : [&apos; + &apos;&#123; &quot;name&quot;:&quot;Runoob&quot; , &quot;url&quot;:&quot;www.runoob.com&quot; &#125;,&apos; + &apos;&#123; &quot;name&quot;:&quot;Google&quot; , &quot;url&quot;:&quot;www.google.com&quot; &#125;,&apos; + &apos;&#123; &quot;name&quot;:&quot;Taobao&quot; , &quot;url&quot;:&quot;www.taobao.com&quot; &#125; ]&#125;&apos;;JSObj = JSON.parse(text);// JSObj.sites[1].name =&gt; Google// JSObj.sites[1].url =&gt; www.google.com JS对象转换为JSON字符串：我们可以使用JSON.stringify(value[, replacer[, space]])方法将JS对象转换为JSON字符串传递给服务器，space可为文本添加缩进、空格、换行符，如int i则添加i个空格缩进，若为\\t则添加制表符12var str = &#123;&quot;name&quot;:&quot;菜鸟教程&quot;, &quot;site&quot;:&quot;http://www.runoob.com&quot;&#125;;str_pretty1 = JSON.stringify(str); //&#123;&quot;name&quot;:&quot;菜鸟教程&quot;,&quot;site&quot;:&quot;http://www.runoob.com&quot;&#125; JS死链接我们经常看到href=”javascript:void(0)”，表示点击这个链接是不会发生任何跳转的链接void()方法表示不返回任何值，void()中的语句会执行但是返回的结果不会被void传递到函数外部 href=”#”表示定位到#位置，#包含了一个位置信息，默认的锚#top也就是网页的上端，可用#+id定位到页面的具体位置 JS函数自调用函数：(function(){})();表示这是一个自调用函数，运行至脚本处会自动触发调用全局对象：若函数没有被自身的对象调用时，this的值会变成全局对象，web浏览器中全局对象是浏览器窗口(window对象)对象方法调用函数：函数可作为对象的方法被调用，如var x = {y:function(){ return 0;}}，可通过x.y()调用函数构造函数调用函数：函数调用使用new关键字则调用了构造函数，创建了新的对象，如function y(){this.z=1;};var x= new y();，则x为一个对象{“z” : 1} JS闭包计数器困境：若计数器为全局变量，则除了add()计数函数外其他所有函数也可以访问计数器变量，不安全；若计数器变量在add()计数函数内声明并初始化为0，则每次调用add()函数就都会初始化变量失去了计数功能闭包：父函数内嵌函数会持有父方法的局部变量并且不会随父方法销毁而销毁，就是说即便父函数已经执行完了但是里面的变量被赋给了别的变量，这个变量并不会随着父函数的调用结束而消失12345678910&lt;script&gt;var add = (function () &#123; var counter = 0; return function () &#123;return counter += 1;&#125;&#125;)();&lt;/script&gt;//利用自调用函数，执行一次申明并初始化变量counter的过程之后返回一个匿名函数给add，这样add就变成了一个函数add()&#123;return counter +=1;&#125;这个函数持有父函数的变量counter但是即便父函数执行结束后counter并没有被销毁因此每次执行add()，都会使counter++，也仅有执行add()才能调用到counter变量，保证了变量的私有性","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://harviealwayshere.github.io/tags/JavaScript/"},{"name":"Web前端","slug":"Web前端","permalink":"https://harviealwayshere.github.io/tags/Web前端/"}]},{"title":"Swoole(十六)实现一个长连接的网络聊天室","slug":"swoole16","date":"2018-02-21T11:09:56.000Z","updated":"2018-02-22T10:19:50.016Z","comments":true,"path":"2018/02/21/swoole16/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/21/swoole16/","excerpt":"","text":"这次我们首先一个类似IM的网络聊天室，服务器端使用websocket，客户端使用JS连接。 1.Websocket服务器首先将服务器端代码写好1234567891011121314151617181920212223242526272829303132333435363738&lt;?php//创建Websocket服务器$ws = new swoole_websocket_server(&quot;0.0.0.0&quot;, 9501);//on监听事件函数 open/message/close$ws-&gt;on(&apos;open&apos;, function ($ws, $request) &#123; echo &quot;user&quot;.$request-&gt;fd.&quot;in\\n&quot;; //将新用户存在全局变量里 $GLOBALS[&apos;fd&apos;][$request-&gt;fd][&apos;id&apos;] = $request-&gt;fd; $GLOBALS[&apos;fd&apos;][$request-&gt;fd][&apos;name&apos;] = &quot;noName&quot;;&#125;);$ws-&gt;on(&apos;message&apos;, function ($ws, $request) &#123; //若接受的数据中含#name# 则为设置用户名 if(strstr($request-&gt;data, &quot;#name#&quot;))&#123; //将接受到的数据中的#name#替换成空白后存入相应的全局变量中 $GLOBALS[&apos;fd&apos;][$request-&gt;fd][&apos;name&apos;] = str_replace(&quot;#name#&quot;, &apos;&apos;, $request-&gt;data); &#125;else&#123;//若接受的数据中不含#name#, 则为用户发送消息 //编辑消息格式 $msg = $GLOBALS[&apos;fd&apos;][$request-&gt;fd][&apos;name&apos;].&quot;:&quot;.$request-&gt;data.&quot;\\n&quot;; //向所连接的每个客户端发送消息 foreach ($GLOBALS[&apos;fd&apos;] as $client) &#123; //使用push推送消息 $ws-&gt;push($client[&apos;id&apos;],$msg); &#125; &#125;&#125;);$ws-&gt;on(&apos;close&apos;, function ($ws, $request) &#123; echo &quot;user&quot;.$request-&gt;fd.&quot;out\\n&quot;; //删除用户信息 unset( $GLOBALS[&apos;fd&apos;][$request-&gt;fd]);&#125;);//启动服务器$ws-&gt;start(); 2.配置LAMP环境LP我们已经具备了，现在配置AM环境2.1 安装Apache查询是否有Apache安装包：yum list httpd若有直接安装（如我的有x86_64版本的）:yum install httpd.x86_64若没有则使用yum安装Apache：yum -y install httpd设置开机启动：chkconfig –levels 235 httpd on启动Apache：service httpd start(重启Apache：service httpd restart)查询Apache是否启动：ps -ef|grep httpd [Apache默认网站目录/var/www/html]测试是否访问正常：cd /var/www/html/vim index.php&lt;?php phpinfo();?&gt;此时可访问localhost或者使用外网IP访问，出现phpinfo信息则正常 2.2 安装Mysql由于CentOS7默认是安装Maridb，但是不用担心，因为Maridb是mysql的一个分支且支持任何mysql语句，所以我们安装maridb，命令和操作都照常使用mysql的就可以拉，具体maridb和mysql的渊源可以看看知乎这里安装Maridb：yum install -y mariadb-server启动Maridb： service mariadb start（停止和重启服务是 service+服务名+stop/restart）查询是否启动：ps -ef|grep mariadb （此时可查询mysql服务，也可以查询出结果）设置开启启动：chkconfig –levels 235 mariadb on设置root账户密码：mysql_secure_installationTips:一开始提示输入原密码直接回车就好，因为原密码为空，然后输入新密码，之后一直y即可登录mariadb：mysql -u root -p (输入刚才设定的密码即可) 2.3 安装phpmyadmin远程管理数据库安装phpmyadmin：yum install phomyadmin由于默认情况下CentOS7上的phpmyadmin只允许从本地访问，因此我们需要修改phpmyadmin的配置phpMyAdmin默认配置目录为/etc/httpd/conf.d/phpMyAdmin.conf然后将限制ip访问的改成允许(共有4条语句要注释，增加两条Require all granted语句)，如下详情可点击这里查看之后输入IP地址/phpmyadmin即可远程登录数据库管理在开发环境想不用频繁登录phpmyadmin可以在/etc/phpMyAdmin/config.inc.php中修改登录模式，有自动登录模式，详情可查看这里 3.客户端实现客户端代码就十分简易，功能大概就是检验是否连接、设置昵称和发送消息12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;IM聊天室&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;msg&quot;&gt;&lt;/div&gt; &lt;input type=&quot;text&quot; id=&quot;text&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;发送数据&quot; onclick=&quot;send()&quot;&gt;&lt;/body&gt;&lt;script&gt; var msg = document.getElementById(&quot;msg&quot;); var connectIp = &apos;ws://39.108.210.229:9501&apos;; //调用websocket对象建立连接： //参数：ws/wss(加密)：//ip:port （字符串） var websocket = new WebSocket(connectIp); //onopen监听连接打开 websocket.onopen = function (evt) &#123; //websocket.readyState 属性： /* CONNECTING 0 The connection is not yet open. OPEN 1 The connection is open and ready to communicate. CLOSING 2 The connection is in the process of closing. CLOSED 3 The connection is closed or couldn&apos;t be opened. */ if(websocket.readyState == 1) &#123; msg.innerHTML=&quot;连接成功!&lt;br&gt;可使用&apos;#name#+您的昵称&apos;设置昵称&lt;br&gt;&quot;; &#125; //msg.innerHTML = websocket.readyState; &#125;; function send()&#123; var text = document.getElementById(&apos;text&apos;).value; document.getElementById(&apos;text&apos;).value = &apos;&apos;; //向服务器发送数据 websocket.send(text); &#125; //监听连接关闭// websocket.onclose = function (evt) &#123;// console.log(&quot;Disconnected&quot;);// &#125;; //onmessage 监听服务器数据推送 websocket.onmessage = function (evt) &#123; msg.innerHTML += evt.data +&apos;&lt;br&gt;&apos;;// console.log(&apos;Retrieved data from server: &apos; + evt.data); &#125;;//监听连接错误信息// websocket.onerror = function (evt, e) &#123;// console.log(&apos;Error occured: &apos; + evt.data);// &#125;;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;上传到服务器端的网页目录[/var/www/html]，之后运行服务器端代码，之后随意用任意浏览器访问客户端页面[ip/xxx.html]即可，具体效果如下，运行服务器脚本后当浏览器两个请求访问时可以看到两个用户加入了，然后我们可以设置昵称开始发送消息，每个客户端发送的消息到服务器端都会被服务器端推送至每个客户端","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"php项目","slug":"php项目","permalink":"https://harviealwayshere.github.io/tags/php项目/"},{"name":"swoole","slug":"swoole","permalink":"https://harviealwayshere.github.io/tags/swoole/"}]},{"title":"Swoole(十五)异步文件写入","slug":"swoole15","date":"2018-02-20T10:17:56.000Z","updated":"2018-02-21T09:01:56.087Z","comments":true,"path":"2018/02/20/swoole15/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/20/swoole15/","excerpt":"","text":"Swoole增加了异步文件读写，异步DNS，异步Http/WebSocket客户端等特性。开发纯异步非阻塞IO的程序时，不能使用PHP自带的网络客户端，如curl、file_get_contents、stream、sockets、mysql、redis。 1.(小文件)异步写文件：swoole_async_writefile提供了两种风格函数风格：swoole_async_writefile($filename, $fileContent, function($filename){}, $flags = 0);面向对象风格：Swoole\\Async::writeFile(string $filename, string $fileContent, callable $callback = null, int $flags = 0)$filename：文件名称，须有可写权限，文件不存在会自动创建，打开文件失败会返回false$fileContent：写入文件的内容，最大可写入4M$callback：写入成功的回调函数，可选flags：写入选项，可以使用FILE_APPEND表示追加到文件末尾Tips：Linux原生异步IO不支持FILE_APPEND，并且写入的内容长度必须为4096的整数倍，否则底层会自动在末尾填充0 2.(大文件)异步写文件：swoole_async_write函数原型：bool swoole_async_write(string $filename, string $content, int $offset = -1, mixed $callback = NULL);$filename：文件名称$content：写入文件的内容，因为是分段写入，所以无限制$offset：写入方式，-1为追加写入到文件末尾$callback：写入成功的回调函数，可选swoole_async_write是分段写的。不需要一次性将要写的内容放到内存里，所以只占用少量内存。swoole_async_write通过传入的offset参数来确定写入的位置。 3.两种写入方式测试将脚本上传到服务器运行可以看到我们用vim打开写入的文件看看内容可以看到由于是异步写入，write比writeFile2的写入还要早执行，但是三个写入函数都执行成功了，一个是直接写入，一个是追加写入，还有一个是大文件的写入","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"php项目","slug":"php项目","permalink":"https://harviealwayshere.github.io/tags/php项目/"},{"name":"swoole","slug":"swoole","permalink":"https://harviealwayshere.github.io/tags/swoole/"}]},{"title":"Swoole(十四)异步文件读取","slug":"swoole14","date":"2018-02-20T10:17:51.000Z","updated":"2018-02-21T08:27:33.779Z","comments":true,"path":"2018/02/20/swoole14/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/20/swoole14/","excerpt":"","text":"Swoole增加了异步文件读写，异步DNS，异步Http/WebSocket客户端等特性。开发纯异步非阻塞IO的程序时，不能使用PHP自带的网络客户端，如curl、file_get_contents、stream、sockets、mysql、redis。 1.(小文件)异步读取文件内容：swoole_async_readfile提供了两种风格函数风格：swoole_async_readfile(string $filename, mixed $callback);面向对象风格：Swoole\\Async::readFile(string $filename, mixed $callback);$filename：路径下的文件名$callback：由于是异步非阻塞，数据读取完毕后会立即调用指定的回调函数Tips：swoole_async_readfile会将文件内容全部复制到内存，所以不能用于大文件的读取如果要读取超大文件，请使用swoole_async_read函数 2.(大文件)异步读取文件内容：swoole_async_read函数原型：bool swoole_async_read(string $filename, mixed $callback, int $size = 8192, int $offset = 0);$filename：路径下的文件名$callback：回调函数接受两个参数bool callback(string $filename, string $content);，$filename-文件名称，$content-读取到的分段内容，如果内容为空，表明文件已读完，在回调函数中可通过return true/false，来控制继续读下一段内容/停止读取并关闭文件。$size：读取的分段内容的大小，单位字节Tips：此函数与swoole_async_readfile不同，它是分段读取，可以用于读取超大文件。每次只读$size个字节，不会占用太多内存。 3.两种读取方式测试123456789101112131415161718192021&lt;?phpecho &quot;swoole_async_readfile \\n&quot;;//readFile读取swoole_async_readfile(__DIR__.&quot;/testFile.txt&quot;, function($filename, $content) &#123; echo &quot;swoole_async_readfile-[$filename] : $content \\n&quot;;&#125;);echo &quot;swoole_async_read \\n&quot;;//read读取swoole_async_read(__DIR__.&quot;/testFile.txt&quot;, function($filename, $content) &#123; if($content)&#123; echo &quot;swoole_async_read-[$filename] : $content \\n&quot;; return true; &#125;else&#123; return false; &#125; &#125;); 上传脚本和测试文本到服务器可以看到由于是异步读取，两个echo都在文件读取之前输出出来了，之后就是两个文件读取内容的打印","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"php项目","slug":"php项目","permalink":"https://harviealwayshere.github.io/tags/php项目/"},{"name":"swoole","slug":"swoole","permalink":"https://harviealwayshere.github.io/tags/swoole/"}]},{"title":"Swoole(十三)DNS查询","slug":"swoole13","date":"2018-02-20T10:17:48.000Z","updated":"2018-02-21T07:16:18.752Z","comments":true,"path":"2018/02/20/swoole13/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/20/swoole13/","excerpt":"","text":"Swoole有(异步)DNS查询功能(我也不知道为什么集成了) 1.（异步）将域名解析为IP地址：swoole_async_dns_lookup函数原型：swoole_async_dns_lookup($domainName,callback function($host,$ip){});$domainName：传入的域名DNS查询完成：自动回调指定的callback函数。DNS查询失败：比如域名不存在，回调函数传入的$ip为空调用此函数是非阻塞的，调用会立即返回。将向下执行后面的代码。 2.执行DNS查询123swoole_async_dns_lookup(&quot;www.baidu.com&quot;, function($host, $ip)&#123; echo &quot;&#123;$host&#125; : &#123;$ip&#125;\\n&quot;;&#125;); 脚本在服务器运行，可以看到执行成功","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"php项目","slug":"php项目","permalink":"https://harviealwayshere.github.io/tags/php项目/"},{"name":"swoole","slug":"swoole","permalink":"https://harviealwayshere.github.io/tags/swoole/"}]},{"title":"Swoole(十二)锁机制","slug":"swoole12","date":"2018-02-20T10:17:41.000Z","updated":"2018-02-20T17:41:02.115Z","comments":true,"path":"2018/02/20/swoole12/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/20/swoole12/","excerpt":"","text":"Swoole针对内存的其他提供了一系列的锁机制swoole_lock类支持5种锁的类型： 文件锁 SWOOLE_FILELOCK 读写锁 SWOOLE_RWLOCK 信号量 SWOOLE_SEM 互斥锁 SWOOLE_MUTEX 自旋锁 SWOOLE_SPINLOCKTips：之前学习单例模式算法的时候，为了防止两个进程创建两个单例，就需要使用锁机制，C++/C#有private static object syncObj = new object();，JAVA中有synchronized(Singleton2.class){}，没想到PHP也有Swoole扩展的锁机制。 1.创建锁对象：$lock = new swoole_lock();函数原型：swoole_lock-&gt;__construct(int $type, [string $lockfile]);$type：锁的类型，具体为以上五种锁$lockfile：当类型为SWOOLE_FILELOCK(文件锁)时必须传入，指定文件锁的路径注意每一种类型的锁支持的方法都不一样，如读写锁、文件锁可以支持$lock-&gt;lock_read()。另外除文件锁外，其他类型的锁必须在父进程内创建，这样fork出的子进程之间才可以互相争抢锁。 2.加锁：swoole_lock-&gt;lock函数原型：bool $lock-&gt;lock();如果有其他进程持有锁，那这里将进入阻塞，直到持有锁的进程unlock。 3.释放锁：swoole_lock-&gt;unlock函数原型：bool $lock-&gt;unlock();解锁成功返回true。 4.创建一个互斥锁并通过主进程和子进程演示123456789101112131415161718192021222324&lt;?php//创建锁对象（互斥锁）$lock = new swoole_lock(SWOOLE_MUTEX);echo &quot;[Master]create mutex lock\\n&quot;;//主进程 加锁$lock-&gt;lock();//创建子进程if(pcntl_fork() &gt; 0)&#123; //创建成功则主进程解锁 sleep(1); $lock-&gt;unlock();&#125;else&#123; //创建失败则子进程等待主进程解锁后子进程再加锁进行自身的操作 echo &quot;[Child] Wait Lock\\n&quot;; $lock-&gt;lock(); echo &quot;[Child] Get Lock\\n&quot;; $lock-&gt;unlock(); exit(&quot;[Child] exit\\n&quot;);&#125;echo &quot;[Master]release lock\\n&quot;;unset($lock);sleep(1);echo &quot;[Master]exit\\n&quot;; 运行脚本在服务器上，可以看到首先主进程创建互斥锁并上锁(create mutex lock)此时子进程创建失败只能等待(wait lock)等到主进程释放锁(release lock)主进程释放锁后，子进程首先加锁(get lock)之后子进程做自己的事情，完成后解锁退出(exit)此时主进程再退出(exit)","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"php项目","slug":"php项目","permalink":"https://harviealwayshere.github.io/tags/php项目/"},{"name":"swoole","slug":"swoole","permalink":"https://harviealwayshere.github.io/tags/swoole/"}]},{"title":"Swoole(十一)进程信号触发器","slug":"swoole11","date":"2018-02-20T09:29:28.000Z","updated":"2018-02-21T11:21:50.053Z","comments":true,"path":"2018/02/20/swoole11/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/20/swoole11/","excerpt":"","text":"Swoole具备进程管理模块，用来代替PHP的pcntl拓展。1.设置异步信号监听：swoole_process::signal函数原型：bool swoole_process::signal(int $signo, callable $callback);此方法基于signalfd和eventloop是异步IO，不能用于同步程序中同步阻塞的程序可以使用pcntl扩展提供的pcntl_signal$callback如果为null，表示移除信号监听 如果已设置了此信号的回调函数，重新设置时会覆盖历史设置2.高精度定时器：swoole_process::alarm高精度定时器，是操作系统setitimer系统调用的封装，可以设置微秒级别的定时器。定时器会触发信号，需要与swoole_process::signal（异步）或pcntl_signal（同步）配合使用。函数原型：function swoole_process::alarm(int $interval_usec, int $type = ITIMER_REAL) : bool$interval_usec：定时器间隔时间，单位为微秒。如果为负数表示清除定时器$type：定时器类型 0 表示为真实时间,触发SIGALAM信号 1 表示用户态CPU时间，触发SIGVTALAM信号 2 表示用户态+内核态时间，触发SIGPROF信号 3.创建定时器及信号监听函数12345678910111213141516&lt;?php//触发函数 异步执行 达到条件停止swoole_process::signal(SIGALRM,function()&#123; //计时器 用于停止定时器触发信号 static $i=0; echo &quot;hello!\\n&quot;; $i++; if($i&gt;10)&#123; //触发十次 清除定时器 swoole_process::alarm(-1); &#125;&#125;);//定时信号swoole_process::alarm(100*1000); 将脚本上传至服务器并运行，可以看到成功发送了10次信号并触发后清除定时器停止程序","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"php项目","slug":"php项目","permalink":"https://harviealwayshere.github.io/tags/php项目/"},{"name":"swoole","slug":"swoole","permalink":"https://harviealwayshere.github.io/tags/swoole/"}]},{"title":"Swoole(十)进程队列通信","slug":"swoole10","date":"2018-02-20T09:25:28.000Z","updated":"2018-02-20T10:16:51.686Z","comments":true,"path":"2018/02/20/swoole10/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/20/swoole10/","excerpt":"","text":"Swoole具备进程管理模块，用来代替PHP的pcntl拓展。 1.投递数据到消息队列：swoole_process-&gt;push函数原型：bool swoole_process-&gt;push(string $data);$data：投递的数据，长度受限与操作系统内核参数的限制。默认为8192，最大不超过65536默认模式下（阻塞模式）：队列已满，push方法会阻塞等待非阻塞模式下：队列已满，push方法会立即返回false 2.从队列中提取数据：swoole_process-&gt;pop函数原型：string swoole_process-&gt;pop(int $maxsize = 8192);$maxsize：表示获取数据的最大尺寸，默认为8192操作成功会返回提取到的数据内容，失败返回false默认模式下：队列中没有数据，pop方法会阻塞等待非阻塞模式下：队列中没有数据，pop方法会立即返回false，并设置错误码为ENOMSG 3.回收结束运行的子进程：swoole_process::wait子进程结束必须要执行wait进行回收，否则子进程会变成僵尸进程函数原型：array(‘code’ =&gt; 0, ‘pid’ =&gt; 15001, ‘signal’ =&gt; 15) swoole_process::wait(bool $blocking = true);$blocking：可以指定是否阻塞等待，默认为阻塞操作成功会返回一个数组包含子进程的PID、退出状态码、被哪种信号KILL如果在异步信号回调中执行wait123456swoole_process::signal(SIGCHLD, function($sig) &#123; //必须循环执行wait直到返回false while($ret = swoole_process::wait(false)) &#123; echo &quot;PID=&#123;$ret[&apos;pid&apos;]&#125;\\n&quot;; &#125;&#125;); 4.启用消息队列作为进程间通信：swoole_process-&gt;useQueue函数原型：bool swoole_process-&gt;useQueue(int $msgkey = 0, int $mode = 2);$msgkey：消息队列的key，默认会使用ftok(FILE, 1)作为KEY$mode：通信模式，默认为2，表示争抢模式，所有创建的子进程都会从队列中取数据 5.退出子进程：swoole_process-&gt;exit函数原型：int swoole_process-&gt;exit(int $status=0);$status是退出进程的状态码，如果为0表示正常结束，会继续执行PHP的shutdown_function，其他扩展的清理工作。$status不为0，表示异常退出，会立即终止进程。不再执行PHP的shutdown_function，其他扩展的清理工作。在父进程中，执行swoole_process::wait可以得到子进程退出的事件和状态码。 6.创建进程队列并通信123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?php//进程池 存储进程$workers = []; //进程数量$worker_num = 2;//创建并启动进程for($i=0;$i&lt;$worker_num;$i++)&#123; //创建新进程，注意第三个参数为false，不启动pipe通信 $process = new swoole_process(&apos;doProcess&apos;,false,false); //启用消息队列作为进程间通信 $process-&gt;useQueue(); $pid = $process-&gt;start(); //启动进程并获取进程ID $workers[$pid] = $process; //将进程存入进程池&#125;//编写进程执行函数function doProcess(swoole_process $worker)&#123; //从主进程(master)中获取数据 $recv = $worker-&gt;pop(); echo &quot;Worker(&quot;.$worker-&gt;pid.&quot;)From Master: &quot;.$recv.&quot;\\n&quot;; sleep(2); //退出子进程 0表示正常结束 $worker-&gt;exit(0);&#125;//主进程向子进程添加数据foreach ($workers as $process) &#123; $process-&gt;push(&quot;hello worker[&quot;.$process-&gt;pid.&quot;]\\n&quot;);&#125;//等待子进程结束回收资源for($i = 0; $i &lt; $worker_num; $i++)&#123; //等待执行完成 $ret = swoole_process::wait(); $pid = $ret[&apos;pid&apos;]; //释放进程池中的进程资源 unset($workers[$pid]); echo &quot;Worker Exit, PID=&quot;.$pid.PHP_EOL;&#125; 将PHP脚本上传至服务器并运行，可以看到进程确实pop到了主进程push的数据，但是不知道为什么主进程push数据的时候识别的子进程的ID打印出来是错误的，可以看到子进程的PID分别是9922和9921，回收进程时也是这两个ID，可是接收到主进程push的数据时的PID确实9918和9919","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"php项目","slug":"php项目","permalink":"https://harviealwayshere.github.io/tags/php项目/"},{"name":"swoole","slug":"swoole","permalink":"https://harviealwayshere.github.io/tags/swoole/"}]},{"title":"Swoole(九)同步/异步进程","slug":"swoole9","date":"2018-02-19T09:40:20.000Z","updated":"2018-02-20T09:36:35.836Z","comments":true,"path":"2018/02/19/swoole9/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/19/swoole9/","excerpt":"","text":"Swoole具备进程管理模块，用来代替PHP的pcntl拓展。Process进程是系统中十分昂贵的资源，创建进程消耗很大，可以使用vmstat指令查看系统每秒进程切换次数 1.PHP自带pcntl拓展存在很多不足 pcntl没有提供进程间通信的功能 pcntl不支持重定向标准输入和输出 pcntl只提供了fork这样原始的接口，容易使用错误 swoole_process提供了比pcntl更强大的功能，更易用的API，使PHP在多进程编程方面更加轻松。 2.swoole_process提供了如下特性 swoole_process提供了基于unixsock的进程间通信，使用很简单只需调用write/read或者push/pop即可 swoole_process支持重定向标准输入和输出，在子进程内echo不会打印屏幕，而是写入管道，读键盘 输入可以重定向为*管道读取数据 配合swoole_event模块，创建的PHP子进程可以异步的事件驱动模式swoole_process提供了exec接口，创建的进程可以执行其他程序，与原PHP父进程之间可以方便的通信 3.创建进程：new swoole_process()函数原型：swoole_process::__construct(callable $function, $redirect_stdin_stdout = false, $create_pipe = true);参数： callable $function：子进程创建成功后要执行的函数，底层会自动将函数保存在对象的callback属性上，若要更改执行函数则可赋值新的函数在对象的callback属性。 $redirect_stdin_stdout：重定向子进程的标准输入输出，启动此选项后，子进程输出内容不是打印到屏幕而是写入主进程管道，读取键盘输入变成从管道中读取数据，默认为阻塞读取。 $create_pipe：是否创建管道，启动重定向后此项强制为1/true，如果子进程内没有进程间通信科设置为false。 管道类型：0/false =&gt; 不创建管道，1/true =&gt; 管道类型将设置为SOCK_STREAM(流式)，2 =&gt; 管道类型将设置为SOCK_DGRAM(数据包) 4.启动进程：swoole_process-&gt;start执行fork系统调用，启动进程函数原型：int swoole_process-&gt;start();返回参数：创建成功返回子进程的PID，创建失败返回false启动后可用属性： $process-&gt;pid属性为子进程的PID $process-&gt;pipe属性为管道的文件描述符 5.向管道写入数据：swoole_process-&gt;write函数原型：int swoole_process-&gt;write(string $data);参数：$data的长度在Linux系统下最大不超过8K，MacOS/FreeBSD下最大不超过2K父/子进程调用write，子/父进程可调用read接收数据同步模式：进程内未使用任何异步IO，则管道为同步阻塞模式，如果缓冲区满了，将阻塞直到write操作完成。如Task进程就是同步阻塞模式。异步模式：进程内使用了异步IO，如swoole_event_add(进程事件),进程内wirte操作变成异步模式，swoole底层会监听可写事件，自动完成管道写入。 6.从管道中读取数据：swoole_process-&gt;read函数原型：function swoole_process-&gt;read(int $buffer_size=8192) : string | bool; $buffer_size是缓冲区的大小，默认为8192，最大不超过64K 管道类型为DGRAM数据报(2)时，read可以读取完整的一个数据包 管道类型为STREAM(1/true)时，read是流式的，需要自行处理包完整性问题 读取成功返回二进制数据字符串，读取失败返回false 7.添加进程事件：异步IO，swoole_event_addswoole_event_add函数用于将一个socket加入到底层的reactor事件监听中。此函数可以用在Server或Client模式下。函数原型：bool swoole_event_add(int $sock, mixed $read_callback, mixed $write_callback = null, int $flags = null); int $sock：可以为一下三种类型1.int，就是文件描述符,包括swoole_client的socket,以及第三方扩展的socket（比如mysql）2.stream资源，就是stream_socket_client/fsockopen创建的资源3.sockets资源，就是sockets扩展中socket_create创建的资源，需要在编译时加入 ./configure –enable-sockets mixed $read_callback：可读回调函数 mixed $write_callback:可写事件回调，可以是字符串函数名、对象+方法、类静态方法或匿名函数，当此socket可读时回调指定的函数。 int $flags：事件类型的掩码，可选择关闭/开启可读可写事件，如SWOOLE_EVENT_READ，SWOOLE_EVENT_WRITE，或者SWOOLE_EVENT_READ | SWOOLE_EVENT_WRITE 8.创建同步进程123456789101112131415161718192021222324&lt;?php//创建进程对应的执行函数function doProcess(swoole_process $worker)&#123; var_dump($worker); echo &quot;\\n&quot;; echo &quot;PID : &quot;.$worker-&gt;pid.&quot;\\n&quot;; sleep(5);&#125;//创建进程 没有启动重定向$process = new swoole_process(&quot;doProcess&quot;);$pid = $process-&gt;start();//匿名函数创建进程(启动重定向)$process = new swoole_process(function (swoole_process $process) &#123; $process-&gt;write(&apos;Hello&apos;);&#125;, true);$process-&gt;start();sleep(10);echo $process-&gt;read(); //从管道输出//等待结束，关闭子进程(若不等待结束，容易出现僵尸进程)swoole_process::wait(); 将脚本上传至服务器并启动，可以看到，无重定向打印了$worker的内容和PID，重定向输出了Hello 9.创建异步进程因为子进程会继承父进程的内存和IO句柄，所以如果父进程要创建多个子进程，务必要等待创建完毕后再使用swoole_event_add/异步swoole_client/定时器/信号等异步IO函数。12345678910111213141516171819202122232425262728&lt;?php//进程池 存储进程$workers = []; //进程数量$worker_num = 3;//创建并启动进程for($i=0;$i&lt;$worker_num;$i++)&#123; $process = new swoole_process(&apos;doProcess&apos;); //创建单独新进程 $pid = $process-&gt;start(); //启动进程并获取进程ID $workers[$pid] = $process; //将进程存入进程池&#125;//编写进程执行函数function doProcess(swoole_process $process)&#123; $process-&gt;write(&quot;PID : (&quot;.$process-&gt;pid.&quot;)\\t CallbackFunction(&quot;.$process-&gt;callback .&quot;)&quot;.PHP_EOL); echo &quot;Write Msg : PID(&quot;.$process-&gt;pid.&quot;)\\t CallbackFunction(&quot;.$process-&gt;callback .&quot;)&quot;.PHP_EOL;&#125;//添加进程事件 向每个子进程添加需要执行的事件foreach ($workers as $process) &#123; //子进程也会包含此事件 swoole_event_add($process-&gt;pipe,function($pipe) use($process)&#123; $data = $process-&gt;read(); echo &quot;Receive Msg : &quot;.$data.PHP_EOL; &#125;);&#125;将脚本上传至服务器并启动，可以看到成功将PID和Callback函数写入管道并且读出来了","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"php项目","slug":"php项目","permalink":"https://harviealwayshere.github.io/tags/php项目/"},{"name":"swoole","slug":"swoole","permalink":"https://harviealwayshere.github.io/tags/swoole/"}]},{"title":"Swoole(八)同步TCP客户端","slug":"swoole8","date":"2018-02-18T12:06:51.000Z","updated":"2018-02-21T08:29:45.375Z","comments":true,"path":"2018/02/18/swoole8/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/18/swoole8/","excerpt":"","text":"创建一个TCP的同步客户端，可用于连接我们之前的实例TCP服务器 1.函数讲解1.建立TCP客户端对象：$client = new swoole_client(SWOOLE_SOCK_TCP);2.连接到服务器使用客户端对象的connect方法，参数分别为服务器$ip、服务器端口号$port和连接超时时间$time1$client-&gt;connect(&apos;127.0.0.1&apos;, 9501, 0.5);TCP需要进行3次握手，所以connect至少需要3次网络传输过程3.向服务器发送数据使用客户端对象的send方法，参数为字符串1$client-&gt;send(&quot;hello world&quot;);在发送少量数据时$client-&gt;send都是可以立即返回的。发送大量数据时，socket缓存区可能会塞满，send操作会阻塞。4.从服务器接收数据使用客户端对象的recv方法1$data = $client-&gt;recv();recv操作会阻塞等待服务器返回数据，recv耗时等于服务器处理时间+网络传输耗时之合。5.关闭连接1$client-&gt;close(); 这个客户端是同步阻塞的，connect/send/recv 会等待IO完成后再返回。同步阻塞操作并不消耗CPU资源，IO操作未完成当前进程会自动转入sleep模式，当IO完成后操作系统会唤醒当前进程，继续向下执行代码。 2.代码构建1234567891011121314151617181920212223&lt;?php$client = new swoole_client(SWOOLE_SOCK_TCP);//连接到服务器if (!$client-&gt;connect(&apos;0.0.0.0&apos;, 9501, 0.5))&#123; die(&quot;connect failed.&quot;);&#125;//向服务器发送数据if (!$client-&gt;send(&quot;hello world&quot;))&#123; die(&quot;send failed.&quot;);&#125;//从服务器接收数据$data = $client-&gt;recv();if (!$data)&#123; die(&quot;recv failed.&quot;);&#125;echo &quot;recv data is :&quot;.$data.&quot;\\n&quot;;//关闭连接$client-&gt;close();3.代码演示首先我们打开一个终端，执行一个tcp服务器的脚本之后我们上传tcp客户端脚本至服务器并运行，可以看到客户端连接服务器并发送数据成功，而且还接受到了服务器返回的数据，看看服务器端的反应证明客户端连接成功并且断开连接成功了","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"php项目","slug":"php项目","permalink":"https://harviealwayshere.github.io/tags/php项目/"},{"name":"swoole","slug":"swoole","permalink":"https://harviealwayshere.github.io/tags/swoole/"}]},{"title":"Swoole(七)异步TCP服务器","slug":"swoole7","date":"2018-02-18T11:14:06.000Z","updated":"2018-02-18T12:40:11.428Z","comments":true,"path":"2018/02/18/swoole7/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/18/swoole7/","excerpt":"","text":"Swoole提供了异步任务处理的功能，可以投递一个异步任务到TaskWorker进程池中执行，不影响当前请求的处理速度。在Server程序中如果需要执行很耗时的操作，比如一个聊天服务器发送广播，Web服务器中发送邮件。如果直接去执行这些函数就会阻塞当前进程，导致服务器响应变慢。 1.代码讲解1.创建TCP服务器：$serv = new swoole_server(“0.0.0.0”, 9501);2.设置异步任务的工作进程数1$serv-&gt;set(array(&apos;task_worker_num&apos; =&gt; 4));3.onReceive事件，用来投递异步任务，同时获取此次异步任务的ID12345//投递异步任务$serv-&gt;on(&apos;receive&apos;, function($serv, $fd, $from_id, $data) &#123; //获取此次异步任务的ID $task_id = $serv-&gt;task($data);&#125;);4.onTask事件，用来处理异步任务，同时返回任务执行的结果1234$serv-&gt;on(&apos;task&apos;, function ($serv, $task_id, $from_id, $data) &#123; //返回任务执行的结果 $serv-&gt;finish(&quot;$data -&gt; OK&quot;);&#125;);5.onFinish事件，用来处理异步任务的结果1234//处理异步任务的结果$serv-&gt;on(&apos;finish&apos;, function ($serv, $task_id, $data) &#123; &#125;);6.启动服务器，$serv-&gt;start(); 2.代码运行上传脚本代码至服务器并运行，再开启一个终端可以看到已经有4个额外的worker进程在运行我们把这个终端当作TCP客户端采用TCP方式连接服务器测试，并发送消息此时在另一个终端即TCP服务器端可以看到如下","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"php项目","slug":"php项目","permalink":"https://harviealwayshere.github.io/tags/php项目/"},{"name":"swoole","slug":"swoole","permalink":"https://harviealwayshere.github.io/tags/swoole/"}]},{"title":"Swoole(六)设置定时器","slug":"swoole6","date":"2018-02-18T08:26:36.000Z","updated":"2018-02-18T12:05:24.854Z","comments":true,"path":"2018/02/18/swoole6/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/18/swoole6/","excerpt":"","text":"swoole提供了类似JavaScript的setInterval/setTimeout异步高精度定时器，粒度为毫秒级。使用也非常简单。1.swoole_timer_tick相当于setInterval，是持续触发的函数原型：int $timer_id swoole_timer_tick(int $after_time_ms, mixed $callback function, mixed $user_param)参数： int $after_time_ms：指定触发的时间，单位为毫秒 mixed $callback function：执行的函数，参数有$timer_id mixed $user_param：用户参数返回值：int $timer_id，表示定时器ID 2.swoole_timer_after相当于setTimeout，仅在约定的时间触发一次函数原型：int $timer_id swoole_timer_after(int $after_time_ms, mixed $callback function, mixed $user_param)参数： int $after_time_ms：指定触发的时间，单位为毫秒 mixed $callback function：执行的函数 mixed $user_param：用户参数返回值：int $timer_id，表示定时器ID Tips：可以使用swoole_timer_clear(int $timer_id)清除定时器，参数为定时器ID 3.代码1234567891011&lt;?php//定时器 循环执行swoole_timer_tick(5000,function($timer_id)&#123; echo &quot;Tick 5s timer(ID:&quot;.$timer_id.&quot;) \\n&quot;;&#125;);//定时器 单次执行swoole_timer_after(3000,function($timer_id)&#123; echo &quot;After 3s timer(ID:&quot;.$timer_id.&quot;) \\n&quot;;&#125;);4.演示将脚本上传服务器后执行可看到如下结果","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"php项目","slug":"php项目","permalink":"https://harviealwayshere.github.io/tags/php项目/"},{"name":"swoole","slug":"swoole","permalink":"https://harviealwayshere.github.io/tags/swoole/"}]},{"title":"Swoole(五)配置WebSocket服务器","slug":"swoole5","date":"2018-02-16T12:21:49.000Z","updated":"2018-02-16T18:47:06.365Z","comments":true,"path":"2018/02/16/swoole5/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/16/swoole5/","excerpt":"","text":"接来下我们来学习配置一个WebSocket服务器1.首先介绍下什么是websocket初次接触 WebSocket 的人，都会问同样的问题：我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？答案很简单，因为 HTTP 协议有一个缺陷：通信只能由客户端发起。这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。一般有两种方法 AJAX轮询：让浏览器隔个几秒就发送一次请求，询问服务器是否有新信息。 Long Poll：原理跟AJAX轮询差不多，都是采用轮询的方式，不过采取的是阻塞模型，也就是说，客户端发起连接后，如果没消息，就一直不返回Response给客户端。直到有消息才返回，返回完之后，客户端再次建立连接，周而复始。 WebSocket协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。 2.Swoole实现Websocket服务端先上代码然后解释12345678910111213141516171819&lt;?php$ws = new swoole_websocket_server(&quot;0.0.0.0&quot;, 9504);$ws-&gt;on(&apos;open&apos;, function ($ws, $request) &#123; var_dump($request); $ws-&gt;push($request-&gt;fd,&quot;welcome to harvie&apos;s home !\\n&quot;)&#125;);$ws-&gt;on(&apos;message&apos;, function ($ws, $frame) &#123; echo &quot;receive from &#123;$frame-&gt;fd&#125;:&#123;$frame-&gt;data&#125;,opcode:&#123;$frame-&gt;opcode&#125;,fin:&#123;$frame-&gt;finish&#125;\\n&quot;; $ws-&gt;push($frame-&gt;fd, &quot;get it message !&quot;);&#125;);$ws-&gt;on(&apos;close&apos;, function ($ws, $fd) &#123; echo &quot;client &#123;$fd&#125; closed\\n&quot;;&#125;);$ws-&gt;start(); 3.代码解释1.构建websocket服务器对象：swoole_websocket_server($ip,$port)2.设置回调函数事件:2.1 open事件：建立连接事件， function (swoole_websocket_server $server, $request)，$server是服务器信息，$request是客户端信息2.2 message事件：接收消息事件，function (swoole_websocket_server $server, $request)，$server是服务器信息，$frame是客户端信息2.3 close：关闭连接事件，function (swoole_websocket_server $server, $fd)，$server是服务器信息，$frame是客户端信息2.4 使用swoole_websocket_server-&gt;push(int $fd, string $data, int $opcode = 1, bool $finish = true);向websocket客户端连接推送数据 $fd为客户端连接的ID $data为发送的数据内容 $opcode指定发送数据内容的格式，默认为文本。发送二进制内容$opcode参数需要设置为WEBSOCKET_OPCODE_BINARY $finish发送成功返回true，发送失败返回false3.启动服务器 4.测试运行将脚本上传到服务器并运行，打开浏览器，输入ip地址和端口号可以看到并不能成功访问，必须实现WebSocket协议才能和WebSocket服务器通信，我们创建一个前台websocket页面，代码如下12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=&quot;text/javascript&quot;&gt; var wsServer = &apos;ws://39.108.210.229:9504&apos;; var websocket = new WebSocket(wsServer); websocket.onopen = function (evt) &#123; console.log(&quot;连接成功&quot;); &#125;; websocket.onclose = function (evt) &#123; console.log(&quot;连接关闭&quot;); &#125;; websocket.onmessage = function (evt) &#123; console.log(&apos;从服务器接受到的数据为：&apos; + evt.data); &#125;; websocket.onerror = function (evt, e) &#123; console.log(&apos;错误发生信息: &apos; + evt.data); &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;然后放在我们Windows客户端下的Apache服务器下执行，可以打开浏览器看到此时我们可以看到服务器中打印了相关的请求信息","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"php项目","slug":"php项目","permalink":"https://harviealwayshere.github.io/tags/php项目/"},{"name":"swoole","slug":"swoole","permalink":"https://harviealwayshere.github.io/tags/swoole/"}]},{"title":"Swoole(四)配置Web服务器","slug":"swoole4","date":"2018-02-16T11:56:47.000Z","updated":"2018-02-16T18:25:40.553Z","comments":true,"path":"2018/02/16/swoole4/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/16/swoole4/","excerpt":"","text":"接来下我们来学习Swoole的基本函数，以此来配置一个Web服务器1.基本函数1.1 swoole_http_server：swoole_http_server继承自swoole_server，是一个完整的http服务器实现，支持同步和异步2种模式。函数原型：$http = new swoole_http_server($ip, $port); $ip：监听的ip $port：监听的端口 1.2 swoole_http_server-&gt;on:注册事件回调函数。swoole_http_server-&gt;on不接受onConnect/onReceive回调设置，swoole_http_server-&gt;on 额外接受1种新的事件类型onRequest123$http_server-&gt;on(&apos;request&apos;, function($request,$response) &#123; $response-&gt;end(&quot;&lt;h1&gt;hello swoole&lt;/h1&gt;&quot;);&#125;);在收到一个完整的Http请求后，会回调此函数。回调函数共有2个参数： $request：Http请求信息对象，包含了header/get/post/cookie等相关信息 $response：Http响应对象，支持cookie/header/status等Http操作 $response-&gt;end()：向客户端发送信息Tips：在onRequest回调函数返回时底层会销毁$request和$response对象，如果未执行$response-&gt;end()操作，底层会自动执行一次$response-&gt;end(“”) 2.构建基本的Web服务器1.构建swoole_http_server对象，设置监听对象为所有ip地址，端口为9503端口2.注册回调事件request，打印请求信息对象和返回Hello Swoole+一个随机数(证明每次访问返回不同)，$response-&gt;end()方法表示输出一段HTML内容，并结束此请求。3.启动服务器123456789$http = new swoole_http_server(&quot;0.0.0.0&quot;, 9503);$http-&gt;on(&apos;request&apos;, function ($request, $response) &#123; var_dump($request); $response-&gt;header(&quot;Content-Type&quot;, &quot;text/html; charset=utf-8&quot;); $response-&gt;end(&quot;&lt;h1&gt;Hello Swoole. #&quot;.rand(1000, 9999).&quot;&lt;/h1&gt;&quot;);&#125;);$http-&gt;start();我们先上传php脚本到服务器，之后执行然后我们使用浏览器访问服务器的ip地址，可以看到此时我们可以看到服务器会打印请求对象的信息我们再次刷新服务器可以看到随机数会变化","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"php项目","slug":"php项目","permalink":"https://harviealwayshere.github.io/tags/php项目/"},{"name":"swoole","slug":"swoole","permalink":"https://harviealwayshere.github.io/tags/swoole/"}]},{"title":"Swoole()配置UDP服务器","slug":"swoole3","date":"2018-02-16T09:23:01.000Z","updated":"2018-02-16T10:32:02.589Z","comments":true,"path":"2018/02/16/swoole3/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/16/swoole3/","excerpt":"","text":"接来下我们来学习Swoole的基本函数，以此来配置一个UDP服务器1.基本函数1.1 swoole_server-&gt;sendto：向任意的客户端IP:PORT发送UDP数据包。函数原型：bool swoole_server-&gt;sendto(string $ip, int $port, string $data, int $server_socket = -1); $ip:为IPv4字符串，如192.168.1.102。如果IP不合法会返回错误 $port:为 1-65535的网络端口号，如果端口错误发送会失败 $data:要发送的数据内容，可以是文本或者二进制内容 $server_socket服务器可能会同时监听多个UDP端口，此参数可以指定使用哪个端口发送数据包 2.构建基本的UDP服务器UDP服务器与TCP服务器不同，UDP没有连接的概念。启动Server后，客户端无需Connect，直接可以向Server监听的9502端口发送数据包。对应的事件为onPacket。构建步骤：1.创建swoole_server对象，注意$sock_type类型选择SWOOLE_SOCK_UDP2.注册监听事件，对应事件为Packet，回调函数类型为function ($serv, $data, $clientInfo)3.调用$server-&gt;sendto方法向客户端发送数据4.启动服务器 12345678910111213&lt;?php//创建Server对象，监听 0.0.0.0:9502端口，类型为SWOOLE_SOCK_UDP$serv = new swoole_server(&quot;127.0.0.1&quot;, 9502, SWOOLE_PROCESS, SWOOLE_SOCK_UDP); //监听数据接收事件$serv-&gt;on(&apos;Packet&apos;, function ($serv, $data, $clientInfo) &#123; $serv-&gt;sendto($clientInfo[&apos;address&apos;], $clientInfo[&apos;port&apos;], &quot;Server &quot;.$data); var_dump($clientInfo);&#125;);//启动服务器$serv-&gt;start(); 接下来我们上传文件到服务器并启动可以看到已经启动了，为了确保启动成功我们可以再开一个终端连接服务器查看进程接下来我们使用网络调试助手NetAssist来测试，上次使用windows自带的telnet感觉太鸡肋了，这个小工具简单好用，我下载的是V3.8.1，其实都大同小异","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"php项目","slug":"php项目","permalink":"https://harviealwayshere.github.io/tags/php项目/"},{"name":"swoole","slug":"swoole","permalink":"https://harviealwayshere.github.io/tags/swoole/"}]},{"title":"Swoole(二)配置TCP服务器","slug":"swoole2","date":"2018-02-14T17:55:02.000Z","updated":"2018-02-16T11:39:36.344Z","comments":true,"path":"2018/02/15/swoole2/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/15/swoole2/","excerpt":"","text":"接来下我们来学习Swoole的基本函数，以此来配置一个TCP服务器1.基本函数1.1 swoole_server：创建一个异步Server对象。函数原型：$serv = new swoole_server(string $host, int $port = 0, int $mode = SWOOLE_PROCESS, int $sock_type = SWOOLE_SOCK_TCP); $host:指定监听的ip地址IPv4使用 127.0.0.1表示监听本机，0.0.0.0表示监听所有地址IPv6使用::1表示监听本机，:: (相当于0:0:0:0:0:0:0:0) 表示监听所有地址 $port:监听的端口如果$sock_type为UnixSocket Stream/Dgram，此参数将被忽略监听小于1024端口需要root权限如果此端口被占用server-&gt;start时会失败 $mode:运行的模式SWOOLE_PROCESS多进程模式（默认）SWOOLE_BASE基本模式 $sock_type:指定Socket的类型支持TCP、UDP、TCP6、UDP6、UnixSocket Stream/Dgram 6种 1.2 swoole_server-&gt;on：注册Server的事件回调函数。函数原型：bool swoole_server-&gt;on(string $event, mixed $callback); $event:回调的名称connect：建立连接时receive：接收到数据时close：关闭连接时 $callback:回调的PHP函数，可以是函数名的字符串，类静态方法，对象方法数组，匿名函数。connect：function ($serv, $fd){} $serv:服务器信息 $fd:客户端信息receive：function ($serv, $fd, $from_id, $data){} $from_id:客户端ID $data:接收的数据close：function ($serv, $fd){} $serv:服务器信息 $fd:客户端信息 1.3 swoole_server-&gt;start：启动server，监听所有TCP/UDP端口。函数原型：bool swoole_server-&gt;start()启动成功后会创建:Master进程+Manager进程+serv-&gt;worker_num个Worker进程 Master进程:主进程内有多个Reactor线程，基于epoll/kqueue进行网络事件轮询。收到数据后转发到worker进程去处理 Manager进程:对所有worker进程进行管理，worker进程生命周期结束或者发生异常时自动回收，并创建新的worker进程 Worker进程:对收到的数据进行处理，包括协议解析和响应请求。 启动失败会立即返回false启动成功后将进入事件循环，等待客户端连接请求。start方法之后的代码不会执行服务器关闭后，start函数返回true，并继续向下执行 1.4 swoole_server-&gt;send：向客户端发送数据。函数原型：bool swoole_server-&gt;send(int $fd, string $data, int $extraData = 0); $data:发送的数据TCP协议最大不得超过2M，可修改buffer_output_size改变允许发送的最大包长度UDP协议不得超过65507，UDP包头占8字节, IP包头占20字节，65535-28 = 65507 UDP服务器使用$fd保存客户端IP，$extraData保存server_fd和port 发送成功会返回true发送失败会返回false，调用$server-&gt;getLastError()方法可以得到失败的错误码 2.构建基本的TCP服务器使用上述三个函数就可以构建出一个基本的TCP服务器了12345678910111213141516171819202122&lt;?php//创建Server对象，监听 0.0.0.0:9501端口$serv = new swoole_server(&quot;0.0.0.0&quot;, 9501); //监听连接进入事件$serv-&gt;on(&apos;connect&apos;, function ($serv, $fd) &#123; echo &quot;Client: Connect.\\n&quot;;&#125;);//监听数据接收事件$serv-&gt;on(&apos;receive&apos;, function ($serv, $fd, $from_id, $data) &#123; $serv-&gt;send($fd, &quot;Server: &quot;.$data);&#125;);//监听连接关闭事件$serv-&gt;on(&apos;close&apos;, function ($serv, $fd) &#123; echo &quot;Client: Close.\\n&quot;;&#125;);//启动服务器$serv-&gt;start(); 之后我们把tcpServer.php上传到服务器上在服务器端运行这个脚本我们可以再次连接服务器，通过查看进程确认脚本是否执行首先可以看到有一个进程-bash在使用一个子进程ps -ajft查看进程，这个bash就是我们连接服务器的进程然后可以看到有一个进程-bash有三个子进程在执行，可以看出分别是Master进程(32680)、Manager进程(32681)和Worker进程(32683)此时我们可以通过客户端使用网络工具来连接服务器（x为ip地址，y为端口号），我使用的是windows自带的telnet服务，具有TCP连接功能，如何开启请看这里可以看到成功连接并且实现了向客户端返回数据的功能，若是无法正常连接，可能有如下三种原因 在Linux下，使用netstat -an | grep 端口或者lsof -i:9501，查看端口是否已经被打开处于Listening状态，若处于可以看看是什么哪个进程在使用这个端口，并用kill -9 进程号(PID)，结束这个进程重新开放端口 上一步确认后，检查防火墙问题，最好使用命令systemctl stop firewalld.service 注意服务器所使用的IP地址，如果是127.0.0.1回环地址，则客户端只能使用127.0.0.1才能连接上 若是阿里云服务器，记得在阿里云控制台中安全组设置开放外界端口号 这时我们的基本的tcp服务器就已经搭建好了，若需要关闭这个进程，可以使用kill -9 进程号关闭掉Master的父进程-bash(32618)即可，此时再使用ps -ajft和netstat -an | grep 9501，可看到进程结束并且端口不再处于监听状态即可 我们搭建基本tcp服务器的过程就结束了，接下来我们将会学习如何搭建别的类型服务器，如UDP、Web、Websocket、异步TCP，还有一些队列通信、信号触发、DNS查询、异步文件IO、异步mysql等。","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"php项目","slug":"php项目","permalink":"https://harviealwayshere.github.io/tags/php项目/"},{"name":"swoole","slug":"swoole","permalink":"https://harviealwayshere.github.io/tags/swoole/"}]},{"title":"Swoole(一)安装","slug":"swoole1","date":"2018-02-09T16:29:04.000Z","updated":"2018-02-09T17:55:49.101Z","comments":true,"path":"2018/02/10/swoole1/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/10/swoole1/","excerpt":"","text":"说到PHP异步网络通信框架，相信PHPer脑海里第一个浮现的便是Swoole。 商业应用：IM聊天、战旗TV、虎牙直播、YY语音等。 应用领域：互联网、网络通信、企业软件、云计算、网络游戏、物理网等。 特点：1.异步、并行、高性能2.纯C编写，接近应用底层3.php扩展 应用：1.异步多线程服务器及客户端2.异步MySQL、Redis、数据库连接池、任务队列3.http/websocket服务器/客户端4.异步文件读写5.Swoole2.0支持协程 安装Swoole大致可分成3个步骤:1.搭建Linux操作系统2.安装环境依赖(php,gcc,httpd，pecl)3.安装Swoole并修改php.ini Part1:搭建Linux操作系统查看官方文档可知Swoole并不支持Windows系统，所以我们这里搭建一个CentOS 7.3 64位的操作系统，我是使用阿里云云服务器 ECS搭建的，使用系统盘安装即可，安装完毕之后可以远程连接进入云服务器中的Linux系统中Tips:如果想在Windows下便捷操作云服务器的系统，推荐使用SSH连接软件，这里我使用的是SSH Secure Shell Client3.2.9，安装完成后有两个工具可以使用，分别对应Linux系统的命令行界面和Linux文件系统的GUI界面的，十分便捷客观，提供工作效率。可参考这篇博客安装使用。连接成功后的界面为 Part2:安装环境依赖(php,gcc,httpd，pecl)在CentOS中使用yum安装php7，由于初始yum所安装的php版本是5.*的，我们首先要获取php7的yum源1234567891011//1.安装epel-releaseyum -y install epel-release //2.获取php7的yum源rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm//3.安装php7yum install php70w//4.验证安装php -v安装完成后可看到php版本之后我们要安装gcc和httpd1yum install httpd gcc最后我们要安装pecl，因为swoole项目已收录到PHP官方扩展库，可直接使用pecl安装swoole12wget http://pear.php.net/go-pear.pharphp go-pear.phar Part3:安装Swoole并修改php.ini1sudo pecl install swoole 会报错如下，别着急输入1vi `which pecl`进入Linux的Vim编辑模式，一直向下查找找到这个文件的最后一行按I进入Vim的插入模式，之后将-n标志去掉，按ESC进入Vim的退出(末行)模式，输入[:wq!]保存并退出之后安装 php-devel1sudo yum install php70w-devel再次安装swoole1sudo pecl install swoole成功安装！根据提示要添加”extension=swoole.so”在php配置文件php.ini中，我这里由于对于Vim的操作并不熟悉，我直接通过SSH软件将php.ini文件拉取到本地之后修改再上传到服务器php.ini一般在/etc目录下拉取到本地后添加”extension=swoole.so”语句，随意在任何两个配置语句中增加之后通过语句[php -m]可查看php拓展安装情况，如果看到swoole则安装成功！ 如果你实践完成了本教程，意味着你对于Linux和Windows系统的协同开发、php拓展安装已经了解了基本情形了，接下来我们将使用swoole开发php应用，敬请期待。","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"php项目","slug":"php项目","permalink":"https://harviealwayshere.github.io/tags/php项目/"},{"name":"swoole","slug":"swoole","permalink":"https://harviealwayshere.github.io/tags/swoole/"}]},{"title":"剑指Offer基础知识(一)数据结构","slug":"offer","date":"2018-02-07T08:20:05.000Z","updated":"2018-03-09T03:32:17.060Z","comments":true,"path":"2018/02/07/offer/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/07/offer/","excerpt":"","text":"本文主要记录阅读剑指Offer这本书所遇到的算法解释并作一些个人的拓展，其中的算法面试题请看剑指Offer面试题集 第二章2.2.1 关于sizeof的小知识 sizeof 对于空类型(无成员变量和成员函数)的实例 = 1字节：由于声明空类型的实例必须在内存中占用一定空间否则无法使用，占用多少内存由编译器决定，在VS中每个空类型实例占用1字节。 sizeof 对于空类型+构造和析构函数的实例 = 1字节 ：调用函数只需知道函数地址即可，函数地址只与类型有关而与类型的实例无关，因此sizeof实例还是1字节。 sizeof 对于空类型+构造函数+虚析构函数(虚函数) = 1个指针大小：一个类型中有虚拟函数就会为该类型生成虚函数表，并为这个类型的每个实例中添加一个指向虚函数表的指针，指针大小与机器有关，32为指针为4字节，64位指针为8字节。1234567891011121314151617181920212223242526class B //空类型&#123;&#125;;class C //空类型+构造和析构函数&#123;public: C()&#123;&#125;; ~C()&#123;&#125;;&#125;;class D //空类型+构造函数+虚析构函数(虚函数)&#123;public: D()&#123;&#125;; virtual ~D()&#123;&#125;;&#125;;int main()&#123; B b; C c; D d; cout &lt;&lt; &quot;空类型大小:&quot; &lt;&lt; sizeof(b)&lt;&lt;endl; cout &lt;&lt; &quot;空类型+构造和析构函数大小:&quot; &lt;&lt; sizeof(c) &lt;&lt; endl; cout &lt;&lt; &quot;空类型+构造函数+虚析构函数(虚函数)大小:&quot; &lt;&lt; sizeof(d) &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 总结：空的类是会占用内存空间的，而且大小是1，原因是C++要求每个实例在内存中都有独一无二的地址。 类内部的成员变量：*普通的变量：是要占用内存的，但是要注意对齐原则（这点和struct类型很相似）。*static修饰的静态变量：不占用内容，原因是编译器将其放在全局变量区。 类内部的成员函数：*普通函数：不占用内存。*虚函数：要占用4个字节，用来指定虚函数的虚拟函数表的入口地址。所以一个类的虚函数所占用的地址是不变的，和虚函数的个数是没有关系的 2.2.1 关于复制函数的小知识C++标准不允许复制构造函数传值参数，否则会造成递归重复调用，编译错误。12345678910111213141516171819202122232425262728293031323334353637383940class E&#123;private: int num;public: //构造函数 E(int x) :num(x) &#123; cout &lt;&lt; &quot;constructor call&quot; &lt;&lt; endl; &#125; //复制构造函数 传引用调用 E(E&amp; x) &#123; num = x.num; cout &lt;&lt; &quot;copy constructor call&quot; &lt;&lt; endl; &#125; //赋值运算符重载 E&amp; operator = (E&amp; x) &#123; num = x.num; cout &lt;&lt; &quot;assignment operator call&quot; &lt;&lt; endl; return *this; &#125; //函数调用 void showNum(E x) &#123; &#125; &#125;;int main()&#123; E a(1); //1式 E b(2); //2式 b = a; //3式 E c = a; //4式 c.showNum(a); //5式 system(&quot;pause&quot;); return 0;&#125;运行结果如图： 1/2式 =&gt; 若是实例创建并初始化时调用相应参数的构造函数 3式 =&gt; 若是实例已经创建初始化后再用=赋值，则调用=重载赋值函数 4式 =&gt; 若是实例用另一个同类实例初始化，则调用复制构造函数 5式 =&gt; 若是实例使用方法调用另一个实例，则首先调用复制构造函数将实参复制给形参后执行相关操作 因此就可以解释为什么C++不允许复制构造函数传值了，若是传值，则调用E c = a或者c.showNum(a)或者的时候，a作为参数传值给c的复制构造函数的参数E x，因为x没有被初始化，所以要调用x的复制构造函数将a复制给x，即x.E(a)，然而x的复制构造函数也是传值的，因此又要将a作为参数传值给c的复制构造函数的参数x的复制构造函数的参数E x，又因为这个x也没有被初始化，又要调用这个x的复制构造函数，造成了无限的递归。因此复制构造函数的参数使用引用调用不是为了减少一次内存的复制，而是为了避免复制构造函数无限递归调用的情况出现。下面这几种情况下会调用复制构造函数:（1）显式或隐式地用同类型的一个对象来初始化另外一个对象。如上例中的E c=a;（2）作为实参传递给一个函数。如上例中的c.showNum(a);（3）在函数体内返回一个对象时，也会调用返回值类型的拷贝构造函数（4）初始化序列容器中的元素时。比如vector svec(5)，string的缺省构造函数和拷贝构造函数都会被调用。（5）用列表的方式初始化数组元素时。string a[] = {string(“hello”),string(“world”)};会调用string的拷贝构造函数。 2.3 数组和指针区别输出 “20,4,4”20：data1是一个数组，包含五个整数，每个整数占4字节，一共20字节4：data2是一个指针指向data1数组的第一个数字，指针大小为4字节4：在C/C++中数组作为参数传递时自动退化为同类型的指针，因此为4字节 2.3.2字符串小知识C/C++中每个字符串以’/0’作为结尾，这样可以方便地找到字符串的结尾，但有额外字符开销，易越界。C/C++将常量字符串放到一个单独的内存区域节省内存，当几个指针赋值给相同的常量字符串时，他们实际上会指向相同的内存地址，但是用常量内存初始化数组却会创建新空间。 2.3.3 链表小知识链表是由指针把若干个节点连接成链状结构，链表的创建、插入节点、删除节点等操作只需要20行代码就可以实现，比较适合面试。链表是一种动态结构，创建时无需知道链表的长度，每添加一次节点再分配新内存，然后调整指针的指向。单向链表的节点定义如下12345struct ListNode&#123; int Value; ListNode* Next;&#125;往链表末尾添加一个节点的函数如下要点：1.头指针的传参 2.插入的节点是第一个节点的情况(空链表/头指针为空)1234567891011121314151617181920void addToTail(ListNode** pHead, int value) //由于头指针可能改变，因此要以传指针的形式传参，否则出了函数头指针依然是空指针&#123; ListNode* pNew = new ListNode(); pNew-&gt;Value = value; pNew-&gt;Next = NULL; //注意新节点的Next初始化为NULL if(*pHead == NULL) //若是往一个空链表插入节点，则头指针指向新节点 &#123; *pHead = pNew; &#125; else //否则找到头指针指向第一个节点，开始遍历找到最后一个节点，将节点的Next指向新节点 &#123; ListNode* pNode = *pHead; while(pNode-&gt;Next != NULL) pNode = pNode-&gt;Next; pNode-&gt;Next = pNew; &#125;&#125;在链表中找到第一个含有某值的节点并删除该节点的函数如下要点：123456789101112131415161718192021222324252627282930void removeNode(ListNode** pHead, int value)&#123; if(pHead == NULL || *pHead == NULL) //空链表直接返回 return; ListNode* pToBeDelete = NULL; //找到需要删除的节点 if((*pHead)-&gt;Value == value) //当第一个节点是需要删除的节点，则需要改变头指针的指向 &#123; pToBeDelete = *pHead; *pHead = (*pHead)-&gt;Next; &#125; else //否则开始遍历节点 &#123; ListNode* pNode = *pHead; while(pNode-&gt;Next != NULL &amp;&amp; pNode-&gt;Next-&gt;Value != value) //遍历到最后一个节点或者找到需要删除的节点的前一个节点则停止遍历 pNode = pNode-&gt;Next; if(pNode-&gt;Next != NULL &amp;&amp; pNode-&gt;Next-&gt;Value ==value) //找到需要删除的节点的前一个节点 &#123; pToBeDelete = pNode-&gt;Next; pNode-&gt;Next = pNode-&gt;Next-&gt;Next; //这里包含了当需要删除的节点是最后一个节点的情况，若是最后一个节点则它的前一个节点会指向NULL &#125; &#125; if(pToBeDelete != NULL) &#123; delete pToBeDelete; pToBeDelete = NULL; &#125;&#125; 2.3.4 树小知识树是一种数据结构: 除了根节点外每个节点只有一个父节点，根节点没有父节点 除了叶节点外每个节点有一个或多个子节点，叶节点没有子节点 父节点与子节点之间用指针连接 二叉树：树的特殊结构，每个节点最多有两个子节点遍历方式： 前序：根-左-右 中序：左-根-右 后序：左-右-根 宽度优先：按照层的顺序从顶到底遍历，同一层的节点按从左到右遍历 二叉搜索树：左节点小于等于根节点，右节点大于等于根节点的二叉树堆：最大堆中根节点的值最大，最小堆中根节点的值最小红黑树：把树中的节点定义为红、黑两种颜色，并通过规则确保从根节点到叶节点的最长路径的长度不超过最短路径的两倍，C++中STL中set、multiset、map、multimap等数据结构都是基于红黑树实现的 2.3.5 栈和队列小知识栈：先进先出，即最后入栈(push)的元素会第一个被弹出(pop)队列：先进先出，即第一个进入队列的元素会第一个出来","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://harviealwayshere.github.io/tags/数据结构/"},{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://harviealwayshere.github.io/tags/剑指Offer/"}]},{"title":"C++基础语法","slug":"cplusplus","date":"2018-01-31T07:31:56.000Z","updated":"2018-02-07T08:09:25.136Z","comments":true,"path":"2018/01/31/cplusplus/","link":"","permalink":"https://harviealwayshere.github.io/2018/01/31/cplusplus/","excerpt":"","text":"刚想刷剑指offer和leetcode上的题目，本来享用python写的，毕竟是刷算法感觉无论是什么语言总是相通的，但看到剑指offer上写到 大一学的C++基础语法都忘记的差不多了，还是先来巩固一下C++基础语法，本文以runoob和C++ Primer(第五版)为基础编写。 Part1：C++基础语法标准的 C++ 由三个重要部分组成： 核心语言，提供了所有构件块，包括变量、数据类型和常量，等等。 C++ 标准库，提供了大量的函数，用于操作文件、字符串等。 标准模板库（STL），提供了大量的方法，用于操作数据结构等。 C++面向对象四大特点:封装、抽象、继承和多态。 C++基本程序结构：12345678#include &lt;iostream&gt; //添加头文件using namespace std; //使用std命名空间 int main() //主函数，程序执行入口&#123; cout &lt;&lt; &quot;Hello World&quot;; // 输出 Hello World return 0; //终止main函数并返回0值&#125; C++内置数据类型：类型&emsp;&emsp;&emsp;&emsp;关键字&emsp;&emsp;&emsp;&emsp;内存(字节)布尔型 &emsp;&emsp;&emsp;bool&emsp;&emsp;&emsp;&emsp;&emsp;1字符型 &emsp;&emsp;&emsp;char&emsp;&emsp;&emsp;&emsp;&emsp;1整型 &emsp;&emsp;&emsp;&emsp;int&emsp;&emsp;&emsp;&emsp;&emsp;&nbsp;&nbsp;&nbsp;4浮点型 &emsp;&emsp;&emsp;float&emsp;&emsp;&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;4双浮点型 &emsp;&emsp;double&emsp;&emsp;&emsp;&emsp;8无类型 &emsp;&emsp;&emsp;void&emsp;&emsp;&emsp;&emsp;&emsp;宽字符型 &emsp;&emsp;wchar_t&emsp;&emsp;&emsp;&nbsp;&nbsp;4一些类型可用修饰符修饰:signed,unsigned,short,long.Tip:其实知道了字节数很简单计算范围，1字节=8位，每位存储一个二进制0/1，有几位二进制则可以存储2^位数范围大小的数字。Tip:存储有符号数的时候，例如int，虽然是4字节的，但是只能是1符号位+31数值为位，所以最大为2^31=2147483647。可以使用typedef为一个已有的类型取一个新的名字:typedef type newname;12typedef int SSS;SSS a = 2; 枚举类型(enumeration)：是C++中的一种派生数据类型，它是由用户定义的若干枚举常量的集合:语法为:enum name {IDentifier0[=int 0],IDentifier1=[int 1]} Variable;12enum color &#123; red, green, blue &#125; c; //定义变量c是枚举类型colorc = blue; //c赋值为blue 变量声明和定义:您可以使用extern关键字在任何地方声明一个变量。虽然您可以在 C++ 程序中多次声明一个变量，但变量只能在某个文件、函数或代码块中被定义一次。123456789101112// 变量声明extern int a; //可进行多次int main ()&#123; // 变量定义 //仅可进行一次 int a; // 实际初始化 a = 10; return 0;&#125; 函数声明和定义:在函数声明时，提供一个函数名，而函数的实际定义则可以在任何地方进行。1234567891011121314// 函数声明int func();int main ()&#123; // 函数调用 int i = func(); return 0;&#125;// 函数定义int func()&#123; return 666;&#125; 变量作用域: 在函数或一个代码块内部声明的变量，称为局部变量。 在函数参数的定义中声明的变量，称为形式参数。 在所有函数外部声明的变量，称为全局变量。 初始化:定义全局变量时，系统会根据数据类型自动初始化；定义局部变量时，系统不会自动初始化。 C++常量:定义后不能进行修改的固定值。整数常量: 前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制 后缀指定修饰符:是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。 浮点常量：由整数部分、小数点、小数部分和指数部分组成。 小数形式：必须包含整数部分、小数部分，或同时包含两者。 指数形式：必须包含小数点、指数，或同时包含两者。带符号的指数是用 e 或 E 引入的。 布尔常量：true/false字符常量：括在单引号中的可以是一个普通的字符（例如 ‘x’）、一个转义序列（例如 ‘\\t’），或一个通用的字符（例如 ‘\\u02C0’）。 宽字符常量：以 L（仅当大写时）开头存储在 wchar_t 类型的变量中（例如 L’x’）。 窄字符常量：存储在 char 类型的简单变量中（例如 ‘x’）。 字符串常量：括在双引号 “” 中的。一个字符串包含类似于字符常量的字符：普通的字符、转义序列和通用的字符。C++有两种简单定义常量方式: 使用 #define 预处理器:#define identifier value 使用 const 关键字:const type variable = value; Tips:常量一般被定义成大写字母形式 C++ 修饰符类型修饰符 signed、unsigned、long 、short可应用于整型，signed 和 unsigned可应用于字符型，long 可应用于双精度型。修饰符 signed 和 unsigned 也可以作为 long 或 short 修饰符的前缀。例如：unsigned long int。 C++ 类型限定符用于限定类型和类型成员的声明 const：限定对象在程序执行期间不能被修改改变。 volatile：限定变量的值可能以程序未明确指定的方式被改变。(多线程使用) C++ 存储类存储类定义 C++ 程序中变量/函数的范围（可见性）和生命周期，常有auto、static、extern、mutable、thread_local (C++11)。auto关键字用于两种情况： 声明变量时根据初始化表达式自动推断该变量的类型。 声明函数时函数返回值的占位符。1234auto f=3.14;cout&lt;&lt;typeid(f).name()&lt;&lt;endl; //doubleauto z = new auto(9); cout&lt;&lt;typeid(z).name()&lt;&lt;endl; // int* static关键字指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。 static修饰局部变量：变量在全局数据区分配内存，程序执行第一次时首次初始化，以后函数调用不再进行初始化，没有显式初始化则会被自动初始化为0。 static修饰全局变量：使变量的作用域限制在声明它的文件内。 static修饰类的成员变量：类外初始化，先于类存在，类所有对象共同一个静态成员变量，可通过类名直接调用公共(public)静态成员变量。123456789101112131415class A&#123;public: A()&#123; count++; &#125; //先于类存在，在类的构造方法中已经可以调用 static int count;&#125;;int A::count = 0; //类外初始化int main()&#123; A c; A d; cout &lt;&lt; A::count &lt;&lt; endl; //共用性和直接类名调用 system(&quot;pause&quot;); return 0;&#125; static修饰类的成员方法:先于类存在，方法中不能使用非静态成员(无this指针),可通过类名直接调用公共(public)静态成员方法。12345678910111213141516171819class A&#123;public: A()&#123; count++; &#125; static int count; static void showCount() &#123; cout &lt;&lt; &quot;count is &quot; &lt;&lt; count &lt;&lt; endl; //不用this指针织带变量 &#125;&#125;;int A::count = 0; int main()&#123; A c; A d; A::showCount(); //类名直接调用 system(&quot;pause&quot;); return 0;&#125; C++ 运算符运算符是一种告诉编译器执行特定的数学或逻辑操作的符号,有算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符和其他运算符。算数运算符:+、-、、/、%(取模,整除后的余数)、++(自增)、–(自减).关系运算符:==、!=、&gt;、&lt;、&gt;=、&lt;=.逻辑运算符:&amp;&amp;(逻辑与，均非零为真)、||(逻辑或，存在非零则为真)、!(逻辑非，逆转逻辑状态).Tips:&amp;&amp;(||)具有短路功能，即若第一个条件为false(true)，则不再计算第二个表达式；&amp;(|)则无论如何均会计算两个表达式.利用这点可将A&amp;&amp;B中的A作为一个条件语句(if)不满足则不执行B，如下1234567891011121314151617/*不用任何循环语句，不用if，来实现1+2+3+...+10的值*/#include &lt;iostream&gt;using namespace std;int add(int c)&#123; int a=0; c&amp;&amp;(a=add(c-1));//递归循环，直到传入c的值为0则结束循环不执行右式 //(用&amp;则会执行造成溢出错误) cout&lt;&lt;c+a&lt;&lt;endl; return c+a;&#125;int main()&#123; add(10); return 0;&#125;位运算:若A = 60，且 B = 13，以二进制表示如下A = 0011 1100B = 0000 1101赋值运算:=、+=、-=、=、/=、%=、&lt;&lt;=、&gt;&gt;=、&amp;=(按位与或且赋值)、^=(按位异或且赋值)、|=(按位或且赋值)杂项运算: C++ 循环 while:1234while(condition)&#123; statement(s);&#125; for:1234for ( init; condition; increment )&#123; statement(s);&#125; do…while:12345do&#123; statement(s);&#125;while( condition ); 循环控制语句: break：跳出循环。 continue:跳过循环主体的剩余部分，立即重新开始测试条件。 C++ 判断 if:1234if(boolean_expression)&#123; statement(true); // 如果布尔表达式为真将执行的语句&#125; if…else:12345678if(boolean_expression)&#123; statement(true); // 如果布尔表达式为真将执行的语句&#125;else&#123; statement(false); // 如果布尔表达式为假将执行的语句&#125; switch:123456789101112switch(expression)&#123; case constant-expression : statement(s); break; // 可选的 case constant-expression : statement(s); break; // 可选的 // 您可以有任意数量的 case 语句 default : // 可选的 statement(s);&#125; [ ? : ]运算符:1Exp1 ? Exp2 : Exp3; C++ 函数函数声明包含函数的名称、返回类型和参数C++中的函数声明形式：1return_type function_name( parameter list );函数定义提供了函数的实际主体。C++中的函数定义形式：1234return_type function_name( parameter list )&#123; body of the function&#125;函数参数:函数内使用的局部变量称作形式参数，有三种调用方式 传值调用(默认)：把参数的实际值复制给形式参数。在这种情况下，修改函数内的形式参数不会影响实际参数。 指针调用：把参数的地址复制给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。修改形式参数会影响实际参数。如函数声明:void swap(int *x, int *y)函数调用:swap(&amp;a,&amp;b) 引用调用：把参数的引用赋值给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。如函数声明:void swap(int &amp;x, int &amp;y)函数调用:swap(a,b) 参数默认值:定义函数时可以为参数列表中每一个参数指定默认值,如int sum(int a=10,int b=20)Lambda 函数与表达式:Lambda 表达式把函数看作对象。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。 C++ 数字数学运算:引用数学头文件 内有许多内置数学函数随机数:标准库（被包含于中）提供两个帮助生成伪随机数的函数 void srand(unsigned seed)：设置随机数种子，通常用time()初始化(使用time需要引入头文件)，如srand( (unsigned)time( NULL ) ); int rand(void)：从srand (seed)中指定的seed开始，返回一个[seed, RAND_MAX（0x7fff）)间的随机整数。 指定生成范围的随机数1234(low,up) (rand()%(up-low+1)) + low - 1[low,up) (rand()%(up-low)) + low(low,up] (rand()%(up-low))+ low + 1[low,up] (rand()%(up-low+1)) + low C++ 数组声明数组:type arrayName [ arraySize ];初始化数组:type arrayName [ arraySize ] = { data } ;访问数组元素:数组名称+索引，arrayName[index];数组详解: 多维数组:type arrayName[size1][size2]…[sizeN]; 数组指针:声明的数组名其实是指向数组第一个元素的指针，即*arrayName == &amp;arrayName[0]所以也可以使用指针形式访问数组*(arrayName + i ) == arrayName[i] 传递数组给函数:是以指针的形式传递的，因此有三种传递方式：(type *param)(type param[size])(type param[]) 函数返回数组:数组以指针的形式返回的，另外C++不支持在函数外返回局部变量的地址，因此返回的数组需要均是static变量 C++ 字符串 C风格字符串:实质是一个以’\\0’(null)结尾的char数组，例如123//以下msg1和msg2初始化规则相同char msg1[6] = &#123;&apos;H&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, &apos;o&apos;, &apos;\\0&apos;&#125;;char msg2[] = &quot;Hello&quot;; C++有大量函数操作以null结尾的字符串： C++引入的 string 类类型:C++标准库提供了string类型(需引入#include &lt; string >库)且支持上述函数操作1234string str1 = &quot;Hello&quot;;string str2 = str1; //复制string str3 = str1 + str2; //连接int length = str3.size(); //长度 C++ 指针 内存地址:每个C++变量都有一个内存地址，可用寻址（&amp;）运算符访问变量的内存地址 指针:是一个特殊的变量，其值为另一个变量的内存地址，声明形式为:type *var-name; 使用指针:过程一般为声明、存储、访问（对指针使用间址(*)运算符可访问指针存储地址的变量值）12345678string str = &quot;Hello&quot;;string *ip;ip = &amp;str;cout &lt;&lt; &quot;Address of str : &quot; &lt;&lt; &amp;str &lt;&lt; endl;cout &lt;&lt; &quot;Value of str : &quot; &lt;&lt; str &lt;&lt; endl;cout &lt;&lt; &quot;Stored Address of ip : &quot; &lt;&lt; ip &lt;&lt; endl; //指针存储的变量的地址cout &lt;&lt; &quot;Address of ip : &quot; &lt;&lt; &amp;ip &lt;&lt; endl; //指针本身的地址cout &lt;&lt; &quot;Value of ip : &quot; &lt;&lt; *ip &lt;&lt; endl; 执行结果如下: Null指针:指针初始化时指定NULL值被称作空指针可以避免越界使用指针1type *ptr = NULL; 指针的算数运算:指针是一个用数值表示的地址，可以执行四种算数运算（++，–，+，-）具体运算数值与指针的类型有关(如整形指针一次递增4个字节，字符指针一次递增1个字节等) 指针与数组的异同:（同）均可通过指针的算数运算和数组索引来访问数组（异）声明数组的数组名的指针是一个指向数组第一个元素地址的常量指针，不可改变指向的地址 指针数组:可声明一个数组来存放指针，其中每个数组元素都是一个指针，如type *ptr[size]; 多级指针:一个指针指向另一个指针的地址123type var;type *ptr1 = &amp;var;type *ptr2 = &amp;ptr1; //ptr2就是一个多级指针指向一级指针ptr1 指针参数:声明函数参数为指针类型即可，这种属于指针调用函数参数，将参数地址复制给函数的形式参数，在函数内修改形式参数会影响实际参数。 函数返回指针类型:声明函数返回类型为指针类型即可，但由于C++不支持在函数外返回局部变量的地址，因此可返回指针类型的变量需要声明为static变量。 C++ 引用引用变量是一个实际变量的别名。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。 引用于指针的区别:1.引用必须在创建时初始化，指针可以在任何时间初始化。2.引出初始化为一个对象后不能更改，指针可以在任何时候指向另一个对象。3.不存在空引用，引用必须连接到一个合法内存。 引用创建初始化使用:type&amp; name = variable; 引用参数:声明函数参数为引用类型即可，属于引用调用的函数参数。这比传一般参数安全。 函数返回引用类型:声明函数返回类型为引用类型，但是实际上函数返回一个引用时是返回一个指向返回值的隐式指针，这样函数可以放在赋值语句的左边。返回引用最大的好处是在内存中不产生被返回值的副本，节省内存，但是不能返回局部变量的引用。 C++ 日期和时间C++继承了C语言用于日期和时间操作的结构和函数,需要引入 &lt; ctime > 头文件 有四个与时间有关的类型，其中clock_t、time_t、size_t 将系统时间和日期表示为某种整数，tm结构类型将日期和时间以C结构形式保存。 C/C++中关于日期和时间的重要函数:1.time(): 返回从 1970-01-01 到 当前的日历时间的秒数123//函数原型:time_t time(time_t *t)time_t nowSeconds = time(NULL);cout &lt;&lt; nowSeconds &lt;&lt; endl; 2.ctime():返回一个格式为[Www Mmm dd hh:mm:ss yyyy]基于参数timer的时间的字符串1234//函数原型:char *ctime(const time_t *timer)#pragma warning(disable:4996) //接触安全警报限制time_t curtime = time(NULL);cout &lt;&lt; ctime(&amp;curtime) &lt;&lt; endl; 3.localtime(): struct tm *localtime(const time_t *timer)，将参数timer的值分解为tm结构，并用本地时区表示12345678910//函数原型:struct tm *localtime(const time_t *timer)#pragma warning(disable:4996) //接触安全警报限制time_t curtime = time(NULL);struct tm *info = localtime(&amp;curtime);cout &lt;&lt; &quot;tm_sec:&quot; &lt;&lt; info-&gt;tm_sec &lt;&lt; endl;cout &lt;&lt; &quot;tm_min:&quot; &lt;&lt; info-&gt;tm_min &lt;&lt; endl;cout &lt;&lt; &quot;tm_hour:&quot; &lt;&lt; info-&gt;tm_hour &lt;&lt; endl;cout &lt;&lt; &quot;tm_mday:&quot; &lt;&lt; info-&gt;tm_mday &lt;&lt; endl;cout &lt;&lt; &quot;tm_mon:&quot; &lt;&lt; info-&gt;tm_mon &lt;&lt; endl;cout &lt;&lt; &quot;tm_year:&quot; &lt;&lt; info-&gt;tm_year &lt;&lt; endl; 4.clock(): 返回程序执行起处理器时钟所使用的时间，为了获取CPU所使用秒数需要除以CLOCKS_PER_SEC常量12345678910111213//函数原型:clock_t clock(void)#pragma warning(disable:4996) //接触安全警报限制clock_t start_t, end_t;start_t = clock();cout &lt;&lt; &quot;程序启动：&quot; &lt;&lt; start_t &lt;&lt; endl;for(int i=0; i&lt; 10000000; i++)&#123;&#125;end_t = clock();cout &lt;&lt; &quot;程序结束：&quot; &lt;&lt; end_t &lt;&lt; endl;double total_t;total_t = (double)(end_t - start_t) / CLOCKS_PER_SEC;cout &lt;&lt; &quot;CPU占用时间:&quot; &lt;&lt; total_t &lt;&lt; endl; 5.asctime()：返回一个基于timeptr的时期和时间的字符串的指针12345//函数原型:char *asctime(const struct tm *timeptr)#pragma warning(disable:4996) //接触安全警报限制time_t curtime = time(NULL);struct tm *info = localtime(&amp;curtime);cout &lt;&lt; asctime(info) &lt;&lt; endl; 6.gmtime():使用timer来填充tm的结构，并协调世界时(UTC)也被称作格林尼治标准时间(GMT)表示12345//函数原型:struct tm *gmtime(const time_t *timer)#pragma warning(disable:4996) //接触安全警报限制time_t curtime = time(NULL);struct tm *info = gmtime(&amp;curtime);cout &lt;&lt; asctime(info) &lt;&lt; endl; 7.mktime():将tm结构的timer转换成一个依据本地时区的time_t值123456//函数原型:time_t mktime(struct tm *timeptr)#pragma warning(disable:4996) //接触安全警报限制time_t curtime = time(NULL);struct tm *info = localtime(&amp;curtime);time_t localtime = mktime(info); cout &lt;&lt; ctime(&amp;localtime) &lt;&lt; endl; 8.difftime(): 返回time1和time2之间的相差秒数1234567891011// double difftime(time_t time1, time_t time2)#pragma warning(disable:4996) //接触安全警报限制#include &lt;windows.h&gt; //sleep函数time_t start_t, end_t;time(&amp;start_t);cout &lt;&lt; &quot;程序启动：&quot; &lt;&lt; start_t &lt;&lt; endl;Sleep(5632);time(&amp;end_t);cout &lt;&lt; &quot;程序结束：&quot; &lt;&lt; end_t &lt;&lt; endl;double diff_t = difftime(end_t, start_t); //以秒为单位精度是double我也不太清楚为什么....cout &lt;&lt; &quot;程序占用时间:&quot; &lt;&lt; diff_t &lt;&lt; endl; 9.strftime(): size_t strftime(char *str, size_t maxsize, const char *format, const struct tm *timeptr)，根据format中定义的格式化规则，格式化数据结构timeptr表示的时间，并把它存储在str中12345time_t now = time(NULL);struct tm *info = localtime(&amp;now);char buffer[80];strftime(buffer, 80, &quot;%x - %I:%M%p&quot;, info);cout &lt;&lt; &quot;格式化时间：&quot; &lt;&lt; buffer &lt;&lt; endl; C++ 基本输入输出 C++的I/O 发生在流中，流是字节序列。输入操作：字节流是从设备（如键盘、磁盘驱动器、网络连接等）流向内存。输出操作：字节流是从内存流向设备（如显示屏、打印机、磁盘驱动器、网络连接等）。 I/O 库头文件：1.标准输出流(cout):是ostream类的实例，与运算符&lt;&lt;将对象连接到标准输出设备2.标准输入流(cin):是istream类的实例，与运算符&gt;&gt;将对象连接到标准输入设备3.标准错误流(cerr):是ostream类的实例，是非缓冲的，每个流插入cerr会立即输出4.标准日志流(clog):是ostream类的实例，是缓冲的，每个流插入clog会先存储到缓冲区直到其填满或者刷新时才会输出 C++ 结构用户自定义的数据类型，允许存储不同类型的数据项，格式如下1234567struct type_name &#123;member_type1 member_name1;member_type2 member_name2;member_type3 member_name3;..&#125; object_names; 访问结构成员:使用成员访问运算符(.)，如1object_names.member_name 访问指向结构的指针:可定以指向结构的指针，则使用指针访问运算符(-&gt;)，如12struct type_name *struct_ptr = &amp;object_names;struct_pointer-&gt;title","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://harviealwayshere.github.io/tags/C/"}]},{"title":"粤语歌单","slug":"musicYueYu","date":"2018-01-30T08:34:19.000Z","updated":"2018-01-31T09:45:01.985Z","comments":true,"path":"2018/01/30/musicYueYu/","link":"","permalink":"https://harviealwayshere.github.io/2018/01/30/musicYueYu/","excerpt":"","text":"今天推荐的歌单是粤语抒情相关的，怎么说呢，感觉粤语歌与普通话的歌听觉上有所不同，粤语歌的咬文嚼字可能并不需要那么清晰，但是情感却十分饱满浓郁。第一位着重推荐的是我喜欢的比较冷门的粤语歌手侧田，听他的歌总是能感受的到他的力量、他的硬朗，能身临其境地走入他的内心感受他歌唱时的情感，听他的歌总能汲取歌中的能量，让听众奋发向上。 第二位推荐的是杨千嬅，她总是吟唱悲伤无助的歌曲，高亮干净的嗓音让她的歌总是令人心生怜意，比较适合一个人、悲伤的时候听，也许她的歌可以让你明白，悲剧才是最感动的。 第三位推荐的是谢安琪，”男不听七友，女不听钟无艳”相比很多人都听过，都是伤感情歌，谢安琪更是把以好友身份苦恋无果、甘做备胎的状态演唱的淋漓尽致。由于版权原因，请移步钟无艳 试听。","categories":[{"name":"Music","slug":"Music","permalink":"https://harviealwayshere.github.io/categories/Music/"}],"tags":[{"name":"粤语","slug":"粤语","permalink":"https://harviealwayshere.github.io/tags/粤语/"},{"name":"music","slug":"music","permalink":"https://harviealwayshere.github.io/tags/music/"}]},{"title":"使用Hexo和Markdown写作","slug":"hexoWrite","date":"2018-01-27T10:03:33.000Z","updated":"2018-01-30T08:30:23.412Z","comments":true,"path":"2018/01/27/hexoWrite/","link":"","permalink":"https://harviealwayshere.github.io/2018/01/27/hexoWrite/","excerpt":"","text":"终于开始激动人心的写博客环节了，但是在hexo上写博客跟word上写博客可不太一样。 Hexo特性：hexo可以用命令行创建文章，hexo可以自定义写作布局layout，hexo的资源文件的引用 Markdown语法：hexo生成的文章都是.md格式，需要使用特殊的编辑器来进行写作，还有特殊的markdown写作语法 资源的引用：使用外链（图床）和本地引用方法 严格规范markdown语法看来写博客也是一件不省心的事情，就让我们按部就班一步步来看看各个环节的特性吧。 1.Hexo特性建议参考官方文档&emsp; &emsp;&emsp;&emsp;&emsp;1.1 修改layout布局：&emsp;&emsp;&emsp;&emsp;打开博客文件夹根目录下的[scaffolds]中的[post.md]文件，可以看到初始只有title/date/tags三种文件变量称作Front-matter,可以添加updated/categories等基本变量如下&emsp;&emsp;&emsp;&emsp;Tips:并列的tips需要使用- (-和空格)否则会编译出错 &emsp;&emsp;&emsp;&emsp;1.2 创建文章语法：1$ hexo new [layout] &lt;title&gt; &emsp;&emsp;&emsp;&emsp;1.3 Hexo自带语法：&emsp;&emsp;&emsp;&emsp;Hexo也有一些用于写作的不同于md的基本语法称作标签插件(Tag Plugins)比如引用块真是不知命运所馈赠的礼物，早已在暗中标明了价格。 茨威格断头王后比如代码块1alert(&apos;Hello World!&apos;); 2.Markdown语法&emsp;&emsp;&emsp;&emsp;Markdown语法很多很细致但是很简单，网上有很多文章介绍，这里我就推荐一个写的很好的博主文章供大家学习，相信很多人都是看这篇文章入门的，我就不露丑介绍了。 3.资源引用&emsp;&emsp;&emsp;&emsp;相信很多人在写博文为了增强用户体验都会插入一些图片表达，md中都是依靠链接来插入图片的，唯一不同的是这个链接是本地链接还是外部链接呢，本地链接无风险但是插入的图片会占据github空间而且不灵活不好分享毕竟我们写的博文都是需要部署到github上的，外部链接节省github空间但是万一失效了图片就显示不出来了俗称图片挂了，我个人原则是 小图片用本地链接大图片可以尝试外部链接，重要图片用本地链接稍微不那么关键的图片用外部链接。 &emsp;&emsp;&emsp;&emsp;3.1 本地链接的使用：&emsp;&emsp;&emsp;&emsp;本地链接的使用其实很简单，但是由于图片在本地路径和在生成($ hexo g)文件的路径并不相同，所以我的做法是首先将图片放在跟博文文件一个目录下，在本地预览完成需要部署的时候，再将图片剪切到[博客根目录/source/images/]文件夹里面同时要修改博文中对于图片的引用变成(/images/picture.png)因为编译后图片放在网站根目录的images中。 &emsp;&emsp;&emsp;&emsp;3.2 外部链接的使用：&emsp;&emsp;&emsp;&emsp;外部链接的使用其实就是利用一些网站服务器的空间来存储你的图片俗称图床，在博文中直接使用直接路径调用图片，如类似这种链接https://i.loli.net/2018/01/25/5a69a60eeda77.gif&emsp;&emsp;&emsp;&emsp;图床有许多，有免费的也有收费的，有些有浏览流量的限制，收费的我推荐七牛云,免费的我推荐SM.MS,用到现在还没有出现挂图的迹象。&emsp;&emsp;&emsp;&emsp;Tips：其实图床蛮多托的，有人建议直接放在github仓库上用绝对连接访问就好。 在repository的根目录下建立文件夹，然后将图片放在其中，在写链接的时候直接使用自己的GitHub Pages根路径加图片地址访问即可。 4.严格规范markdown语法&emsp;&emsp;&emsp;&emsp;Markdown语法看似简单，其实有许多坑需要踩。比如最简单的用[###]表示字体大小，也许在markdown编辑器上可以直接使用[###你好]表示，但是生成页面的时候却显示不出来，这是因为[#]的严格语法是[#+空格+内容]，缺少一个空格将会造成无法编译。还有一些小技巧，比如想打出空格,换行，底色等，最好还是用字符或者Html语法的形式，如下1234567&amp;emsp; //空格&lt;br&gt; //换行&lt;font face=&quot;微软雅黑&quot;&gt;&lt;/font&gt; //字号&lt;font color=red&gt;&lt;/font&gt; //字体颜色&lt;font color=#0099ff size=7&gt;&lt;/font&gt; //字体[1-7]&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=orange&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; //背景色--- //分割线 相信你已经初步了解怎么使用hexo和markdown语法写作了，你肯定迫不及待地想写下自己第一篇博文打了吧，去吧！","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://harviealwayshere.github.io/tags/Hexo/"},{"name":"GithubPages","slug":"GithubPages","permalink":"https://harviealwayshere.github.io/tags/GithubPages/"}]},{"title":"大三上寒假计划","slug":"planOfHoliday","date":"2018-01-27T09:13:41.000Z","updated":"2018-01-30T08:30:21.686Z","comments":true,"path":"2018/01/27/planOfHoliday/","link":"","permalink":"https://harviealwayshere.github.io/2018/01/27/planOfHoliday/","excerpt":"","text":"我的寒假学习计划同时也是博客的更新计划，大致有以下几个方面： 算法：LeetCode、牛客网、剑指Offer的题目解法总结 专业相关：机器学习的实践相关内容总结 实战：Laravel框架的学习和一个网页功能开发实战的更新总结 python：python相关的库使用，如爬虫、机器学习、可视化、游戏等 影评：休闲之时也会写一些影评推荐一些精品电影给大家（资源也会放出来） 每部分的更新频率不一定，但是会尽量面面俱到、频繁更新的，敬请期待哦！","categories":[{"name":"Life","slug":"Life","permalink":"https://harviealwayshere.github.io/categories/Life/"}],"tags":[{"name":"Plan","slug":"Plan","permalink":"https://harviealwayshere.github.io/tags/Plan/"}]},{"title":"使用github pages和hexo搭建个人博客","slug":"gitPagesAndHexo","date":"2018-01-14T12:51:14.000Z","updated":"2018-01-30T08:30:24.530Z","comments":true,"path":"2018/01/14/gitPagesAndHexo/","link":"","permalink":"https://harviealwayshere.github.io/2018/01/14/gitPagesAndHexo/","excerpt":"","text":"大致步骤可以分为6步 下载安装Node.js（可以使用npm下载和管理包） 申请github账户（用于注册github pages仓库） 下载git（最好是bash 便于使用命令行操作系统） 安装hexo并配置基本参数 安装hexo主题并配置基本参数 博客部署到github pages上线 1. 下载安装Node.js（可以使用npm下载和管理包）1.1访问Node.js中文官网下载安装包:根据你的操作系统和系统类型（位数）选择下载哪一个安装包Tips：32位安装包兼容64位操作系统，64位安装包不兼容32位操作系统&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;建议使用.msi格式一键安装&nbsp;&nbsp;1.2安装Node.js:&emsp;&emsp;&emsp;&emsp;.zip文件：运行node.exe文件会跳出命令行安装&emsp;&emsp;&emsp;&emsp;.msi文件:根据提示步骤安装（安装路径最好是全英文）1.3测试是否安装成功:&emsp;&emsp;&emsp;&emsp;1.3.1 打开命令提示符:&emsp;&emsp;&emsp;&emsp;windows系统下用+R）打开运行窗口输入cmd打开命令提示符&emsp;&emsp;&emsp;&emsp;1.3.2： 输入命令 node -v 和npm -v 查看node.js和npm是否安装成功：&emsp;&emsp;&emsp;&emsp; &emsp;&emsp;&emsp;&emsp; 若有版本号（不一定与我的相同）则安装成功 否则安装失败则重新安装即可 2. 申请github账户（用于注册github pages仓库）&emsp;&emsp;&emsp;&emsp;2.1 访问github官网注册账号&emsp;&emsp;&emsp;&emsp;2.3 申请一个仓库:&emsp;&emsp;&emsp;&emsp;登录你的github账号点击上方的New repository 如下图所示&emsp;&emsp;&emsp;&emsp;在Repository name上填写 [你注册的github名称.github.io] 即可&emsp;&emsp;&emsp;&emsp;如我注册的github名称是xxx则我的Repository name为 [xxx.github.io]&emsp;&emsp;&emsp;&emsp;其他的都不用填写 之后点击[Create repository]即可 3. 下载安装git（最好是bash 便于使用命令行操作系统） Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 此部分内容建议参考廖雪峰老师的git安装文档&emsp;&emsp;&emsp;&emsp;3.1 通俗来说git就是一个软件类似于cmd命令行，但是它可以使用git命令和linux命令来操控系统，这是cmd所做不到的。在此项目中，我们主要使用它来编写npm命令、hexo命令、git命令来生成和部署自己的博客到github pages上&emsp;&emsp;&emsp;&emsp;访问git下载页面下载对应系统的git &emsp;&emsp;&emsp;&emsp;安装完毕之后打开gitbash即可使用&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;首次使用git的用户还需配置自己的用户名和地址用于验证身份：12$ git config --global user.name &quot;Your Name&quot; $ git config --global user.email &quot;email@example.com&quot; &emsp;&emsp;&emsp;&emsp;3.2 将计算机的ssh key设置到你的github账号上，你才能将本地的文件上传到你的github上面&emsp;&emsp;&emsp;&emsp;具体操作可参考廖雪峰老师的ssh key设置教程 4. 全局安装hexo建立自己的博客并配置基本参数此部分内容建议参考hexo官方文档&emsp;&emsp;&emsp;&emsp; 4.1 全局安装hexo：&emsp;&emsp;&emsp;&emsp;访问hexo官方网站查看安装命令，运行Git Bash输入安装命令npm install hexo-cli -g&emsp;&emsp;&emsp;&emsp; 4.2 建立自己的博客：在Git Bash中输入123$ hexo init [你的博客文件夹名称] $ cd [你的博客文件夹名称] $ npm install&emsp;&emsp;&emsp;&emsp;我这里演示的文件夹名称是[testBlog]&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Tips:输入pwd可查看当前文件夹的路径&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&nbsp;输入explorer .可打开命令行当前文件夹&emsp;&emsp;&emsp;&emsp;如果看到以下内容，那么恭喜你hexo建站成功了&emsp;&emsp;&emsp;&emsp; &emsp;&emsp;&emsp;&emsp; 4.3 配置基本参数博客本地预览&emsp;&emsp;&emsp;&emsp;您可以在 _config.yml 文件中修改大部份的配置具体参数意义可参考官方文档&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;输入以下命令可在本地预览你生成的博客网址123$ npm install hexo-server --save $ hexo generate$ hexo server &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;你可以像我一样用[$ hexo g]和[$ hexo s]来简化命令&emsp;&emsp;&emsp;&emsp;[$ npm install hexo-server –save]用来安装hexo本地预览的服务器 只用第一次执行一次就可以了&emsp;&emsp;&emsp;&emsp;以后每次改动就只用[$ hexo g]生成文件和[$ hexo s]启动服务器就可以了&emsp;&emsp;&emsp;&emsp;之后在浏览器输入[http://localhost:4000]就可以查看你的博客页面了&emsp;&emsp;&emsp;&emsp; 5. 安装hexo主题并配置基本参数&emsp;&emsp;&emsp;&emsp;到目前为止，是不是觉得hexo默认的主题不符合你的心意，没关系，hexo爱好者们提供了上千个主题供你挑选使用，安装主题的方法也十分简单，让我们一起来让博客的面目焕然一新吧&emsp;&emsp;&emsp;&emsp;5.1 挑选你喜爱的主题下载&emsp;&emsp;&emsp;&emsp;可以参考官方主题推荐文档或者github大神整理来寻找自己喜欢的主题并按照对应主题的文档说明下载使用&emsp;&emsp;&emsp;&emsp;如我的博客采用的主题是Huemen下载就十分简单，按照官方文档按部就班即可&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;5.2 配置主题的基本参数：&emsp;&emsp;&emsp;&emsp;主题的配置是类似于hexo配置，修改主题文件下中的[_config.yml]文件即可具体每个参数的意义请参考主题的说明文档&emsp;&emsp;&emsp;&emsp;5.3 配置成功之后可运行命令预览自己的博客了（在博客根目录下运行命令）123$ hexo clean $ hexo g $ hexo s 6. 博客部署到github pages上线&emsp;&emsp;&emsp;&emsp;6.1 安装git pages部署器：在博客根目录下打开git bash运行[$ npm install hexo-deployer-git –save]命令&emsp;&emsp;&emsp;&emsp;6.2 修改博客根目录下的配置文件[_config.yml]中的deploy参数：123deploy: type: git repo: [你注册的github pages的仓库地址] &emsp;&emsp;&emsp;&emsp;6.3 部署至github上：12$hexo generate $hexo deploy &emsp;&emsp;&emsp;&emsp;或者1$hexo d -g&emsp;&emsp;&emsp;&emsp;成功之后你可以在线访问你的github pages地址[你的github仓库名.github.io]来查看你的博客了 恭喜你，你的博客已经搭建成功并上线了! 之后我会再写一篇文章介绍hexo写作的基本方法、使用markdown格式写作、图床的使用技巧等博文写作知识，敬请期待。","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://harviealwayshere.github.io/tags/Hexo/"},{"name":"GithubPages","slug":"GithubPages","permalink":"https://harviealwayshere.github.io/tags/GithubPages/"}]}]}