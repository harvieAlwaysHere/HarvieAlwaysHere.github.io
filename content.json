{"meta":{"title":"Harvie Blog","subtitle":"Fright For Better Day","description":"IT Blog","author":"Harvie Yao","url":"https://harviealwayshere.github.io"},"pages":[{"title":"about","date":"2018-01-30T09:37:04.000Z","updated":"2018-01-30T09:37:04.587Z","comments":true,"path":"about/index.html","permalink":"https://harviealwayshere.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"Swoole(一)安装","slug":"swoole1","date":"2018-02-09T16:29:04.000Z","updated":"2018-02-09T17:55:49.101Z","comments":true,"path":"2018/02/10/swoole1/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/10/swoole1/","excerpt":"","text":"说到PHP异步网络通信框架，相信PHPer脑海里第一个浮现的便是Swoole。 商业应用：IM聊天、战旗TV、虎牙直播、YY语音等。 应用领域：互联网、网络通信、企业软件、云计算、网络游戏、物理网等。 特点：1.异步、并行、高性能2.纯C编写，接近应用底层3.php扩展 应用：1.异步多线程服务器及客户端2.异步MySQL、Redis、数据库连接池、任务队列3.http/websocket服务器/客户端4.异步文件读写5.Swoole2.0支持协程 安装Swoole大致可分成3个步骤:1.搭建Linux操作系统2.安装环境依赖(php,gcc,httpd，pecl)3.安装Swoole并修改php.ini Part1:搭建Linux操作系统查看官方文档可知Swoole并不支持Windows系统，所以我们这里搭建一个CentOS 7.3 64位的操作系统，我是使用阿里云云服务器 ECS搭建的，使用系统盘安装即可，安装完毕之后可以远程连接进入云服务器中的Linux系统中Tips:如果想在Windows下便捷操作云服务器的系统，推荐使用SSH连接软件，这里我使用的是SSH Secure Shell Client3.2.9，安装完成后有两个工具可以使用，分别对应Linux系统的命令行界面和Linux文件系统的GUI界面的，十分便捷客观，提供工作效率。可参考这篇博客安装使用。连接成功后的界面为 Part2:安装环境依赖(php,gcc,httpd，pecl)在CentOS中使用yum安装php7，由于初始yum所安装的php版本是5.*的，我们首先要获取php7的yum源1234567891011//1.安装epel-releaseyum -y install epel-release //2.获取php7的yum源rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm//3.安装php7yum install php70w//4.验证安装php -v安装完成后可看到php版本之后我们要安装gcc和httpd1yum install httpd gcc最后我们要安装pecl，因为swoole项目已收录到PHP官方扩展库，可直接使用pecl安装swoole12wget http://pear.php.net/go-pear.pharphp go-pear.phar Part3:安装Swoole并修改php.ini1sudo pecl install swoole 会报错如下，别着急输入1vi `which pecl`进入Linux的Vim编辑模式，一直向下查找找到这个文件的最后一行按I进入Vim的插入模式，之后将-n标志去掉，按ESC进入Vim的退出(末行)模式，输入[:wq!]保存并退出之后安装 php-devel1sudo yum install php70w-devel再次安装swoole1sudo pecl install swoole成功安装！根据提示要添加”extension=swoole.so”在php配置文件php.ini中，我这里由于对于Vim的操作并不熟悉，我直接通过SSH软件将php.ini文件拉取到本地之后修改再上传到服务器php.ini一般在/etc目录下拉取到本地后添加”extension=swoole.so”语句，随意在任何两个配置语句中增加之后通过语句[php -m]可查看php拓展安装情况，如果看到swoole则安装成功！ 如果你实践完成了本教程，意味着你对于Linux和Windows系统的协同开发、php拓展安装已经了解了基本情形了，接下来我们将使用swoole开发php应用，敬请期待。","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"php项目","slug":"php项目","permalink":"https://harviealwayshere.github.io/tags/php项目/"},{"name":"swoole","slug":"swoole","permalink":"https://harviealwayshere.github.io/tags/swoole/"}]},{"title":"剑指Offer算法记录","slug":"offer","date":"2018-02-07T08:20:05.000Z","updated":"2018-02-07T17:07:05.064Z","comments":true,"path":"2018/02/07/offer/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/07/offer/","excerpt":"","text":"本文主要记录阅读剑指Offer这本书所遇到的算法解释并作一些个人的拓展 第二章2.2.1 关于sizeof的小知识 sizeof 对于空类型(无成员变量和成员函数)的实例 = 1字节：由于声明空类型的实例必须在内存中占用一定空间否则无法使用，占用多少内存由编译器决定，在VS中每个空类型实例占用1字节。 sizeof 对于空类型+构造和析构函数的实例 = 1字节 ：调用函数只需知道函数地址即可，函数地址只与类型有关而与类型的实例无关，因此sizeof实例还是1字节。 sizeof 对于空类型+构造函数+虚析构函数(虚函数) = 1个指针大小：一个类型中有虚拟函数就会为该类型生成虚函数表，并为这个类型的每个实例中添加一个指向虚函数表的指针，指针大小与机器有关，32为指针为4字节，64位指针为8字节。1234567891011121314151617181920212223242526class B //空类型&#123;&#125;;class C //空类型+构造和析构函数&#123;public: C()&#123;&#125;; ~C()&#123;&#125;;&#125;;class D //空类型+构造函数+虚析构函数(虚函数)&#123;public: D()&#123;&#125;; virtual ~D()&#123;&#125;;&#125;;int main()&#123; B b; C c; D d; cout &lt;&lt; &quot;空类型大小:&quot; &lt;&lt; sizeof(b)&lt;&lt;endl; cout &lt;&lt; &quot;空类型+构造和析构函数大小:&quot; &lt;&lt; sizeof(c) &lt;&lt; endl; cout &lt;&lt; &quot;空类型+构造函数+虚析构函数(虚函数)大小:&quot; &lt;&lt; sizeof(d) &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 总结：空的类是会占用内存空间的，而且大小是1，原因是C++要求每个实例在内存中都有独一无二的地址。 类内部的成员变量：*普通的变量：是要占用内存的，但是要注意对齐原则（这点和struct类型很相似）。*static修饰的静态变量：不占用内容，原因是编译器将其放在全局变量区。 类内部的成员函数：*普通函数：不占用内存。*虚函数：要占用4个字节，用来指定虚函数的虚拟函数表的入口地址。所以一个类的虚函数所占用的地址是不变的，和虚函数的个数是没有关系的 2.2.1 关于复制函数的小知识C++标准不允许复制构造函数传值参数，否则会造成递归重复调用，编译错误。12345678910111213141516171819202122232425262728293031323334353637383940class E&#123;private: int num;public: //构造函数 E(int x) :num(x) &#123; cout &lt;&lt; &quot;constructor call&quot; &lt;&lt; endl; &#125; //复制构造函数 传引用调用 E(E&amp; x) &#123; num = x.num; cout &lt;&lt; &quot;copy constructor call&quot; &lt;&lt; endl; &#125; //赋值运算符重载 E&amp; operator = (E&amp; x) &#123; num = x.num; cout &lt;&lt; &quot;assignment operator call&quot; &lt;&lt; endl; return *this; &#125; //函数调用 void showNum(E x) &#123; &#125; &#125;;int main()&#123; E a(1); //1式 E b(2); //2式 b = a; //3式 E c = a; //4式 c.showNum(a); //5式 system(&quot;pause&quot;); return 0;&#125;运行结果如图： 1/2式 =&gt; 若是实例创建并初始化时调用相应参数的构造函数 3式 =&gt; 若是实例已经创建初始化后再用=赋值，则调用=重载赋值函数 4式 =&gt; 若是实例用另一个同类实例初始化，则调用复制构造函数 5式 =&gt; 若是实例使用方法调用另一个实例，则首先调用复制构造函数将实参复制给形参后执行相关操作 因此就可以解释为什么C++不允许复制构造函数传值了，若是传值，则调用E c = a或者c.showNum(a)或者的时候，a作为参数传值给c的复制构造函数的参数E x，因为x没有被初始化，所以要调用x的复制构造函数将a复制给x，即x.E(a)，然而x的复制构造函数也是传值的，因此又要将a作为参数传值给c的复制构造函数的参数x的复制构造函数的参数E x，又因为这个x也没有被初始化，又要调用这个x的复制构造函数，造成了无限的递归。因此复制构造函数的参数使用引用调用不是为了减少一次内存的复制，而是为了避免复制构造函数无限递归调用的情况出现。下面这几种情况下会调用复制构造函数:（1）显式或隐式地用同类型的一个对象来初始化另外一个对象。如上例中的E c=a;（2）作为实参传递给一个函数。如上例中的c.showNum(a);（3）在函数体内返回一个对象时，也会调用返回值类型的拷贝构造函数（4）初始化序列容器中的元素时。比如vector svec(5)，string的缺省构造函数和拷贝构造函数都会被调用。 （5）用列表的方式初始化数组元素时。string a[] = {string(“hello”),string(“world”)};会调用string的拷贝构造函数。","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://harviealwayshere.github.io/tags/算法/"}]},{"title":"C++基础语法","slug":"cplusplus","date":"2018-01-31T07:31:56.000Z","updated":"2018-02-07T08:09:25.136Z","comments":true,"path":"2018/01/31/cplusplus/","link":"","permalink":"https://harviealwayshere.github.io/2018/01/31/cplusplus/","excerpt":"","text":"刚想刷剑指offer和leetcode上的题目，本来享用python写的，毕竟是刷算法感觉无论是什么语言总是相通的，但看到剑指offer上写到 大一学的C++基础语法都忘记的差不多了，还是先来巩固一下C++基础语法，本文以runoob和C++ Primer(第五版)为基础编写。 Part1：C++基础语法标准的 C++ 由三个重要部分组成： 核心语言，提供了所有构件块，包括变量、数据类型和常量，等等。 C++ 标准库，提供了大量的函数，用于操作文件、字符串等。 标准模板库（STL），提供了大量的方法，用于操作数据结构等。 C++面向对象四大特点:封装、抽象、继承和多态。 C++基本程序结构：12345678#include &lt;iostream&gt; //添加头文件using namespace std; //使用std命名空间 int main() //主函数，程序执行入口&#123; cout &lt;&lt; &quot;Hello World&quot;; // 输出 Hello World return 0; //终止main函数并返回0值&#125; C++内置数据类型：类型&emsp;&emsp;&emsp;&emsp;关键字&emsp;&emsp;&emsp;&emsp;内存(字节)布尔型 &emsp;&emsp;&emsp;bool&emsp;&emsp;&emsp;&emsp;&emsp;1字符型 &emsp;&emsp;&emsp;char&emsp;&emsp;&emsp;&emsp;&emsp;1整型 &emsp;&emsp;&emsp;&emsp;int&emsp;&emsp;&emsp;&emsp;&emsp;&nbsp;&nbsp;&nbsp;4浮点型 &emsp;&emsp;&emsp;float&emsp;&emsp;&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;4双浮点型 &emsp;&emsp;double&emsp;&emsp;&emsp;&emsp;8无类型 &emsp;&emsp;&emsp;void&emsp;&emsp;&emsp;&emsp;&emsp;宽字符型 &emsp;&emsp;wchar_t&emsp;&emsp;&emsp;&nbsp;&nbsp;4一些类型可用修饰符修饰:signed,unsigned,short,long.Tip:其实知道了字节数很简单计算范围，1字节=8位，每位存储一个二进制0/1，有几位二进制则可以存储2^位数范围大小的数字。Tip:存储有符号数的时候，例如int，虽然是4字节的，但是只能是1符号位+31数值为位，所以最大为2^31=2147483647。可以使用typedef为一个已有的类型取一个新的名字:typedef type newname;12typedef int SSS;SSS a = 2; 枚举类型(enumeration)：是C++中的一种派生数据类型，它是由用户定义的若干枚举常量的集合:语法为:enum name {IDentifier0[=int 0],IDentifier1=[int 1]} Variable;12enum color &#123; red, green, blue &#125; c; //定义变量c是枚举类型colorc = blue; //c赋值为blue 变量声明和定义:您可以使用extern关键字在任何地方声明一个变量。虽然您可以在 C++ 程序中多次声明一个变量，但变量只能在某个文件、函数或代码块中被定义一次。123456789101112// 变量声明extern int a; //可进行多次int main ()&#123; // 变量定义 //仅可进行一次 int a; // 实际初始化 a = 10; return 0;&#125; 函数声明和定义:在函数声明时，提供一个函数名，而函数的实际定义则可以在任何地方进行。1234567891011121314// 函数声明int func();int main ()&#123; // 函数调用 int i = func(); return 0;&#125;// 函数定义int func()&#123; return 666;&#125; 变量作用域: 在函数或一个代码块内部声明的变量，称为局部变量。 在函数参数的定义中声明的变量，称为形式参数。 在所有函数外部声明的变量，称为全局变量。 初始化:定义全局变量时，系统会根据数据类型自动初始化；定义局部变量时，系统不会自动初始化。 C++常量:定义后不能进行修改的固定值。整数常量: 前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制 后缀指定修饰符:是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。 浮点常量：由整数部分、小数点、小数部分和指数部分组成。 小数形式：必须包含整数部分、小数部分，或同时包含两者。 指数形式：必须包含小数点、指数，或同时包含两者。带符号的指数是用 e 或 E 引入的。 布尔常量：true/false字符常量：括在单引号中的可以是一个普通的字符（例如 ‘x’）、一个转义序列（例如 ‘\\t’），或一个通用的字符（例如 ‘\\u02C0’）。 宽字符常量：以 L（仅当大写时）开头存储在 wchar_t 类型的变量中（例如 L’x’）。 窄字符常量：存储在 char 类型的简单变量中（例如 ‘x’）。 字符串常量：括在双引号 “” 中的。一个字符串包含类似于字符常量的字符：普通的字符、转义序列和通用的字符。C++有两种简单定义常量方式: 使用 #define 预处理器:#define identifier value 使用 const 关键字:const type variable = value; Tips:常量一般被定义成大写字母形式 C++ 修饰符类型修饰符 signed、unsigned、long 、short可应用于整型，signed 和 unsigned可应用于字符型，long 可应用于双精度型。修饰符 signed 和 unsigned 也可以作为 long 或 short 修饰符的前缀。例如：unsigned long int。 C++ 类型限定符用于限定类型和类型成员的声明 const：限定对象在程序执行期间不能被修改改变。 volatile：限定变量的值可能以程序未明确指定的方式被改变。(多线程使用) C++ 存储类存储类定义 C++ 程序中变量/函数的范围（可见性）和生命周期，常有auto、static、extern、mutable、thread_local (C++11)。auto关键字用于两种情况： 声明变量时根据初始化表达式自动推断该变量的类型。 声明函数时函数返回值的占位符。1234auto f=3.14;cout&lt;&lt;typeid(f).name()&lt;&lt;endl; //doubleauto z = new auto(9); cout&lt;&lt;typeid(z).name()&lt;&lt;endl; // int* static关键字指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。 static修饰局部变量：变量在全局数据区分配内存，程序执行第一次时首次初始化，以后函数调用不再进行初始化，没有显式初始化则会被自动初始化为0。 static修饰全局变量：使变量的作用域限制在声明它的文件内。 static修饰类的成员变量：类外初始化，先于类存在，类所有对象共同一个静态成员变量，可通过类名直接调用公共(public)静态成员变量。123456789101112131415class A&#123;public: A()&#123; count++; &#125; //先于类存在，在类的构造方法中已经可以调用 static int count;&#125;;int A::count = 0; //类外初始化int main()&#123; A c; A d; cout &lt;&lt; A::count &lt;&lt; endl; //共用性和直接类名调用 system(&quot;pause&quot;); return 0;&#125; static修饰类的成员方法:先于类存在，方法中不能使用非静态成员(无this指针),可通过类名直接调用公共(public)静态成员方法。12345678910111213141516171819class A&#123;public: A()&#123; count++; &#125; static int count; static void showCount() &#123; cout &lt;&lt; &quot;count is &quot; &lt;&lt; count &lt;&lt; endl; //不用this指针织带变量 &#125;&#125;;int A::count = 0; int main()&#123; A c; A d; A::showCount(); //类名直接调用 system(&quot;pause&quot;); return 0;&#125; C++ 运算符运算符是一种告诉编译器执行特定的数学或逻辑操作的符号,有算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符和其他运算符。算数运算符:+、-、、/、%(取模,整除后的余数)、++(自增)、–(自减).关系运算符:==、!=、&gt;、&lt;、&gt;=、&lt;=.逻辑运算符:&amp;&amp;(逻辑与，均非零为真)、||(逻辑或，存在非零则为真)、!(逻辑非，逆转逻辑状态).Tips:&amp;&amp;(||)具有短路功能，即若第一个条件为false(true)，则不再计算第二个表达式；&amp;(|)则无论如何均会计算两个表达式.利用这点可将A&amp;&amp;B中的A作为一个条件语句(if)不满足则不执行B，如下1234567891011121314151617/*不用任何循环语句，不用if，来实现1+2+3+...+10的值*/#include &lt;iostream&gt;using namespace std;int add(int c)&#123; int a=0; c&amp;&amp;(a=add(c-1));//递归循环，直到传入c的值为0则结束循环不执行右式 //(用&amp;则会执行造成溢出错误) cout&lt;&lt;c+a&lt;&lt;endl; return c+a;&#125;int main()&#123; add(10); return 0;&#125;位运算:若A = 60，且 B = 13，以二进制表示如下A = 0011 1100B = 0000 1101赋值运算:=、+=、-=、=、/=、%=、&lt;&lt;=、&gt;&gt;=、&amp;=(按位与或且赋值)、^=(按位异或且赋值)、|=(按位或且赋值)杂项运算: C++ 循环 while:1234while(condition)&#123; statement(s);&#125; for:1234for ( init; condition; increment )&#123; statement(s);&#125; do…while:12345do&#123; statement(s);&#125;while( condition ); 循环控制语句: break：跳出循环。 continue:跳过循环主体的剩余部分，立即重新开始测试条件。 C++ 判断 if:1234if(boolean_expression)&#123; statement(true); // 如果布尔表达式为真将执行的语句&#125; if…else:12345678if(boolean_expression)&#123; statement(true); // 如果布尔表达式为真将执行的语句&#125;else&#123; statement(false); // 如果布尔表达式为假将执行的语句&#125; switch:123456789101112switch(expression)&#123; case constant-expression : statement(s); break; // 可选的 case constant-expression : statement(s); break; // 可选的 // 您可以有任意数量的 case 语句 default : // 可选的 statement(s);&#125; [ ? : ]运算符:1Exp1 ? Exp2 : Exp3; C++ 函数函数声明包含函数的名称、返回类型和参数C++中的函数声明形式：1return_type function_name( parameter list );函数定义提供了函数的实际主体。C++中的函数定义形式：1234return_type function_name( parameter list )&#123; body of the function&#125;函数参数:函数内使用的局部变量称作形式参数，有三种调用方式 传值调用(默认)：把参数的实际值复制给形式参数。在这种情况下，修改函数内的形式参数不会影响实际参数。 指针调用：把参数的地址复制给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。修改形式参数会影响实际参数。如函数声明:void swap(int *x, int *y)函数调用:swap(&amp;a,&amp;b) 引用调用：把参数的引用赋值给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。如函数声明:void swap(int &amp;x, int &amp;y)函数调用:swap(a,b) 参数默认值:定义函数时可以为参数列表中每一个参数指定默认值,如int sum(int a=10,int b=20)Lambda 函数与表达式:Lambda 表达式把函数看作对象。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。 C++ 数字数学运算:引用数学头文件 内有许多内置数学函数随机数:标准库（被包含于中）提供两个帮助生成伪随机数的函数 void srand(unsigned seed)：设置随机数种子，通常用time()初始化(使用time需要引入头文件)，如srand( (unsigned)time( NULL ) ); int rand(void)：从srand (seed)中指定的seed开始，返回一个[seed, RAND_MAX（0x7fff）)间的随机整数。 指定生成范围的随机数1234(low,up) (rand()%(up-low+1)) + low - 1[low,up) (rand()%(up-low)) + low(low,up] (rand()%(up-low))+ low + 1[low,up] (rand()%(up-low+1)) + low C++ 数组声明数组:type arrayName [ arraySize ];初始化数组:type arrayName [ arraySize ] = { data } ;访问数组元素:数组名称+索引，arrayName[index];数组详解: 多维数组:type arrayName[size1][size2]…[sizeN]; 数组指针:声明的数组名其实是指向数组第一个元素的指针，即*arrayName == &amp;arrayName[0]所以也可以使用指针形式访问数组*(arrayName + i ) == arrayName[i] 传递数组给函数:是以指针的形式传递的，因此有三种传递方式：(type *param)(type param[size])(type param[]) 函数返回数组:数组以指针的形式返回的，另外C++不支持在函数外返回局部变量的地址，因此返回的数组需要均是static变量 C++ 字符串 C风格字符串:实质是一个以’\\0’(null)结尾的char数组，例如123//以下msg1和msg2初始化规则相同char msg1[6] = &#123;&apos;H&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, &apos;o&apos;, &apos;\\0&apos;&#125;;char msg2[] = &quot;Hello&quot;; C++有大量函数操作以null结尾的字符串： C++引入的 string 类类型:C++标准库提供了string类型(需引入#include &lt; string >库)且支持上述函数操作1234string str1 = &quot;Hello&quot;;string str2 = str1; //复制string str3 = str1 + str2; //连接int length = str3.size(); //长度 C++ 指针 内存地址:每个C++变量都有一个内存地址，可用寻址（&amp;）运算符访问变量的内存地址 指针:是一个特殊的变量，其值为另一个变量的内存地址，声明形式为:type *var-name; 使用指针:过程一般为声明、存储、访问（对指针使用间址(*)运算符可访问指针存储地址的变量值）12345678string str = &quot;Hello&quot;;string *ip;ip = &amp;str;cout &lt;&lt; &quot;Address of str : &quot; &lt;&lt; &amp;str &lt;&lt; endl;cout &lt;&lt; &quot;Value of str : &quot; &lt;&lt; str &lt;&lt; endl;cout &lt;&lt; &quot;Stored Address of ip : &quot; &lt;&lt; ip &lt;&lt; endl; //指针存储的变量的地址cout &lt;&lt; &quot;Address of ip : &quot; &lt;&lt; &amp;ip &lt;&lt; endl; //指针本身的地址cout &lt;&lt; &quot;Value of ip : &quot; &lt;&lt; *ip &lt;&lt; endl; 执行结果如下: Null指针:指针初始化时指定NULL值被称作空指针可以避免越界使用指针1type *ptr = NULL; 指针的算数运算:指针是一个用数值表示的地址，可以执行四种算数运算（++，–，+，-）具体运算数值与指针的类型有关(如整形指针一次递增4个字节，字符指针一次递增1个字节等) 指针与数组的异同:（同）均可通过指针的算数运算和数组索引来访问数组（异）声明数组的数组名的指针是一个指向数组第一个元素地址的常量指针，不可改变指向的地址 指针数组:可声明一个数组来存放指针，其中每个数组元素都是一个指针，如type *ptr[size]; 多级指针:一个指针指向另一个指针的地址123type var;type *ptr1 = &amp;var;type *ptr2 = &amp;ptr1; //ptr2就是一个多级指针指向一级指针ptr1 指针参数:声明函数参数为指针类型即可，这种属于指针调用函数参数，将参数地址复制给函数的形式参数，在函数内修改形式参数会影响实际参数。 函数返回指针类型:声明函数返回类型为指针类型即可，但由于C++不支持在函数外返回局部变量的地址，因此可返回指针类型的变量需要声明为static变量。 C++ 引用引用变量是一个实际变量的别名。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。 引用于指针的区别:1.引用必须在创建时初始化，指针可以在任何时间初始化。2.引出初始化为一个对象后不能更改，指针可以在任何时候指向另一个对象。3.不存在空引用，引用必须连接到一个合法内存。 引用创建初始化使用:type&amp; name = variable; 引用参数:声明函数参数为引用类型即可，属于引用调用的函数参数。这比传一般参数安全。 函数返回引用类型:声明函数返回类型为引用类型，但是实际上函数返回一个引用时是返回一个指向返回值的隐式指针，这样函数可以放在赋值语句的左边。返回引用最大的好处是在内存中不产生被返回值的副本，节省内存，但是不能返回局部变量的引用。 C++ 日期和时间C++继承了C语言用于日期和时间操作的结构和函数,需要引入 &lt; ctime > 头文件 有四个与时间有关的类型，其中clock_t、time_t、size_t 将系统时间和日期表示为某种整数，tm结构类型将日期和时间以C结构形式保存。 C/C++中关于日期和时间的重要函数:1.time(): 返回从 1970-01-01 到 当前的日历时间的秒数123//函数原型:time_t time(time_t *t)time_t nowSeconds = time(NULL);cout &lt;&lt; nowSeconds &lt;&lt; endl; 2.ctime():返回一个格式为[Www Mmm dd hh:mm:ss yyyy]基于参数timer的时间的字符串1234//函数原型:char *ctime(const time_t *timer)#pragma warning(disable:4996) //接触安全警报限制time_t curtime = time(NULL);cout &lt;&lt; ctime(&amp;curtime) &lt;&lt; endl; 3.localtime(): struct tm *localtime(const time_t *timer)，将参数timer的值分解为tm结构，并用本地时区表示12345678910//函数原型:struct tm *localtime(const time_t *timer)#pragma warning(disable:4996) //接触安全警报限制time_t curtime = time(NULL);struct tm *info = localtime(&amp;curtime);cout &lt;&lt; &quot;tm_sec:&quot; &lt;&lt; info-&gt;tm_sec &lt;&lt; endl;cout &lt;&lt; &quot;tm_min:&quot; &lt;&lt; info-&gt;tm_min &lt;&lt; endl;cout &lt;&lt; &quot;tm_hour:&quot; &lt;&lt; info-&gt;tm_hour &lt;&lt; endl;cout &lt;&lt; &quot;tm_mday:&quot; &lt;&lt; info-&gt;tm_mday &lt;&lt; endl;cout &lt;&lt; &quot;tm_mon:&quot; &lt;&lt; info-&gt;tm_mon &lt;&lt; endl;cout &lt;&lt; &quot;tm_year:&quot; &lt;&lt; info-&gt;tm_year &lt;&lt; endl; 4.clock(): 返回程序执行起处理器时钟所使用的时间，为了获取CPU所使用秒数需要除以CLOCKS_PER_SEC常量12345678910111213//函数原型:clock_t clock(void)#pragma warning(disable:4996) //接触安全警报限制clock_t start_t, end_t;start_t = clock();cout &lt;&lt; &quot;程序启动：&quot; &lt;&lt; start_t &lt;&lt; endl;for(int i=0; i&lt; 10000000; i++)&#123;&#125;end_t = clock();cout &lt;&lt; &quot;程序结束：&quot; &lt;&lt; end_t &lt;&lt; endl;double total_t;total_t = (double)(end_t - start_t) / CLOCKS_PER_SEC;cout &lt;&lt; &quot;CPU占用时间:&quot; &lt;&lt; total_t &lt;&lt; endl; 5.asctime()：返回一个基于timeptr的时期和时间的字符串的指针12345//函数原型:char *asctime(const struct tm *timeptr)#pragma warning(disable:4996) //接触安全警报限制time_t curtime = time(NULL);struct tm *info = localtime(&amp;curtime);cout &lt;&lt; asctime(info) &lt;&lt; endl; 6.gmtime():使用timer来填充tm的结构，并协调世界时(UTC)也被称作格林尼治标准时间(GMT)表示12345//函数原型:struct tm *gmtime(const time_t *timer)#pragma warning(disable:4996) //接触安全警报限制time_t curtime = time(NULL);struct tm *info = gmtime(&amp;curtime);cout &lt;&lt; asctime(info) &lt;&lt; endl; 7.mktime():将tm结构的timer转换成一个依据本地时区的time_t值123456//函数原型:time_t mktime(struct tm *timeptr)#pragma warning(disable:4996) //接触安全警报限制time_t curtime = time(NULL);struct tm *info = localtime(&amp;curtime);time_t localtime = mktime(info); cout &lt;&lt; ctime(&amp;localtime) &lt;&lt; endl; 8.difftime(): 返回time1和time2之间的相差秒数1234567891011// double difftime(time_t time1, time_t time2)#pragma warning(disable:4996) //接触安全警报限制#include &lt;windows.h&gt; //sleep函数time_t start_t, end_t;time(&amp;start_t);cout &lt;&lt; &quot;程序启动：&quot; &lt;&lt; start_t &lt;&lt; endl;Sleep(5632);time(&amp;end_t);cout &lt;&lt; &quot;程序结束：&quot; &lt;&lt; end_t &lt;&lt; endl;double diff_t = difftime(end_t, start_t); //以秒为单位精度是double我也不太清楚为什么....cout &lt;&lt; &quot;程序占用时间:&quot; &lt;&lt; diff_t &lt;&lt; endl; 9.strftime(): size_t strftime(char *str, size_t maxsize, const char *format, const struct tm *timeptr)，根据format中定义的格式化规则，格式化数据结构timeptr表示的时间，并把它存储在str中12345time_t now = time(NULL);struct tm *info = localtime(&amp;now);char buffer[80];strftime(buffer, 80, &quot;%x - %I:%M%p&quot;, info);cout &lt;&lt; &quot;格式化时间：&quot; &lt;&lt; buffer &lt;&lt; endl; C++ 基本输入输出 C++的I/O 发生在流中，流是字节序列。输入操作：字节流是从设备（如键盘、磁盘驱动器、网络连接等）流向内存。输出操作：字节流是从内存流向设备（如显示屏、打印机、磁盘驱动器、网络连接等）。 I/O 库头文件：1.标准输出流(cout):是ostream类的实例，与运算符&lt;&lt;将对象连接到标准输出设备2.标准输入流(cin):是istream类的实例，与运算符&gt;&gt;将对象连接到标准输入设备3.标准错误流(cerr):是ostream类的实例，是非缓冲的，每个流插入cerr会立即输出4.标准日志流(clog):是ostream类的实例，是缓冲的，每个流插入clog会先存储到缓冲区直到其填满或者刷新时才会输出 C++ 结构用户自定义的数据类型，允许存储不同类型的数据项，格式如下1234567struct type_name &#123;member_type1 member_name1;member_type2 member_name2;member_type3 member_name3;..&#125; object_names; 访问结构成员:使用成员访问运算符(.)，如1object_names.member_name 访问指向结构的指针:可定以指向结构的指针，则使用指针访问运算符(-&gt;)，如12struct type_name *struct_ptr = &amp;object_names;struct_pointer-&gt;title","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://harviealwayshere.github.io/tags/C/"}]},{"title":"粤语歌单","slug":"musicYueYu","date":"2018-01-30T08:34:19.000Z","updated":"2018-01-31T09:45:01.985Z","comments":true,"path":"2018/01/30/musicYueYu/","link":"","permalink":"https://harviealwayshere.github.io/2018/01/30/musicYueYu/","excerpt":"","text":"今天推荐的歌单是粤语抒情相关的，怎么说呢，感觉粤语歌与普通话的歌听觉上有所不同，粤语歌的咬文嚼字可能并不需要那么清晰，但是情感却十分饱满浓郁。第一位着重推荐的是我喜欢的比较冷门的粤语歌手侧田，听他的歌总是能感受的到他的力量、他的硬朗，能身临其境地走入他的内心感受他歌唱时的情感，听他的歌总能汲取歌中的能量，让听众奋发向上。 第二位推荐的是杨千嬅，她总是吟唱悲伤无助的歌曲，高亮干净的嗓音让她的歌总是令人心生怜意，比较适合一个人、悲伤的时候听，也许她的歌可以让你明白，悲剧才是最感动的。 第三位推荐的是谢安琪，”男不听七友，女不听钟无艳”相比很多人都听过，都是伤感情歌，谢安琪更是把以好友身份苦恋无果、甘做备胎的状态演唱的淋漓尽致。由于版权原因，请移步钟无艳 试听。","categories":[{"name":"Music","slug":"Music","permalink":"https://harviealwayshere.github.io/categories/Music/"}],"tags":[{"name":"粤语","slug":"粤语","permalink":"https://harviealwayshere.github.io/tags/粤语/"},{"name":"music","slug":"music","permalink":"https://harviealwayshere.github.io/tags/music/"}]},{"title":"使用Hexo和Markdown写作","slug":"hexoWrite","date":"2018-01-27T10:03:33.000Z","updated":"2018-01-30T08:30:23.412Z","comments":true,"path":"2018/01/27/hexoWrite/","link":"","permalink":"https://harviealwayshere.github.io/2018/01/27/hexoWrite/","excerpt":"","text":"终于开始激动人心的写博客环节了，但是在hexo上写博客跟word上写博客可不太一样。 Hexo特性：hexo可以用命令行创建文章，hexo可以自定义写作布局layout，hexo的资源文件的引用 Markdown语法：hexo生成的文章都是.md格式，需要使用特殊的编辑器来进行写作，还有特殊的markdown写作语法 资源的引用：使用外链（图床）和本地引用方法 严格规范markdown语法看来写博客也是一件不省心的事情，就让我们按部就班一步步来看看各个环节的特性吧。 1.Hexo特性建议参考官方文档&emsp; &emsp;&emsp;&emsp;&emsp;1.1 修改layout布局：&emsp;&emsp;&emsp;&emsp;打开博客文件夹根目录下的[scaffolds]中的[post.md]文件，可以看到初始只有title/date/tags三种文件变量称作Front-matter,可以添加updated/categories等基本变量如下&emsp;&emsp;&emsp;&emsp;Tips:并列的tips需要使用- (-和空格)否则会编译出错 &emsp;&emsp;&emsp;&emsp;1.2 创建文章语法：1$ hexo new [layout] &lt;title&gt; &emsp;&emsp;&emsp;&emsp;1.3 Hexo自带语法：&emsp;&emsp;&emsp;&emsp;Hexo也有一些用于写作的不同于md的基本语法称作标签插件(Tag Plugins)比如引用块真是不知命运所馈赠的礼物，早已在暗中标明了价格。 茨威格断头王后比如代码块1alert(&apos;Hello World!&apos;); 2.Markdown语法&emsp;&emsp;&emsp;&emsp;Markdown语法很多很细致但是很简单，网上有很多文章介绍，这里我就推荐一个写的很好的博主文章供大家学习，相信很多人都是看这篇文章入门的，我就不露丑介绍了。 3.资源引用&emsp;&emsp;&emsp;&emsp;相信很多人在写博文为了增强用户体验都会插入一些图片表达，md中都是依靠链接来插入图片的，唯一不同的是这个链接是本地链接还是外部链接呢，本地链接无风险但是插入的图片会占据github空间而且不灵活不好分享毕竟我们写的博文都是需要部署到github上的，外部链接节省github空间但是万一失效了图片就显示不出来了俗称图片挂了，我个人原则是 小图片用本地链接大图片可以尝试外部链接，重要图片用本地链接稍微不那么关键的图片用外部链接。 &emsp;&emsp;&emsp;&emsp;3.1 本地链接的使用：&emsp;&emsp;&emsp;&emsp;本地链接的使用其实很简单，但是由于图片在本地路径和在生成($ hexo g)文件的路径并不相同，所以我的做法是首先将图片放在跟博文文件一个目录下，在本地预览完成需要部署的时候，再将图片剪切到[博客根目录/source/images/]文件夹里面同时要修改博文中对于图片的引用变成(/images/picture.png)因为编译后图片放在网站根目录的images中。 &emsp;&emsp;&emsp;&emsp;3.2 外部链接的使用：&emsp;&emsp;&emsp;&emsp;外部链接的使用其实就是利用一些网站服务器的空间来存储你的图片俗称图床，在博文中直接使用直接路径调用图片，如类似这种链接https://i.loli.net/2018/01/25/5a69a60eeda77.gif&emsp;&emsp;&emsp;&emsp;图床有许多，有免费的也有收费的，有些有浏览流量的限制，收费的我推荐七牛云,免费的我推荐SM.MS,用到现在还没有出现挂图的迹象。&emsp;&emsp;&emsp;&emsp;Tips：其实图床蛮多托的，有人建议直接放在github仓库上用绝对连接访问就好。 在repository的根目录下建立文件夹，然后将图片放在其中，在写链接的时候直接使用自己的GitHub Pages根路径加图片地址访问即可。 4.严格规范markdown语法&emsp;&emsp;&emsp;&emsp;Markdown语法看似简单，其实有许多坑需要踩。比如最简单的用[###]表示字体大小，也许在markdown编辑器上可以直接使用[###你好]表示，但是生成页面的时候却显示不出来，这是因为[#]的严格语法是[#+空格+内容]，缺少一个空格将会造成无法编译。还有一些小技巧，比如想打出空格,换行，底色等，最好还是用字符或者Html语法的形式，如下1234567&amp;emsp; //空格&lt;br&gt; //换行&lt;font face=&quot;微软雅黑&quot;&gt;&lt;/font&gt; //字号&lt;font color=red&gt;&lt;/font&gt; //字体颜色&lt;font color=#0099ff size=7&gt;&lt;/font&gt; //字体[1-7]&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=orange&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; //背景色--- //分割线 相信你已经初步了解怎么使用hexo和markdown语法写作了，你肯定迫不及待地想写下自己第一篇博文打了吧，去吧！","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://harviealwayshere.github.io/tags/Hexo/"},{"name":"GithubPages","slug":"GithubPages","permalink":"https://harviealwayshere.github.io/tags/GithubPages/"}]},{"title":"大三上寒假计划","slug":"planOfHoliday","date":"2018-01-27T09:13:41.000Z","updated":"2018-01-30T08:30:21.686Z","comments":true,"path":"2018/01/27/planOfHoliday/","link":"","permalink":"https://harviealwayshere.github.io/2018/01/27/planOfHoliday/","excerpt":"","text":"我的寒假学习计划同时也是博客的更新计划，大致有以下几个方面： 算法：LeetCode、牛客网、剑指Offer的题目解法总结 专业相关：机器学习的实践相关内容总结 实战：Laravel框架的学习和一个网页功能开发实战的更新总结 python：python相关的库使用，如爬虫、机器学习、可视化、游戏等 影评：休闲之时也会写一些影评推荐一些精品电影给大家（资源也会放出来） 每部分的更新频率不一定，但是会尽量面面俱到、频繁更新的，敬请期待哦！","categories":[{"name":"Life","slug":"Life","permalink":"https://harviealwayshere.github.io/categories/Life/"}],"tags":[{"name":"Plan","slug":"Plan","permalink":"https://harviealwayshere.github.io/tags/Plan/"}]},{"title":"使用github pages和hexo搭建个人博客","slug":"gitPagesAndHexo","date":"2018-01-14T12:51:14.000Z","updated":"2018-01-30T08:30:24.530Z","comments":true,"path":"2018/01/14/gitPagesAndHexo/","link":"","permalink":"https://harviealwayshere.github.io/2018/01/14/gitPagesAndHexo/","excerpt":"","text":"大致步骤可以分为6步 下载安装Node.js（可以使用npm下载和管理包） 申请github账户（用于注册github pages仓库） 下载git（最好是bash 便于使用命令行操作系统） 安装hexo并配置基本参数 安装hexo主题并配置基本参数 博客部署到github pages上线 1. 下载安装Node.js（可以使用npm下载和管理包）1.1访问Node.js中文官网下载安装包:根据你的操作系统和系统类型（位数）选择下载哪一个安装包Tips：32位安装包兼容64位操作系统，64位安装包不兼容32位操作系统&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;建议使用.msi格式一键安装&nbsp;&nbsp;1.2安装Node.js:&emsp;&emsp;&emsp;&emsp;.zip文件：运行node.exe文件会跳出命令行安装&emsp;&emsp;&emsp;&emsp;.msi文件:根据提示步骤安装（安装路径最好是全英文）1.3测试是否安装成功:&emsp;&emsp;&emsp;&emsp;1.3.1 打开命令提示符:&emsp;&emsp;&emsp;&emsp;windows系统下用+R）打开运行窗口输入cmd打开命令提示符&emsp;&emsp;&emsp;&emsp;1.3.2： 输入命令 node -v 和npm -v 查看node.js和npm是否安装成功：&emsp;&emsp;&emsp;&emsp; &emsp;&emsp;&emsp;&emsp; 若有版本号（不一定与我的相同）则安装成功 否则安装失败则重新安装即可 2. 申请github账户（用于注册github pages仓库）&emsp;&emsp;&emsp;&emsp;2.1 访问github官网注册账号&emsp;&emsp;&emsp;&emsp;2.3 申请一个仓库:&emsp;&emsp;&emsp;&emsp;登录你的github账号点击上方的New repository 如下图所示&emsp;&emsp;&emsp;&emsp;在Repository name上填写 [你注册的github名称.github.io] 即可&emsp;&emsp;&emsp;&emsp;如我注册的github名称是xxx则我的Repository name为 [xxx.github.io]&emsp;&emsp;&emsp;&emsp;其他的都不用填写 之后点击[Create repository]即可 3. 下载安装git（最好是bash 便于使用命令行操作系统） Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 此部分内容建议参考廖雪峰老师的git安装文档&emsp;&emsp;&emsp;&emsp;3.1 通俗来说git就是一个软件类似于cmd命令行，但是它可以使用git命令和linux命令来操控系统，这是cmd所做不到的。在此项目中，我们主要使用它来编写npm命令、hexo命令、git命令来生成和部署自己的博客到github pages上&emsp;&emsp;&emsp;&emsp;访问git下载页面下载对应系统的git &emsp;&emsp;&emsp;&emsp;安装完毕之后打开gitbash即可使用&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;首次使用git的用户还需配置自己的用户名和地址用于验证身份：12$ git config --global user.name &quot;Your Name&quot; $ git config --global user.email &quot;email@example.com&quot; &emsp;&emsp;&emsp;&emsp;3.2 将计算机的ssh key设置到你的github账号上，你才能将本地的文件上传到你的github上面&emsp;&emsp;&emsp;&emsp;具体操作可参考廖雪峰老师的ssh key设置教程 4. 全局安装hexo建立自己的博客并配置基本参数此部分内容建议参考hexo官方文档&emsp;&emsp;&emsp;&emsp; 4.1 全局安装hexo：&emsp;&emsp;&emsp;&emsp;访问hexo官方网站查看安装命令，运行Git Bash输入安装命令npm install hexo-cli -g&emsp;&emsp;&emsp;&emsp; 4.2 建立自己的博客：在Git Bash中输入123$ hexo init [你的博客文件夹名称] $ cd [你的博客文件夹名称] $ npm install&emsp;&emsp;&emsp;&emsp;我这里演示的文件夹名称是[testBlog]&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Tips:输入pwd可查看当前文件夹的路径&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&nbsp;输入explorer .可打开命令行当前文件夹&emsp;&emsp;&emsp;&emsp;如果看到以下内容，那么恭喜你hexo建站成功了&emsp;&emsp;&emsp;&emsp; &emsp;&emsp;&emsp;&emsp; 4.3 配置基本参数博客本地预览&emsp;&emsp;&emsp;&emsp;您可以在 _config.yml 文件中修改大部份的配置具体参数意义可参考官方文档&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;输入以下命令可在本地预览你生成的博客网址123$ npm install hexo-server --save $ hexo generate$ hexo server &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;你可以像我一样用[$ hexo g]和[$ hexo s]来简化命令&emsp;&emsp;&emsp;&emsp;[$ npm install hexo-server –save]用来安装hexo本地预览的服务器 只用第一次执行一次就可以了&emsp;&emsp;&emsp;&emsp;以后每次改动就只用[$ hexo g]生成文件和[$ hexo s]启动服务器就可以了&emsp;&emsp;&emsp;&emsp;之后在浏览器输入[http://localhost:4000]就可以查看你的博客页面了&emsp;&emsp;&emsp;&emsp; 5. 安装hexo主题并配置基本参数&emsp;&emsp;&emsp;&emsp;到目前为止，是不是觉得hexo默认的主题不符合你的心意，没关系，hexo爱好者们提供了上千个主题供你挑选使用，安装主题的方法也十分简单，让我们一起来让博客的面目焕然一新吧&emsp;&emsp;&emsp;&emsp;5.1 挑选你喜爱的主题下载&emsp;&emsp;&emsp;&emsp;可以参考官方主题推荐文档或者github大神整理来寻找自己喜欢的主题并按照对应主题的文档说明下载使用&emsp;&emsp;&emsp;&emsp;如我的博客采用的主题是Huemen下载就十分简单，按照官方文档按部就班即可&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;5.2 配置主题的基本参数：&emsp;&emsp;&emsp;&emsp;主题的配置是类似于hexo配置，修改主题文件下中的[_config.yml]文件即可具体每个参数的意义请参考主题的说明文档&emsp;&emsp;&emsp;&emsp;5.3 配置成功之后可运行命令预览自己的博客了（在博客根目录下运行命令）123$ hexo clean $ hexo g $ hexo s 6. 博客部署到github pages上线&emsp;&emsp;&emsp;&emsp;6.1 安装git pages部署器：在博客根目录下打开git bash运行[$ npm install hexo-deployer-git –save]命令&emsp;&emsp;&emsp;&emsp;6.2 修改博客根目录下的配置文件[_config.yml]中的deploy参数：123deploy: type: git repo: [你注册的github pages的仓库地址] &emsp;&emsp;&emsp;&emsp;6.3 部署至github上：12$hexo generate $hexo deploy &emsp;&emsp;&emsp;&emsp;或者1$hexo d -g&emsp;&emsp;&emsp;&emsp;成功之后你可以在线访问你的github pages地址[你的github仓库名.github.io]来查看你的博客了 恭喜你，你的博客已经搭建成功并上线了! 之后我会再写一篇文章介绍hexo写作的基本方法、使用markdown格式写作、图床的使用技巧等博文写作知识，敬请期待。","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://harviealwayshere.github.io/tags/Hexo/"},{"name":"GithubPages","slug":"GithubPages","permalink":"https://harviealwayshere.github.io/tags/GithubPages/"}]}]}