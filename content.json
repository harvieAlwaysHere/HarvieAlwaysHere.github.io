{"meta":{"title":"Harvie Blog","subtitle":"Fright For Better Day","description":"IT Blog","author":"Harvie Yao","url":"https://harviealwayshere.github.io"},"pages":[{"title":"about","date":"2018-01-30T09:37:04.000Z","updated":"2018-01-30T09:37:04.587Z","comments":true,"path":"about/index.html","permalink":"https://harviealwayshere.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"Swoole(二)了解基本函数","slug":"swoole2","date":"2018-02-14T17:55:02.000Z","updated":"2018-02-14T19:36:17.936Z","comments":true,"path":"2018/02/15/swoole2/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/15/swoole2/","excerpt":"","text":"接来下我们来学习Swoole的基本函数，以此来配置一个服务器1.基本函数1.1 swoole_server：创建一个异步Server对象。函数原型：$serv = new swoole_server(string $host, int $port = 0, int $mode = SWOOLE_PROCESS, int $sock_type = SWOOLE_SOCK_TCP); $host:指定监听的ip地址IPv4使用 127.0.0.1表示监听本机，0.0.0.0表示监听所有地址IPv6使用::1表示监听本机，:: (相当于0:0:0:0:0:0:0:0) 表示监听所有地址 $port:监听的端口如果$sock_type为UnixSocket Stream/Dgram，此参数将被忽略监听小于1024端口需要root权限如果此端口被占用server-&gt;start时会失败 $mode:运行的模式SWOOLE_PROCESS多进程模式（默认）SWOOLE_BASE基本模式 $sock_type:指定Socket的类型支持TCP、UDP、TCP6、UDP6、UnixSocket Stream/Dgram 6种 1.2 swoole_server-&gt;on：注册Server的事件回调函数。函数原型：bool swoole_server-&gt;on(string $event, mixed $callback); $event:回调的名称connect：建立连接时receive：接收到数据时close：关闭连接时 $callback:回调的PHP函数，可以是函数名的字符串，类静态方法，对象方法数组，匿名函数。connect：function ($serv, $fd){} $serv:服务器信息 $fd:客户端信息receive：function ($serv, $fd, $from_id, $data){} $from_id:客户端ID $data:接收的数据close：function ($serv, $fd){} $serv:服务器信息 $fd:客户端信息 1.3 swoole_server-&gt;start：启动server，监听所有TCP/UDP端口。函数原型：bool swoole_server-&gt;start()启动成功后会创建:Master进程+Manager进程+serv-&gt;worker_num个Worker进程 Master进程:主进程内有多个Reactor线程，基于epoll/kqueue进行网络事件轮询。收到数据后转发到worker进程去处理 Manager进程:对所有worker进程进行管理，worker进程生命周期结束或者发生异常时自动回收，并创建新的worker进程 Worker进程:对收到的数据进行处理，包括协议解析和响应请求。 启动失败会立即返回false启动成功后将进入事件循环，等待客户端连接请求。start方法之后的代码不会执行服务器关闭后，start函数返回true，并继续向下执行 1.4 swoole_server-&gt;send：向客户端发送数据。函数原型：bool swoole_server-&gt;send(int $fd, string $data, int $extraData = 0); $data:发送的数据TCP协议最大不得超过2M，可修改buffer_output_size改变允许发送的最大包长度UDP协议不得超过65507，UDP包头占8字节, IP包头占20字节，65535-28 = 65507 UDP服务器使用$fd保存客户端IP，$extraData保存server_fd和port 发送成功会返回true发送失败会返回false，调用$server-&gt;getLastError()方法可以得到失败的错误码 2.构建基本的TCP服务器使用上述三个函数就可以构建出一个基本的TCP服务器了12345678910111213141516171819202122&lt;?php//创建Server对象，监听 0.0.0.0:9501端口$serv = new swoole_server(&quot;0.0.0.0&quot;, 9501); //监听连接进入事件$serv-&gt;on(&apos;connect&apos;, function ($serv, $fd) &#123; echo &quot;Client: Connect.\\n&quot;;&#125;);//监听数据接收事件$serv-&gt;on(&apos;receive&apos;, function ($serv, $fd, $from_id, $data) &#123; $serv-&gt;send($fd, &quot;Server: &quot;.$data);&#125;);//监听连接关闭事件$serv-&gt;on(&apos;close&apos;, function ($serv, $fd) &#123; echo &quot;Client: Close.\\n&quot;;&#125;);//启动服务器$serv-&gt;start(); 之后我们把tcpServer.php上传到服务器上在服务器端运行这个脚本我们可以再次连接服务器，通过查看进程确认脚本是否执行首先可以看到有一个进程-bash在使用一个子进程ps -ajft查看进程，这个bash就是我们连接服务器的进程然后可以看到有一个进程-bash有三个子进程在执行，可以看出分别是Master进程(32680)、Manager进程(32681)和Worker进程(32683)此时我们可以通过客户端使用网络工具来连接服务器（x为ip地址，y为端口号），我使用的是windows自带的telnet服务，具有TCP连接功能，如何开启请看这里可以看到成功连接并且实现了向客户端返回数据的功能，若是无法正常连接，可能有如下三种原因 在Linux下，使用netstat -an | grep 端口，查看端口是否已经被打开处于Listening状态，若处于可以看看是什么哪个进程在使用这个端口，并用kill -9 进程号(PID)，结束这个进程重新开放端口 上一步确认后，检查防火墙问题，最好使用命令systemctl stop firewalld.service 注意服务器所使用的IP地址，如果是127.0.0.1回环地址，则客户端只能使用127.0.0.1才能连接上 若是阿里云服务器，记得在阿里云控制台中安全组设置开放外界端口号 这时我们的基本的tcp服务器就已经搭建好了，若需要关闭这个进程，可以使用kill -9 进程号关闭掉Master的父进程-bash(32618)即可，此时再使用ps -ajft和netstat -an | grep 9501，可看到进程结束并且端口不再处于监听状态即可 我们搭建基本tcp服务器的过程就结束了，接下来我们将会学习如何搭建别的类型服务器，如UDP、Web、Websocket、异步TCP，还有一些队列通信、信号触发、DNS查询、异步文件IO、异步mysql等。","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"php项目","slug":"php项目","permalink":"https://harviealwayshere.github.io/tags/php项目/"},{"name":"swoole","slug":"swoole","permalink":"https://harviealwayshere.github.io/tags/swoole/"}]},{"title":"剑指Offer算法记录(二)算法","slug":"offer2","date":"2018-02-14T10:24:24.000Z","updated":"2018-02-14T12:07:04.290Z","comments":true,"path":"2018/02/14/offer2/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/14/offer2/","excerpt":"","text":"本文主要记录阅读剑指Offer这本书所遇到的算法解释并作一些个人的拓展 第二章2.4 算法和数据操作排序和查找是面试时考查算法的重点，如二分查找、归并排序、快速排序等。递归和循环是两种算法实现的方式，基于递归的实现较整洁但性能不如基于循环实现的方法，我们应该根据题目特点来选择使用哪种实现方式。 位运算可以看做一类特殊的算法，共有与、或、异或、左移和右移五种位运算2.4.1 查找和排序查找不外乎：顺序查找、二分查找、哈希表查找和二叉排序树查找，无论用递归还是循环都需要掌握这些查找方法的实现。排序则复杂一些：插入排序、冒泡排序、归并排序、快速排序等不同算法的优劣，能够从额外空间消耗、平均时间复杂度和最差时间复杂度等方面去比较它们的优缺点。值得一提的是，快速排序的实现代码是面试官钟爱的。快速排序思路:选择一个数字(有多种选择法)，接下来把数组中的数字分成两部分，比选择的数字小的数字移到数组的左边，比选择数字大的数字移到数组右边1234567891011121314151617181920212223int Partition(int data[], int length, int start, int end)&#123; if(data==NULL || length&lt;=0 || start&lt;0 || end&gt;=length) //输入参数有效行检验 throw new std::exception(&quot;Invalid Parameters&quot;); int index = RandomInRange(start,end); //函数RandomInRange生成[start,end]的随机数 Swap(&amp;data[index], &amp;data[end]); int small = start-1; for(index=start; index&lt;end; index++) &#123; if(data[index]&lt;data[end]) &#123; small++; if(small!=index) Swap(&amp;data[index], &amp;data[small]); &#125; &#125; small++; Swap(&amp;data[small], &amp;data[end]); return small;&#125;","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://harviealwayshere.github.io/tags/算法/"}]},{"title":"Swoole(一)安装","slug":"swoole1","date":"2018-02-09T16:29:04.000Z","updated":"2018-02-09T17:55:49.101Z","comments":true,"path":"2018/02/10/swoole1/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/10/swoole1/","excerpt":"","text":"说到PHP异步网络通信框架，相信PHPer脑海里第一个浮现的便是Swoole。 商业应用：IM聊天、战旗TV、虎牙直播、YY语音等。 应用领域：互联网、网络通信、企业软件、云计算、网络游戏、物理网等。 特点：1.异步、并行、高性能2.纯C编写，接近应用底层3.php扩展 应用：1.异步多线程服务器及客户端2.异步MySQL、Redis、数据库连接池、任务队列3.http/websocket服务器/客户端4.异步文件读写5.Swoole2.0支持协程 安装Swoole大致可分成3个步骤:1.搭建Linux操作系统2.安装环境依赖(php,gcc,httpd，pecl)3.安装Swoole并修改php.ini Part1:搭建Linux操作系统查看官方文档可知Swoole并不支持Windows系统，所以我们这里搭建一个CentOS 7.3 64位的操作系统，我是使用阿里云云服务器 ECS搭建的，使用系统盘安装即可，安装完毕之后可以远程连接进入云服务器中的Linux系统中Tips:如果想在Windows下便捷操作云服务器的系统，推荐使用SSH连接软件，这里我使用的是SSH Secure Shell Client3.2.9，安装完成后有两个工具可以使用，分别对应Linux系统的命令行界面和Linux文件系统的GUI界面的，十分便捷客观，提供工作效率。可参考这篇博客安装使用。连接成功后的界面为 Part2:安装环境依赖(php,gcc,httpd，pecl)在CentOS中使用yum安装php7，由于初始yum所安装的php版本是5.*的，我们首先要获取php7的yum源1234567891011//1.安装epel-releaseyum -y install epel-release //2.获取php7的yum源rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm//3.安装php7yum install php70w//4.验证安装php -v安装完成后可看到php版本之后我们要安装gcc和httpd1yum install httpd gcc最后我们要安装pecl，因为swoole项目已收录到PHP官方扩展库，可直接使用pecl安装swoole12wget http://pear.php.net/go-pear.pharphp go-pear.phar Part3:安装Swoole并修改php.ini1sudo pecl install swoole 会报错如下，别着急输入1vi `which pecl`进入Linux的Vim编辑模式，一直向下查找找到这个文件的最后一行按I进入Vim的插入模式，之后将-n标志去掉，按ESC进入Vim的退出(末行)模式，输入[:wq!]保存并退出之后安装 php-devel1sudo yum install php70w-devel再次安装swoole1sudo pecl install swoole成功安装！根据提示要添加”extension=swoole.so”在php配置文件php.ini中，我这里由于对于Vim的操作并不熟悉，我直接通过SSH软件将php.ini文件拉取到本地之后修改再上传到服务器php.ini一般在/etc目录下拉取到本地后添加”extension=swoole.so”语句，随意在任何两个配置语句中增加之后通过语句[php -m]可查看php拓展安装情况，如果看到swoole则安装成功！ 如果你实践完成了本教程，意味着你对于Linux和Windows系统的协同开发、php拓展安装已经了解了基本情形了，接下来我们将使用swoole开发php应用，敬请期待。","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"php项目","slug":"php项目","permalink":"https://harviealwayshere.github.io/tags/php项目/"},{"name":"swoole","slug":"swoole","permalink":"https://harviealwayshere.github.io/tags/swoole/"}]},{"title":"剑指Offer算法记录(一)数据结构","slug":"offer","date":"2018-02-07T08:20:05.000Z","updated":"2018-02-14T10:24:04.055Z","comments":true,"path":"2018/02/07/offer/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/07/offer/","excerpt":"","text":"本文主要记录阅读剑指Offer这本书所遇到的算法解释并作一些个人的拓展 第二章2.2.1 关于sizeof的小知识 sizeof 对于空类型(无成员变量和成员函数)的实例 = 1字节：由于声明空类型的实例必须在内存中占用一定空间否则无法使用，占用多少内存由编译器决定，在VS中每个空类型实例占用1字节。 sizeof 对于空类型+构造和析构函数的实例 = 1字节 ：调用函数只需知道函数地址即可，函数地址只与类型有关而与类型的实例无关，因此sizeof实例还是1字节。 sizeof 对于空类型+构造函数+虚析构函数(虚函数) = 1个指针大小：一个类型中有虚拟函数就会为该类型生成虚函数表，并为这个类型的每个实例中添加一个指向虚函数表的指针，指针大小与机器有关，32为指针为4字节，64位指针为8字节。1234567891011121314151617181920212223242526class B //空类型&#123;&#125;;class C //空类型+构造和析构函数&#123;public: C()&#123;&#125;; ~C()&#123;&#125;;&#125;;class D //空类型+构造函数+虚析构函数(虚函数)&#123;public: D()&#123;&#125;; virtual ~D()&#123;&#125;;&#125;;int main()&#123; B b; C c; D d; cout &lt;&lt; &quot;空类型大小:&quot; &lt;&lt; sizeof(b)&lt;&lt;endl; cout &lt;&lt; &quot;空类型+构造和析构函数大小:&quot; &lt;&lt; sizeof(c) &lt;&lt; endl; cout &lt;&lt; &quot;空类型+构造函数+虚析构函数(虚函数)大小:&quot; &lt;&lt; sizeof(d) &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 总结：空的类是会占用内存空间的，而且大小是1，原因是C++要求每个实例在内存中都有独一无二的地址。 类内部的成员变量：*普通的变量：是要占用内存的，但是要注意对齐原则（这点和struct类型很相似）。*static修饰的静态变量：不占用内容，原因是编译器将其放在全局变量区。 类内部的成员函数：*普通函数：不占用内存。*虚函数：要占用4个字节，用来指定虚函数的虚拟函数表的入口地址。所以一个类的虚函数所占用的地址是不变的，和虚函数的个数是没有关系的 2.2.1 关于复制函数的小知识C++标准不允许复制构造函数传值参数，否则会造成递归重复调用，编译错误。12345678910111213141516171819202122232425262728293031323334353637383940class E&#123;private: int num;public: //构造函数 E(int x) :num(x) &#123; cout &lt;&lt; &quot;constructor call&quot; &lt;&lt; endl; &#125; //复制构造函数 传引用调用 E(E&amp; x) &#123; num = x.num; cout &lt;&lt; &quot;copy constructor call&quot; &lt;&lt; endl; &#125; //赋值运算符重载 E&amp; operator = (E&amp; x) &#123; num = x.num; cout &lt;&lt; &quot;assignment operator call&quot; &lt;&lt; endl; return *this; &#125; //函数调用 void showNum(E x) &#123; &#125; &#125;;int main()&#123; E a(1); //1式 E b(2); //2式 b = a; //3式 E c = a; //4式 c.showNum(a); //5式 system(&quot;pause&quot;); return 0;&#125;运行结果如图： 1/2式 =&gt; 若是实例创建并初始化时调用相应参数的构造函数 3式 =&gt; 若是实例已经创建初始化后再用=赋值，则调用=重载赋值函数 4式 =&gt; 若是实例用另一个同类实例初始化，则调用复制构造函数 5式 =&gt; 若是实例使用方法调用另一个实例，则首先调用复制构造函数将实参复制给形参后执行相关操作 因此就可以解释为什么C++不允许复制构造函数传值了，若是传值，则调用E c = a或者c.showNum(a)或者的时候，a作为参数传值给c的复制构造函数的参数E x，因为x没有被初始化，所以要调用x的复制构造函数将a复制给x，即x.E(a)，然而x的复制构造函数也是传值的，因此又要将a作为参数传值给c的复制构造函数的参数x的复制构造函数的参数E x，又因为这个x也没有被初始化，又要调用这个x的复制构造函数，造成了无限的递归。因此复制构造函数的参数使用引用调用不是为了减少一次内存的复制，而是为了避免复制构造函数无限递归调用的情况出现。下面这几种情况下会调用复制构造函数:（1）显式或隐式地用同类型的一个对象来初始化另外一个对象。如上例中的E c=a;（2）作为实参传递给一个函数。如上例中的c.showNum(a);（3）在函数体内返回一个对象时，也会调用返回值类型的拷贝构造函数（4）初始化序列容器中的元素时。比如vector svec(5)，string的缺省构造函数和拷贝构造函数都会被调用。（5）用列表的方式初始化数组元素时。string a[] = {string(“hello”),string(“world”)};会调用string的拷贝构造函数。 面试题 1：赋值运算符函数赋值运算符函数基础4要数:1.返回值类型声明为该类型的引用并在函数结束前返回实例自身引用：只有这样才能实现连续赋值运算2.参数类型声明为常量引用:常量是因为在函数体内不改变传入实参状态，引用是可以减少一次从形参到实参的复制构造函数的调用，节省空间开销提高代码效率3.释放实例自身已有内存:在分配新内存之前释放已有空间，避免内存泄露4.需要判断传入参数和当前实例(*this)是不是同一个实例:若是同一个则不进行赋值直接返回，若没有判断则在释放实例自身内存时传入的参数的内存也被释放了，就再也找不到需要赋值的内容了结合以上4点的解法1234567891011CMyString&amp; CMyString::operator =(const CMyString &amp;str) //返回值+参数(1.2.)&#123; if(this == $str) return *this; //判断是否是自身赋值自身(4.) delete []m_pData; //被赋值的实例的成员变量delete释放内存(3.) m_pData = NULL; //初始化变量 m_pData = new char[strlen(str.m_pData)+1]; //new分配内存 strcpy(m_pData,str.m_pData); //赋值 return *this; //返回自身实例用于连续赋值运算(1.)&#125; 考虑异常安全性:若new char时内存不足导致抛出异常，m_pData将是空指针，程序十分容易崩溃，此时由于被赋值的实例的成员变量已经被delete了，实例改变了自身的状态，违背了异常安全原则。解决方案:1.先new分配内存再delete释放内存，当new失败时我们能确保实例不会被修改原先状态2.先创建一个临时实例，再交换临时实例和原来的实例，如下1234567891011121314CMyString&amp; CMyString::operator =(const CMyString &amp;str) &#123; if(this != $str) &#123; CMyString strTemp(str); //调用复制构造函数新创建一个临时实例 char* pTemp = strTemp.m_pData; //利用一个中间变量pTemp将变量值交换 strTemp.m_pData = m_pData; m_pData = pTemp; &#125; //在if作用域外，由于strTemp是局部变量会自动调用析构函数释放内存，//其中strTemp中的成员变量m_pData所指向的内存就是原来被赋值实例成员函数的内存，刚好一并释放 return *this;&#125; 面试题 2：实现Singleton（单例）模式首先单例模式最基本的有3点：1.构造函数私有:不能被外界随意调用2.单例对象实例:此类型只能生成一个实例3.单例获取函数:只能获取到同一个实例基于这三点我们可以写出第一版单例模式123456789101112public class Singleton1&#123; private Singleton1()&#123;&#125; //私有构造函数 private static Singleton1 instance = NULL; //单例对象实例 public static Singleton1 getInstance() //单例获取函数 &#123; if(instance == NULL) instance = new Singleton1(); return instance; &#125;&#125;//其中第四行我们也可以写成private static Singleton1 instance = new Singleton1();//这样在getInstance()中就不需要判空操作，这属于饿汉模式(主动创造)，一开始初始值是NULL属于懒汉模式(等人调用才创造)第二版单例模式:第一版的单例模式是非线程安全的，当最初情况两个线程同时判断instance是否为空时(针对懒汉模式)，则两个线程会创建两个实例不满足单例模式要求，因此在多线程下我们要加上一个同步锁12345678910111213141516171819202122232425public class Singleton2&#123; private Singleton2()&#123;&#125; private static Singleton1 instance = NULL; private static object syncObj = new object(); //C#同步锁 public static Singleton2 getInstance() &#123; if(instance == NULL) //一次检测:只有instance为NULL时需要加锁操作，节省开销 &#123; lock(syncObj) &#123; //二次检测:当两个进程同时访问，线程A创建完对象开锁后 //线程B还是会进入临界区创建对象，因此需要第二次检测 if(instance == NULL) instance = new Singleton1(); &#125; &#125; return instance; &#125;&#125;//其中第十二行只是C#同步锁的操作，JAVA中可使用synchronized(Singleton2.class)&#123;&#125;操作第三版单例模式:C#中有一个函数确保只调用一次，就是静态构造函数(饿汉模式)123456789public class Singleton3&#123; private Singleton3()&#123;&#125; private static Singleton3 instance = new Singleton3(); //由于C#在调用静态构造函数时初始化静态变量，.NET运行时能够确保只调用一次静态构造函数 public static Singleton3 getInstance() &#123; return instance; &#125;&#125;第四版单例模式:按需创造/懒加载 JAVA中可以使用静态内部类1.因为从外部无法访问静态内部类，只有调用Singleton.getInstance方法才能得到单例对象INSTANCE2.INSTANCE对象初始化并不是在类Singleton被加载时，而是在调用getInstance方法时加载静态内部类LazyHolder时才被初始化，这种方式是利用classloader的加载机制实现懒加载（需要时才创建），从而保证偶见单例的线程安全1234567891011121314public class Singleton4&#123; private Singleton4()&#123;&#125; private static class LazyHolder //静态内部类 &#123; private static final Singleton INSTANCE = new Singleton4(); &#125; public static Singleton4 getInstance() &#123; return LazyHolder.INSTANCE; &#125;&#125; C++中可以使用嵌套类型123456789101112131415public class Singleton4&#123; private Singleton4()&#123;&#125; class Nested //嵌套类型 &#123; static Newted()&#123;&#125; //嵌套类型的构造函数 internal static readonly Singleton4 instance = new Singleton4(); &#125; public static Singleton4 getInstance() &#123; return Nested.instance; &#125;&#125;第五版单例模式:无论怎么样设计单例模式，均可以通过反射打破单例反射打破单例过程：123456789//第一步：获得单例类的构造器Constructor con = SingletonEnum.class.getDeclaredConstructor();//第二步：把构造器设置为可访问con.setAccessible(true);//第三步：使用newInstance构造不同的对象SingletonEnum singleton1 = (SingletonEnum)con.newInstance();SingletonEnum singleton2 = (SingletonEnum)con.newInstance();//验证是否是同一对象 =&gt; falseSystem.out.println(singleton1.equals(singleton2));针对防止反射的方式构建对象，在JAVA中可以使用枚举的方式构建类，因为JAM会住址反射获取枚举类的私有构造方法，这还可以实现线程安全性，但是唯一的缺点就是并非使用懒加载，单例对象是在枚举类被加载的时候进行初始化的。1234//枚举实现单例模式public enum SingletonEnum&#123; INSTANCE;&#125; 总结：单例模式升级步骤——基本模式(1.)+线程安全(2.)+懒加载(提升使用效率)(3.4.)+防止反射构建(5.)2.3 数组和指针区别输出 “20,4,4”20：data1是一个数组，包含五个整数，每个整数占4字节，一共20字节4：data2是一个指针指向data1数组的第一个数字，指针大小为4字节4：在C/C++中数组作为参数传递时自动退化为同类型的指针，因此为4字节 面试题3：二维数组中的查找一般的思路是从左上角开始做比较，但是减小排除的范围无规律，若是从右上角或者左下角做比较，则可以以行或者列减小排查范围，而二维数组以连续内存存储的特性让我们可以通过下标访问数组以矩阵形式的空间位置。1234567891011121314151617181920212223bool Find(int* matrix, int rows, int columns, int number)&#123; bool found = false; if(matrix != NULL &amp;&amp; rows &gt;0 &amp;&amp; columns &gt;0) //矩阵有效性检测（若输入空指针） &#123; int row = 0; int column = column -1; while(row &lt; rows &amp;&amp; column &gt;=0) //循环停止条件:最后一行或者第一列 &#123; if(matrix[row * columns + column] == number) //第row行第column列，相当于[row][column] &#123; found = true; break; &#125; else if(matrix[row * columns + column] &gt;number) column--; else row++; &#125; &#125; return found;&#125; 2.3.2字符串小知识C/C++中每个字符串以’/0’作为结尾，这样可以方便地找到字符串的结尾，但有额外字符开销，易越界。C/C++将常量字符串放到一个单独的内存区域节省内存，当几个指针赋值给相同的常量字符串时，他们实际上会指向相同的内存地址，但是用常量内存初始化数组却会创建新空间。 面试题4：替换空格网络编程中，URL参数中特殊字符串(空格、#等)需要替换成服务器端可以识别的字符，转换的规则是在’%’后面加上字符ASCII码的两位十六进制表示，如空格的ASCII码为32，十六进制为0x20，因此空格被替换成”%20”。解题思路:题目理解有两种，第一种是创建新的字符串并在新的字符串上做替换，则我们可以分配足够多的内存，第二种是在原字符串上做替换，则我们需要保证输入字符串后有足够多的空余内存并且不能覆盖原字符串的内存。解法一:字符串从前往后遍历找到一个空格则空格后的字符集体向后移动两个字节大小。时间复杂度为O(n^2)，多次移动次数，不是好的解决方案。解法二:先遍历一次字符串，统计出字符串中空格总数由此计算出替换后字符串的长度，之后从字符串末尾开始复制和替换，这样所有字符只移动一次，算法的时间效率是O(n)。具体的复制和替换过程为使用两个指针 123456789101112131415161718192021222324252627282930313233343536373839404142void ReplaceBlank(char string[], int maxLength)&#123; if(string == NULL &amp;&amp; length &lt;= 0) //输入参数有效性检测性 return; //originalLength为字符串原先长度 int originalLength = 0; int numberOfBlank = 0; int i = 0; while(string[i] != &apos;\\0&apos;) &#123; originalLength++; if(string[i] == &apos; &apos;) numberOfBlank++; i++; &#125; //newLength为替换后的字符串长度 int newLength = originalLength + numberOfBlank * 2; if(newLength &gt; maxLength) //如果替换后字符串长度大于字符串总容量 return; int indexOfOriginal = originalLength; int indexOfNew = newLength; while(indexOfOriginal &gt;= 0 &amp;&amp; indexOfNew &gt; indexOfOriginal)//替换完成条件 &#123; //若是空格则后面的标记添加并前移三个字节 if(string[indexOfOriginal] == &apos; &apos;) &#123; string[indexOfNew --] = &apos;0&apos;; string[indexOfNew --] = &apos;2&apos;; string[indexOfNew --] = &apos;%&apos;; &#125; else &#123; //若不空格则复制前面指针的字符到后面指针的位置，并前移指针 string[indexOfNew --] = string[indexOfOriginal]; &#125; -- indexOfOriginal; &#125; &#125;2.3.3 链表小知识链表是由指针把若干个节点连接成链状结构，链表的创建、插入节点、删除节点等操作只需要20行代码就可以实现，比较适合面试。链表是一种动态结构，创建时无需知道链表的长度，每添加一次节点再分配新内存，然后调整指针的指向。单向链表的节点定义如下12345struct ListNode&#123; int Value; ListNode* Next;&#125;往链表末尾添加一个节点的函数如下要点：1.头指针的传参 2.插入的节点是第一个节点的情况(空链表/头指针为空)1234567891011121314151617181920void addToTail(ListNode** pHead, int value) //由于头指针可能改变，因此要以传指针的形式传参，否则出了函数头指针依然是空指针&#123; ListNode* pNew = new ListNode(); pNew-&gt;Value = value; pNew-&gt;Next = NULL; //注意新节点的Next初始化为NULL if(*pHead == NULL) //若是往一个空链表插入节点，则头指针指向新节点 &#123; *pHead = pNew; &#125; else //否则找到头指针指向第一个节点，开始遍历找到最后一个节点，将节点的Next指向新节点 &#123; ListNode* pNode = *pHead; while(pNode-&gt;Next != NULL) pNode = pNode-&gt;Next; pNode-&gt;Next = pNew; &#125;&#125;在链表中找到第一个含有某值的节点并删除该节点的函数如下要点： 123456789101112131415161718192021222324252627282930void removeNode(ListNode** pHead, int value)&#123; if(pHead == NULL || *pHead == NULL) //空链表直接返回 return; ListNode* pToBeDelete = NULL; //找到需要删除的节点 if((*pHead)-&gt;Value == value) //当第一个节点是需要删除的节点，则需要改变头指针的指向 &#123; pToBeDelete = *pHead; *pHead = (*pHead)-&gt;Next; &#125; else //否则开始遍历节点 &#123; ListNode* pNode = *pHead; while(pNode-&gt;Next != NULL &amp;&amp; pNode-&gt;Next-&gt;Value != value) //遍历到最后一个节点或者找到需要删除的节点的前一个节点则停止遍历 pNode = pNode-&gt;Next; if(pNode-&gt;Next != NULL &amp;&amp; pNode-&gt;Next-&gt;Value ==value) //找到需要删除的节点的前一个节点 &#123; pToBeDelete = pNode-&gt;Next; pNode-&gt;Next = pNode-&gt;Next-&gt;Next; //这里包含了当需要删除的节点是最后一个节点的情况，若是最后一个节点则它的前一个节点会指向NULL &#125; &#125; if(pToBeDelete != NULL) &#123; delete pToBeDelete; pToBeDelete = NULL; &#125;&#125;面试题5：从尾到头打印链表面试中如果我们打算修改输入数据，最好先问面试官允不允许。若允许我们可以将链表中的节点指针反转改变链表方向就可以了。通常打印是一个只读操作，假设面试官要求这个题目不能改变链表结构。思路：遍历是从头到尾，输出却是从尾到头，这是典型的后进先出的栈结构，然后递归的本质就是栈结构，于是我们可以每访问一个节点先递归输出它后面的节点，再输出该节点自身。显示用栈调用代码如下12345678910111213141516171819//Reversingly-倒置地void printListReversingly(ListNode* pHead) //不用改变头指针，可传值&#123; std::stack&lt;ListNode*&gt; nodes; ListNode *pNode = pHead; while(pNode != NULL) &#123; node.push(pNode); //入栈 pNode = pNode-&gt;Next; &#125; while(!node.empty()) &#123; pNode = nodes.top(); //取栈顶元素 cout &lt;&lt; pNode-&gt;Value &lt;&lt; endl; //输出节点值 nodes.pop(); //弹出栈顶元素 &#125;&#125;基于递归的栈调用代码如下 12345678910//Recursively-递归地void printListReversinglyRecursively(ListNode* pHead) //不用改变头指针，可传值&#123; if(pHead != NULL) //判断是不是空链表 &#123; if(pHead-&gt;Next != NULL) printListReversinglyRecursively(pHead-&gt;Next); //判断是不是最后一个结点，若是最后一个结点则递归结束 cout &lt;&lt; pHead-&gt;Value &lt;&lt; endl; &#125; &#125;Tips:链表长时，导致函数调用层级很深，有可能导致函数调用栈移除，鲁棒性(程序稳定性)不好。2.3.4 树小知识树是一种数据结构: 除了根节点外每个节点只有一个父节点，根节点没有父节点 除了叶节点外每个节点有一个或多个子节点，叶节点没有子节点 父节点与子节点之间用指针连接 二叉树：树的特殊结构，每个节点最多有两个子节点遍历方式： 前序：根-左-右 中序：左-根-右 后序：左-右-根 宽度优先：按照层的顺序从顶到底遍历，同一层的节点按从左到右遍历 二叉搜索树：左节点小于等于根节点，右节点大于等于根节点的二叉树堆：最大堆中根节点的值最大，最小堆中根节点的值最小红黑树：把树中的节点定义为红、黑两种颜色，并通过规则确保从根节点到叶节点的最长路径的长度不超过最短路径的两倍，C++中STL中set、multiset、map、multimap等数据结构都是基于红黑树实现的 面试题6：重建二叉树思路：前序遍历可以确定树的根节点(第一个数字)，中序遍历在知道了根节点的值后可以知道左子树的结点值(根节点左边的所有值)和右子树的结点值(根节点右边的所有值)，之后用递归的方式完成剩下子树的建立12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//树的主构造函数BinaryTreeNode* Construct(int* preorder, int* inorder, int length)&#123; if(preorder == NULL || inorder == NULL || length &lt;= 0) //输入有效性检测 return NULL; return ConstructCore(preorder, preorder+length-1, inorder, inorder+length-1);&#125;//树的核心构造函数，通过传入前序遍历的头尾指针、中序遍历的头尾指针递归建树BinaryTreeNode* ConstructCore(int* startPreorder, int *endPreorder, int* startInorder, int* endInorder)&#123; //前序遍历的第一个数字是根节点的值 int rootValue = startPreorder[0]; BinaryTreeNode* root = new BinaryTreeNode(); root-&gt;m_nValue = rootValue; root-&gt;m_pLeft = root-&gt;m_pRight = NULL; if(startPreorder == endPreorder) &#123; //若是输入的树前序只有一个值、中序也只有一个值且这两个值是同一个值 //则输入的这个值就是这棵树的根节点，否则是无效输入 if(startInorder == endInorder &amp;&amp; *startPreorder == *startInorder) return root; else throw std::exception(&quot;Invalid input&quot;); &#125; //在中序遍历中找到根节点的值 int* rootInorder = startInorder; while(rootInorder &lt;= endInorder &amp;&amp; *rootInorder != rootValue) rootInorder++; //如果找到的节点在中序的末尾且值并不是根节点的值，返回错误 if(rootInorder == endInorder &amp;&amp; *rootInorder != rootValue) throw std::exception(&quot;Invalid input&quot;); //可以通过找到的节点确定左子树长度和左子树范围 int leftLength = rootInorder - startInorder; int* leftPreorderEnd = startPreorder + leftLength; if(leftLength &gt;0) &#123; //构建左子树 root-&gt;m_pLeft = ConstructCore(startPreorder+1,leftPreorderEnd,startInorder,rootInorder-1); &#125; if(leftLength &lt; endPreorder-startPreorder) &#123; //构建右子树 root-&gt;m_pRight = ConstructCore(leftPreorderEnd+1,endPreorder,rootInorder+1,endInorder); &#125; return root;&#125;让我们来看看ConstructCore做了什么事 2.3.5 栈和队列小知识栈：先进先出，即最后入栈(push)的元素会第一个被弹出(pop) 队列：先进先出，即第一个进入队列的元素会第一个出来面试题7：用两个栈实现队列思路：插入元素直接插入第一个栈即可，删除元素则若是第二个栈有元素就pop，若是第二个栈没有元素，则将第一个栈的元素全部pop并push进第一个栈，之后按照第二个栈有元素的方式pop123456789101112131415161718192021222324252627//元素入队template&lt;typename T&gt; void CQueue&lt;T&gt;::appendTail(const T&amp; element)&#123; stack1.push(element);&#125;//元素出队template&lt;typename T&gt; T CQueue&lt;T&gt;::deleteHead()&#123; if(stack2.size() &lt;= 0) //stack2空则将stack1全部弹出压如stack2 &#123; while(stack1.size() &gt; 0) &#123; T&amp; data = stack1.top(); stack1.pop(); stack2.push(data); &#125; &#125; //此时若是stack2还是空，则证明队列是空的 if(stack2.size() = 0) throw new exception(&quot;queue is empty&quot;); T head = stack2.top(); //否则弹出栈顶元素 stack2.pop(); return head;&#125;两个栈实现一个队列像是一个是插入栈一个是删除栈，而两个队列实现一个栈呢？思路如下","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://harviealwayshere.github.io/tags/数据结构/"}]},{"title":"C++基础语法","slug":"cplusplus","date":"2018-01-31T07:31:56.000Z","updated":"2018-02-07T08:09:25.136Z","comments":true,"path":"2018/01/31/cplusplus/","link":"","permalink":"https://harviealwayshere.github.io/2018/01/31/cplusplus/","excerpt":"","text":"刚想刷剑指offer和leetcode上的题目，本来享用python写的，毕竟是刷算法感觉无论是什么语言总是相通的，但看到剑指offer上写到 大一学的C++基础语法都忘记的差不多了，还是先来巩固一下C++基础语法，本文以runoob和C++ Primer(第五版)为基础编写。 Part1：C++基础语法标准的 C++ 由三个重要部分组成： 核心语言，提供了所有构件块，包括变量、数据类型和常量，等等。 C++ 标准库，提供了大量的函数，用于操作文件、字符串等。 标准模板库（STL），提供了大量的方法，用于操作数据结构等。 C++面向对象四大特点:封装、抽象、继承和多态。 C++基本程序结构：12345678#include &lt;iostream&gt; //添加头文件using namespace std; //使用std命名空间 int main() //主函数，程序执行入口&#123; cout &lt;&lt; &quot;Hello World&quot;; // 输出 Hello World return 0; //终止main函数并返回0值&#125; C++内置数据类型：类型&emsp;&emsp;&emsp;&emsp;关键字&emsp;&emsp;&emsp;&emsp;内存(字节)布尔型 &emsp;&emsp;&emsp;bool&emsp;&emsp;&emsp;&emsp;&emsp;1字符型 &emsp;&emsp;&emsp;char&emsp;&emsp;&emsp;&emsp;&emsp;1整型 &emsp;&emsp;&emsp;&emsp;int&emsp;&emsp;&emsp;&emsp;&emsp;&nbsp;&nbsp;&nbsp;4浮点型 &emsp;&emsp;&emsp;float&emsp;&emsp;&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;4双浮点型 &emsp;&emsp;double&emsp;&emsp;&emsp;&emsp;8无类型 &emsp;&emsp;&emsp;void&emsp;&emsp;&emsp;&emsp;&emsp;宽字符型 &emsp;&emsp;wchar_t&emsp;&emsp;&emsp;&nbsp;&nbsp;4一些类型可用修饰符修饰:signed,unsigned,short,long.Tip:其实知道了字节数很简单计算范围，1字节=8位，每位存储一个二进制0/1，有几位二进制则可以存储2^位数范围大小的数字。Tip:存储有符号数的时候，例如int，虽然是4字节的，但是只能是1符号位+31数值为位，所以最大为2^31=2147483647。可以使用typedef为一个已有的类型取一个新的名字:typedef type newname;12typedef int SSS;SSS a = 2; 枚举类型(enumeration)：是C++中的一种派生数据类型，它是由用户定义的若干枚举常量的集合:语法为:enum name {IDentifier0[=int 0],IDentifier1=[int 1]} Variable;12enum color &#123; red, green, blue &#125; c; //定义变量c是枚举类型colorc = blue; //c赋值为blue 变量声明和定义:您可以使用extern关键字在任何地方声明一个变量。虽然您可以在 C++ 程序中多次声明一个变量，但变量只能在某个文件、函数或代码块中被定义一次。123456789101112// 变量声明extern int a; //可进行多次int main ()&#123; // 变量定义 //仅可进行一次 int a; // 实际初始化 a = 10; return 0;&#125; 函数声明和定义:在函数声明时，提供一个函数名，而函数的实际定义则可以在任何地方进行。1234567891011121314// 函数声明int func();int main ()&#123; // 函数调用 int i = func(); return 0;&#125;// 函数定义int func()&#123; return 666;&#125; 变量作用域: 在函数或一个代码块内部声明的变量，称为局部变量。 在函数参数的定义中声明的变量，称为形式参数。 在所有函数外部声明的变量，称为全局变量。 初始化:定义全局变量时，系统会根据数据类型自动初始化；定义局部变量时，系统不会自动初始化。 C++常量:定义后不能进行修改的固定值。整数常量: 前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制 后缀指定修饰符:是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。 浮点常量：由整数部分、小数点、小数部分和指数部分组成。 小数形式：必须包含整数部分、小数部分，或同时包含两者。 指数形式：必须包含小数点、指数，或同时包含两者。带符号的指数是用 e 或 E 引入的。 布尔常量：true/false字符常量：括在单引号中的可以是一个普通的字符（例如 ‘x’）、一个转义序列（例如 ‘\\t’），或一个通用的字符（例如 ‘\\u02C0’）。 宽字符常量：以 L（仅当大写时）开头存储在 wchar_t 类型的变量中（例如 L’x’）。 窄字符常量：存储在 char 类型的简单变量中（例如 ‘x’）。 字符串常量：括在双引号 “” 中的。一个字符串包含类似于字符常量的字符：普通的字符、转义序列和通用的字符。C++有两种简单定义常量方式: 使用 #define 预处理器:#define identifier value 使用 const 关键字:const type variable = value; Tips:常量一般被定义成大写字母形式 C++ 修饰符类型修饰符 signed、unsigned、long 、short可应用于整型，signed 和 unsigned可应用于字符型，long 可应用于双精度型。修饰符 signed 和 unsigned 也可以作为 long 或 short 修饰符的前缀。例如：unsigned long int。 C++ 类型限定符用于限定类型和类型成员的声明 const：限定对象在程序执行期间不能被修改改变。 volatile：限定变量的值可能以程序未明确指定的方式被改变。(多线程使用) C++ 存储类存储类定义 C++ 程序中变量/函数的范围（可见性）和生命周期，常有auto、static、extern、mutable、thread_local (C++11)。auto关键字用于两种情况： 声明变量时根据初始化表达式自动推断该变量的类型。 声明函数时函数返回值的占位符。1234auto f=3.14;cout&lt;&lt;typeid(f).name()&lt;&lt;endl; //doubleauto z = new auto(9); cout&lt;&lt;typeid(z).name()&lt;&lt;endl; // int* static关键字指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。 static修饰局部变量：变量在全局数据区分配内存，程序执行第一次时首次初始化，以后函数调用不再进行初始化，没有显式初始化则会被自动初始化为0。 static修饰全局变量：使变量的作用域限制在声明它的文件内。 static修饰类的成员变量：类外初始化，先于类存在，类所有对象共同一个静态成员变量，可通过类名直接调用公共(public)静态成员变量。123456789101112131415class A&#123;public: A()&#123; count++; &#125; //先于类存在，在类的构造方法中已经可以调用 static int count;&#125;;int A::count = 0; //类外初始化int main()&#123; A c; A d; cout &lt;&lt; A::count &lt;&lt; endl; //共用性和直接类名调用 system(&quot;pause&quot;); return 0;&#125; static修饰类的成员方法:先于类存在，方法中不能使用非静态成员(无this指针),可通过类名直接调用公共(public)静态成员方法。12345678910111213141516171819class A&#123;public: A()&#123; count++; &#125; static int count; static void showCount() &#123; cout &lt;&lt; &quot;count is &quot; &lt;&lt; count &lt;&lt; endl; //不用this指针织带变量 &#125;&#125;;int A::count = 0; int main()&#123; A c; A d; A::showCount(); //类名直接调用 system(&quot;pause&quot;); return 0;&#125; C++ 运算符运算符是一种告诉编译器执行特定的数学或逻辑操作的符号,有算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符和其他运算符。算数运算符:+、-、、/、%(取模,整除后的余数)、++(自增)、–(自减).关系运算符:==、!=、&gt;、&lt;、&gt;=、&lt;=.逻辑运算符:&amp;&amp;(逻辑与，均非零为真)、||(逻辑或，存在非零则为真)、!(逻辑非，逆转逻辑状态).Tips:&amp;&amp;(||)具有短路功能，即若第一个条件为false(true)，则不再计算第二个表达式；&amp;(|)则无论如何均会计算两个表达式.利用这点可将A&amp;&amp;B中的A作为一个条件语句(if)不满足则不执行B，如下1234567891011121314151617/*不用任何循环语句，不用if，来实现1+2+3+...+10的值*/#include &lt;iostream&gt;using namespace std;int add(int c)&#123; int a=0; c&amp;&amp;(a=add(c-1));//递归循环，直到传入c的值为0则结束循环不执行右式 //(用&amp;则会执行造成溢出错误) cout&lt;&lt;c+a&lt;&lt;endl; return c+a;&#125;int main()&#123; add(10); return 0;&#125;位运算:若A = 60，且 B = 13，以二进制表示如下A = 0011 1100B = 0000 1101赋值运算:=、+=、-=、=、/=、%=、&lt;&lt;=、&gt;&gt;=、&amp;=(按位与或且赋值)、^=(按位异或且赋值)、|=(按位或且赋值)杂项运算: C++ 循环 while:1234while(condition)&#123; statement(s);&#125; for:1234for ( init; condition; increment )&#123; statement(s);&#125; do…while:12345do&#123; statement(s);&#125;while( condition ); 循环控制语句: break：跳出循环。 continue:跳过循环主体的剩余部分，立即重新开始测试条件。 C++ 判断 if:1234if(boolean_expression)&#123; statement(true); // 如果布尔表达式为真将执行的语句&#125; if…else:12345678if(boolean_expression)&#123; statement(true); // 如果布尔表达式为真将执行的语句&#125;else&#123; statement(false); // 如果布尔表达式为假将执行的语句&#125; switch:123456789101112switch(expression)&#123; case constant-expression : statement(s); break; // 可选的 case constant-expression : statement(s); break; // 可选的 // 您可以有任意数量的 case 语句 default : // 可选的 statement(s);&#125; [ ? : ]运算符:1Exp1 ? Exp2 : Exp3; C++ 函数函数声明包含函数的名称、返回类型和参数C++中的函数声明形式：1return_type function_name( parameter list );函数定义提供了函数的实际主体。C++中的函数定义形式：1234return_type function_name( parameter list )&#123; body of the function&#125;函数参数:函数内使用的局部变量称作形式参数，有三种调用方式 传值调用(默认)：把参数的实际值复制给形式参数。在这种情况下，修改函数内的形式参数不会影响实际参数。 指针调用：把参数的地址复制给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。修改形式参数会影响实际参数。如函数声明:void swap(int *x, int *y)函数调用:swap(&amp;a,&amp;b) 引用调用：把参数的引用赋值给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。如函数声明:void swap(int &amp;x, int &amp;y)函数调用:swap(a,b) 参数默认值:定义函数时可以为参数列表中每一个参数指定默认值,如int sum(int a=10,int b=20)Lambda 函数与表达式:Lambda 表达式把函数看作对象。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。 C++ 数字数学运算:引用数学头文件 内有许多内置数学函数随机数:标准库（被包含于中）提供两个帮助生成伪随机数的函数 void srand(unsigned seed)：设置随机数种子，通常用time()初始化(使用time需要引入头文件)，如srand( (unsigned)time( NULL ) ); int rand(void)：从srand (seed)中指定的seed开始，返回一个[seed, RAND_MAX（0x7fff）)间的随机整数。 指定生成范围的随机数1234(low,up) (rand()%(up-low+1)) + low - 1[low,up) (rand()%(up-low)) + low(low,up] (rand()%(up-low))+ low + 1[low,up] (rand()%(up-low+1)) + low C++ 数组声明数组:type arrayName [ arraySize ];初始化数组:type arrayName [ arraySize ] = { data } ;访问数组元素:数组名称+索引，arrayName[index];数组详解: 多维数组:type arrayName[size1][size2]…[sizeN]; 数组指针:声明的数组名其实是指向数组第一个元素的指针，即*arrayName == &amp;arrayName[0]所以也可以使用指针形式访问数组*(arrayName + i ) == arrayName[i] 传递数组给函数:是以指针的形式传递的，因此有三种传递方式：(type *param)(type param[size])(type param[]) 函数返回数组:数组以指针的形式返回的，另外C++不支持在函数外返回局部变量的地址，因此返回的数组需要均是static变量 C++ 字符串 C风格字符串:实质是一个以’\\0’(null)结尾的char数组，例如123//以下msg1和msg2初始化规则相同char msg1[6] = &#123;&apos;H&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, &apos;o&apos;, &apos;\\0&apos;&#125;;char msg2[] = &quot;Hello&quot;; C++有大量函数操作以null结尾的字符串： C++引入的 string 类类型:C++标准库提供了string类型(需引入#include &lt; string >库)且支持上述函数操作1234string str1 = &quot;Hello&quot;;string str2 = str1; //复制string str3 = str1 + str2; //连接int length = str3.size(); //长度 C++ 指针 内存地址:每个C++变量都有一个内存地址，可用寻址（&amp;）运算符访问变量的内存地址 指针:是一个特殊的变量，其值为另一个变量的内存地址，声明形式为:type *var-name; 使用指针:过程一般为声明、存储、访问（对指针使用间址(*)运算符可访问指针存储地址的变量值）12345678string str = &quot;Hello&quot;;string *ip;ip = &amp;str;cout &lt;&lt; &quot;Address of str : &quot; &lt;&lt; &amp;str &lt;&lt; endl;cout &lt;&lt; &quot;Value of str : &quot; &lt;&lt; str &lt;&lt; endl;cout &lt;&lt; &quot;Stored Address of ip : &quot; &lt;&lt; ip &lt;&lt; endl; //指针存储的变量的地址cout &lt;&lt; &quot;Address of ip : &quot; &lt;&lt; &amp;ip &lt;&lt; endl; //指针本身的地址cout &lt;&lt; &quot;Value of ip : &quot; &lt;&lt; *ip &lt;&lt; endl; 执行结果如下: Null指针:指针初始化时指定NULL值被称作空指针可以避免越界使用指针1type *ptr = NULL; 指针的算数运算:指针是一个用数值表示的地址，可以执行四种算数运算（++，–，+，-）具体运算数值与指针的类型有关(如整形指针一次递增4个字节，字符指针一次递增1个字节等) 指针与数组的异同:（同）均可通过指针的算数运算和数组索引来访问数组（异）声明数组的数组名的指针是一个指向数组第一个元素地址的常量指针，不可改变指向的地址 指针数组:可声明一个数组来存放指针，其中每个数组元素都是一个指针，如type *ptr[size]; 多级指针:一个指针指向另一个指针的地址123type var;type *ptr1 = &amp;var;type *ptr2 = &amp;ptr1; //ptr2就是一个多级指针指向一级指针ptr1 指针参数:声明函数参数为指针类型即可，这种属于指针调用函数参数，将参数地址复制给函数的形式参数，在函数内修改形式参数会影响实际参数。 函数返回指针类型:声明函数返回类型为指针类型即可，但由于C++不支持在函数外返回局部变量的地址，因此可返回指针类型的变量需要声明为static变量。 C++ 引用引用变量是一个实际变量的别名。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。 引用于指针的区别:1.引用必须在创建时初始化，指针可以在任何时间初始化。2.引出初始化为一个对象后不能更改，指针可以在任何时候指向另一个对象。3.不存在空引用，引用必须连接到一个合法内存。 引用创建初始化使用:type&amp; name = variable; 引用参数:声明函数参数为引用类型即可，属于引用调用的函数参数。这比传一般参数安全。 函数返回引用类型:声明函数返回类型为引用类型，但是实际上函数返回一个引用时是返回一个指向返回值的隐式指针，这样函数可以放在赋值语句的左边。返回引用最大的好处是在内存中不产生被返回值的副本，节省内存，但是不能返回局部变量的引用。 C++ 日期和时间C++继承了C语言用于日期和时间操作的结构和函数,需要引入 &lt; ctime > 头文件 有四个与时间有关的类型，其中clock_t、time_t、size_t 将系统时间和日期表示为某种整数，tm结构类型将日期和时间以C结构形式保存。 C/C++中关于日期和时间的重要函数:1.time(): 返回从 1970-01-01 到 当前的日历时间的秒数123//函数原型:time_t time(time_t *t)time_t nowSeconds = time(NULL);cout &lt;&lt; nowSeconds &lt;&lt; endl; 2.ctime():返回一个格式为[Www Mmm dd hh:mm:ss yyyy]基于参数timer的时间的字符串1234//函数原型:char *ctime(const time_t *timer)#pragma warning(disable:4996) //接触安全警报限制time_t curtime = time(NULL);cout &lt;&lt; ctime(&amp;curtime) &lt;&lt; endl; 3.localtime(): struct tm *localtime(const time_t *timer)，将参数timer的值分解为tm结构，并用本地时区表示12345678910//函数原型:struct tm *localtime(const time_t *timer)#pragma warning(disable:4996) //接触安全警报限制time_t curtime = time(NULL);struct tm *info = localtime(&amp;curtime);cout &lt;&lt; &quot;tm_sec:&quot; &lt;&lt; info-&gt;tm_sec &lt;&lt; endl;cout &lt;&lt; &quot;tm_min:&quot; &lt;&lt; info-&gt;tm_min &lt;&lt; endl;cout &lt;&lt; &quot;tm_hour:&quot; &lt;&lt; info-&gt;tm_hour &lt;&lt; endl;cout &lt;&lt; &quot;tm_mday:&quot; &lt;&lt; info-&gt;tm_mday &lt;&lt; endl;cout &lt;&lt; &quot;tm_mon:&quot; &lt;&lt; info-&gt;tm_mon &lt;&lt; endl;cout &lt;&lt; &quot;tm_year:&quot; &lt;&lt; info-&gt;tm_year &lt;&lt; endl; 4.clock(): 返回程序执行起处理器时钟所使用的时间，为了获取CPU所使用秒数需要除以CLOCKS_PER_SEC常量12345678910111213//函数原型:clock_t clock(void)#pragma warning(disable:4996) //接触安全警报限制clock_t start_t, end_t;start_t = clock();cout &lt;&lt; &quot;程序启动：&quot; &lt;&lt; start_t &lt;&lt; endl;for(int i=0; i&lt; 10000000; i++)&#123;&#125;end_t = clock();cout &lt;&lt; &quot;程序结束：&quot; &lt;&lt; end_t &lt;&lt; endl;double total_t;total_t = (double)(end_t - start_t) / CLOCKS_PER_SEC;cout &lt;&lt; &quot;CPU占用时间:&quot; &lt;&lt; total_t &lt;&lt; endl; 5.asctime()：返回一个基于timeptr的时期和时间的字符串的指针12345//函数原型:char *asctime(const struct tm *timeptr)#pragma warning(disable:4996) //接触安全警报限制time_t curtime = time(NULL);struct tm *info = localtime(&amp;curtime);cout &lt;&lt; asctime(info) &lt;&lt; endl; 6.gmtime():使用timer来填充tm的结构，并协调世界时(UTC)也被称作格林尼治标准时间(GMT)表示12345//函数原型:struct tm *gmtime(const time_t *timer)#pragma warning(disable:4996) //接触安全警报限制time_t curtime = time(NULL);struct tm *info = gmtime(&amp;curtime);cout &lt;&lt; asctime(info) &lt;&lt; endl; 7.mktime():将tm结构的timer转换成一个依据本地时区的time_t值123456//函数原型:time_t mktime(struct tm *timeptr)#pragma warning(disable:4996) //接触安全警报限制time_t curtime = time(NULL);struct tm *info = localtime(&amp;curtime);time_t localtime = mktime(info); cout &lt;&lt; ctime(&amp;localtime) &lt;&lt; endl; 8.difftime(): 返回time1和time2之间的相差秒数1234567891011// double difftime(time_t time1, time_t time2)#pragma warning(disable:4996) //接触安全警报限制#include &lt;windows.h&gt; //sleep函数time_t start_t, end_t;time(&amp;start_t);cout &lt;&lt; &quot;程序启动：&quot; &lt;&lt; start_t &lt;&lt; endl;Sleep(5632);time(&amp;end_t);cout &lt;&lt; &quot;程序结束：&quot; &lt;&lt; end_t &lt;&lt; endl;double diff_t = difftime(end_t, start_t); //以秒为单位精度是double我也不太清楚为什么....cout &lt;&lt; &quot;程序占用时间:&quot; &lt;&lt; diff_t &lt;&lt; endl; 9.strftime(): size_t strftime(char *str, size_t maxsize, const char *format, const struct tm *timeptr)，根据format中定义的格式化规则，格式化数据结构timeptr表示的时间，并把它存储在str中12345time_t now = time(NULL);struct tm *info = localtime(&amp;now);char buffer[80];strftime(buffer, 80, &quot;%x - %I:%M%p&quot;, info);cout &lt;&lt; &quot;格式化时间：&quot; &lt;&lt; buffer &lt;&lt; endl; C++ 基本输入输出 C++的I/O 发生在流中，流是字节序列。输入操作：字节流是从设备（如键盘、磁盘驱动器、网络连接等）流向内存。输出操作：字节流是从内存流向设备（如显示屏、打印机、磁盘驱动器、网络连接等）。 I/O 库头文件：1.标准输出流(cout):是ostream类的实例，与运算符&lt;&lt;将对象连接到标准输出设备2.标准输入流(cin):是istream类的实例，与运算符&gt;&gt;将对象连接到标准输入设备3.标准错误流(cerr):是ostream类的实例，是非缓冲的，每个流插入cerr会立即输出4.标准日志流(clog):是ostream类的实例，是缓冲的，每个流插入clog会先存储到缓冲区直到其填满或者刷新时才会输出 C++ 结构用户自定义的数据类型，允许存储不同类型的数据项，格式如下1234567struct type_name &#123;member_type1 member_name1;member_type2 member_name2;member_type3 member_name3;..&#125; object_names; 访问结构成员:使用成员访问运算符(.)，如1object_names.member_name 访问指向结构的指针:可定以指向结构的指针，则使用指针访问运算符(-&gt;)，如12struct type_name *struct_ptr = &amp;object_names;struct_pointer-&gt;title","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://harviealwayshere.github.io/tags/C/"}]},{"title":"粤语歌单","slug":"musicYueYu","date":"2018-01-30T08:34:19.000Z","updated":"2018-01-31T09:45:01.985Z","comments":true,"path":"2018/01/30/musicYueYu/","link":"","permalink":"https://harviealwayshere.github.io/2018/01/30/musicYueYu/","excerpt":"","text":"今天推荐的歌单是粤语抒情相关的，怎么说呢，感觉粤语歌与普通话的歌听觉上有所不同，粤语歌的咬文嚼字可能并不需要那么清晰，但是情感却十分饱满浓郁。第一位着重推荐的是我喜欢的比较冷门的粤语歌手侧田，听他的歌总是能感受的到他的力量、他的硬朗，能身临其境地走入他的内心感受他歌唱时的情感，听他的歌总能汲取歌中的能量，让听众奋发向上。 第二位推荐的是杨千嬅，她总是吟唱悲伤无助的歌曲，高亮干净的嗓音让她的歌总是令人心生怜意，比较适合一个人、悲伤的时候听，也许她的歌可以让你明白，悲剧才是最感动的。 第三位推荐的是谢安琪，”男不听七友，女不听钟无艳”相比很多人都听过，都是伤感情歌，谢安琪更是把以好友身份苦恋无果、甘做备胎的状态演唱的淋漓尽致。由于版权原因，请移步钟无艳 试听。","categories":[{"name":"Music","slug":"Music","permalink":"https://harviealwayshere.github.io/categories/Music/"}],"tags":[{"name":"粤语","slug":"粤语","permalink":"https://harviealwayshere.github.io/tags/粤语/"},{"name":"music","slug":"music","permalink":"https://harviealwayshere.github.io/tags/music/"}]},{"title":"使用Hexo和Markdown写作","slug":"hexoWrite","date":"2018-01-27T10:03:33.000Z","updated":"2018-01-30T08:30:23.412Z","comments":true,"path":"2018/01/27/hexoWrite/","link":"","permalink":"https://harviealwayshere.github.io/2018/01/27/hexoWrite/","excerpt":"","text":"终于开始激动人心的写博客环节了，但是在hexo上写博客跟word上写博客可不太一样。 Hexo特性：hexo可以用命令行创建文章，hexo可以自定义写作布局layout，hexo的资源文件的引用 Markdown语法：hexo生成的文章都是.md格式，需要使用特殊的编辑器来进行写作，还有特殊的markdown写作语法 资源的引用：使用外链（图床）和本地引用方法 严格规范markdown语法看来写博客也是一件不省心的事情，就让我们按部就班一步步来看看各个环节的特性吧。 1.Hexo特性建议参考官方文档&emsp; &emsp;&emsp;&emsp;&emsp;1.1 修改layout布局：&emsp;&emsp;&emsp;&emsp;打开博客文件夹根目录下的[scaffolds]中的[post.md]文件，可以看到初始只有title/date/tags三种文件变量称作Front-matter,可以添加updated/categories等基本变量如下&emsp;&emsp;&emsp;&emsp;Tips:并列的tips需要使用- (-和空格)否则会编译出错 &emsp;&emsp;&emsp;&emsp;1.2 创建文章语法：1$ hexo new [layout] &lt;title&gt; &emsp;&emsp;&emsp;&emsp;1.3 Hexo自带语法：&emsp;&emsp;&emsp;&emsp;Hexo也有一些用于写作的不同于md的基本语法称作标签插件(Tag Plugins)比如引用块真是不知命运所馈赠的礼物，早已在暗中标明了价格。 茨威格断头王后比如代码块1alert(&apos;Hello World!&apos;); 2.Markdown语法&emsp;&emsp;&emsp;&emsp;Markdown语法很多很细致但是很简单，网上有很多文章介绍，这里我就推荐一个写的很好的博主文章供大家学习，相信很多人都是看这篇文章入门的，我就不露丑介绍了。 3.资源引用&emsp;&emsp;&emsp;&emsp;相信很多人在写博文为了增强用户体验都会插入一些图片表达，md中都是依靠链接来插入图片的，唯一不同的是这个链接是本地链接还是外部链接呢，本地链接无风险但是插入的图片会占据github空间而且不灵活不好分享毕竟我们写的博文都是需要部署到github上的，外部链接节省github空间但是万一失效了图片就显示不出来了俗称图片挂了，我个人原则是 小图片用本地链接大图片可以尝试外部链接，重要图片用本地链接稍微不那么关键的图片用外部链接。 &emsp;&emsp;&emsp;&emsp;3.1 本地链接的使用：&emsp;&emsp;&emsp;&emsp;本地链接的使用其实很简单，但是由于图片在本地路径和在生成($ hexo g)文件的路径并不相同，所以我的做法是首先将图片放在跟博文文件一个目录下，在本地预览完成需要部署的时候，再将图片剪切到[博客根目录/source/images/]文件夹里面同时要修改博文中对于图片的引用变成(/images/picture.png)因为编译后图片放在网站根目录的images中。 &emsp;&emsp;&emsp;&emsp;3.2 外部链接的使用：&emsp;&emsp;&emsp;&emsp;外部链接的使用其实就是利用一些网站服务器的空间来存储你的图片俗称图床，在博文中直接使用直接路径调用图片，如类似这种链接https://i.loli.net/2018/01/25/5a69a60eeda77.gif&emsp;&emsp;&emsp;&emsp;图床有许多，有免费的也有收费的，有些有浏览流量的限制，收费的我推荐七牛云,免费的我推荐SM.MS,用到现在还没有出现挂图的迹象。&emsp;&emsp;&emsp;&emsp;Tips：其实图床蛮多托的，有人建议直接放在github仓库上用绝对连接访问就好。 在repository的根目录下建立文件夹，然后将图片放在其中，在写链接的时候直接使用自己的GitHub Pages根路径加图片地址访问即可。 4.严格规范markdown语法&emsp;&emsp;&emsp;&emsp;Markdown语法看似简单，其实有许多坑需要踩。比如最简单的用[###]表示字体大小，也许在markdown编辑器上可以直接使用[###你好]表示，但是生成页面的时候却显示不出来，这是因为[#]的严格语法是[#+空格+内容]，缺少一个空格将会造成无法编译。还有一些小技巧，比如想打出空格,换行，底色等，最好还是用字符或者Html语法的形式，如下1234567&amp;emsp; //空格&lt;br&gt; //换行&lt;font face=&quot;微软雅黑&quot;&gt;&lt;/font&gt; //字号&lt;font color=red&gt;&lt;/font&gt; //字体颜色&lt;font color=#0099ff size=7&gt;&lt;/font&gt; //字体[1-7]&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=orange&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; //背景色--- //分割线 相信你已经初步了解怎么使用hexo和markdown语法写作了，你肯定迫不及待地想写下自己第一篇博文打了吧，去吧！","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://harviealwayshere.github.io/tags/Hexo/"},{"name":"GithubPages","slug":"GithubPages","permalink":"https://harviealwayshere.github.io/tags/GithubPages/"}]},{"title":"大三上寒假计划","slug":"planOfHoliday","date":"2018-01-27T09:13:41.000Z","updated":"2018-01-30T08:30:21.686Z","comments":true,"path":"2018/01/27/planOfHoliday/","link":"","permalink":"https://harviealwayshere.github.io/2018/01/27/planOfHoliday/","excerpt":"","text":"我的寒假学习计划同时也是博客的更新计划，大致有以下几个方面： 算法：LeetCode、牛客网、剑指Offer的题目解法总结 专业相关：机器学习的实践相关内容总结 实战：Laravel框架的学习和一个网页功能开发实战的更新总结 python：python相关的库使用，如爬虫、机器学习、可视化、游戏等 影评：休闲之时也会写一些影评推荐一些精品电影给大家（资源也会放出来） 每部分的更新频率不一定，但是会尽量面面俱到、频繁更新的，敬请期待哦！","categories":[{"name":"Life","slug":"Life","permalink":"https://harviealwayshere.github.io/categories/Life/"}],"tags":[{"name":"Plan","slug":"Plan","permalink":"https://harviealwayshere.github.io/tags/Plan/"}]},{"title":"使用github pages和hexo搭建个人博客","slug":"gitPagesAndHexo","date":"2018-01-14T12:51:14.000Z","updated":"2018-01-30T08:30:24.530Z","comments":true,"path":"2018/01/14/gitPagesAndHexo/","link":"","permalink":"https://harviealwayshere.github.io/2018/01/14/gitPagesAndHexo/","excerpt":"","text":"大致步骤可以分为6步 下载安装Node.js（可以使用npm下载和管理包） 申请github账户（用于注册github pages仓库） 下载git（最好是bash 便于使用命令行操作系统） 安装hexo并配置基本参数 安装hexo主题并配置基本参数 博客部署到github pages上线 1. 下载安装Node.js（可以使用npm下载和管理包）1.1访问Node.js中文官网下载安装包:根据你的操作系统和系统类型（位数）选择下载哪一个安装包Tips：32位安装包兼容64位操作系统，64位安装包不兼容32位操作系统&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;建议使用.msi格式一键安装&nbsp;&nbsp;1.2安装Node.js:&emsp;&emsp;&emsp;&emsp;.zip文件：运行node.exe文件会跳出命令行安装&emsp;&emsp;&emsp;&emsp;.msi文件:根据提示步骤安装（安装路径最好是全英文）1.3测试是否安装成功:&emsp;&emsp;&emsp;&emsp;1.3.1 打开命令提示符:&emsp;&emsp;&emsp;&emsp;windows系统下用+R）打开运行窗口输入cmd打开命令提示符&emsp;&emsp;&emsp;&emsp;1.3.2： 输入命令 node -v 和npm -v 查看node.js和npm是否安装成功：&emsp;&emsp;&emsp;&emsp; &emsp;&emsp;&emsp;&emsp; 若有版本号（不一定与我的相同）则安装成功 否则安装失败则重新安装即可 2. 申请github账户（用于注册github pages仓库）&emsp;&emsp;&emsp;&emsp;2.1 访问github官网注册账号&emsp;&emsp;&emsp;&emsp;2.3 申请一个仓库:&emsp;&emsp;&emsp;&emsp;登录你的github账号点击上方的New repository 如下图所示&emsp;&emsp;&emsp;&emsp;在Repository name上填写 [你注册的github名称.github.io] 即可&emsp;&emsp;&emsp;&emsp;如我注册的github名称是xxx则我的Repository name为 [xxx.github.io]&emsp;&emsp;&emsp;&emsp;其他的都不用填写 之后点击[Create repository]即可 3. 下载安装git（最好是bash 便于使用命令行操作系统） Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 此部分内容建议参考廖雪峰老师的git安装文档&emsp;&emsp;&emsp;&emsp;3.1 通俗来说git就是一个软件类似于cmd命令行，但是它可以使用git命令和linux命令来操控系统，这是cmd所做不到的。在此项目中，我们主要使用它来编写npm命令、hexo命令、git命令来生成和部署自己的博客到github pages上&emsp;&emsp;&emsp;&emsp;访问git下载页面下载对应系统的git &emsp;&emsp;&emsp;&emsp;安装完毕之后打开gitbash即可使用&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;首次使用git的用户还需配置自己的用户名和地址用于验证身份：12$ git config --global user.name &quot;Your Name&quot; $ git config --global user.email &quot;email@example.com&quot; &emsp;&emsp;&emsp;&emsp;3.2 将计算机的ssh key设置到你的github账号上，你才能将本地的文件上传到你的github上面&emsp;&emsp;&emsp;&emsp;具体操作可参考廖雪峰老师的ssh key设置教程 4. 全局安装hexo建立自己的博客并配置基本参数此部分内容建议参考hexo官方文档&emsp;&emsp;&emsp;&emsp; 4.1 全局安装hexo：&emsp;&emsp;&emsp;&emsp;访问hexo官方网站查看安装命令，运行Git Bash输入安装命令npm install hexo-cli -g&emsp;&emsp;&emsp;&emsp; 4.2 建立自己的博客：在Git Bash中输入123$ hexo init [你的博客文件夹名称] $ cd [你的博客文件夹名称] $ npm install&emsp;&emsp;&emsp;&emsp;我这里演示的文件夹名称是[testBlog]&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Tips:输入pwd可查看当前文件夹的路径&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&nbsp;输入explorer .可打开命令行当前文件夹&emsp;&emsp;&emsp;&emsp;如果看到以下内容，那么恭喜你hexo建站成功了&emsp;&emsp;&emsp;&emsp; &emsp;&emsp;&emsp;&emsp; 4.3 配置基本参数博客本地预览&emsp;&emsp;&emsp;&emsp;您可以在 _config.yml 文件中修改大部份的配置具体参数意义可参考官方文档&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;输入以下命令可在本地预览你生成的博客网址123$ npm install hexo-server --save $ hexo generate$ hexo server &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;你可以像我一样用[$ hexo g]和[$ hexo s]来简化命令&emsp;&emsp;&emsp;&emsp;[$ npm install hexo-server –save]用来安装hexo本地预览的服务器 只用第一次执行一次就可以了&emsp;&emsp;&emsp;&emsp;以后每次改动就只用[$ hexo g]生成文件和[$ hexo s]启动服务器就可以了&emsp;&emsp;&emsp;&emsp;之后在浏览器输入[http://localhost:4000]就可以查看你的博客页面了&emsp;&emsp;&emsp;&emsp; 5. 安装hexo主题并配置基本参数&emsp;&emsp;&emsp;&emsp;到目前为止，是不是觉得hexo默认的主题不符合你的心意，没关系，hexo爱好者们提供了上千个主题供你挑选使用，安装主题的方法也十分简单，让我们一起来让博客的面目焕然一新吧&emsp;&emsp;&emsp;&emsp;5.1 挑选你喜爱的主题下载&emsp;&emsp;&emsp;&emsp;可以参考官方主题推荐文档或者github大神整理来寻找自己喜欢的主题并按照对应主题的文档说明下载使用&emsp;&emsp;&emsp;&emsp;如我的博客采用的主题是Huemen下载就十分简单，按照官方文档按部就班即可&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;5.2 配置主题的基本参数：&emsp;&emsp;&emsp;&emsp;主题的配置是类似于hexo配置，修改主题文件下中的[_config.yml]文件即可具体每个参数的意义请参考主题的说明文档&emsp;&emsp;&emsp;&emsp;5.3 配置成功之后可运行命令预览自己的博客了（在博客根目录下运行命令）123$ hexo clean $ hexo g $ hexo s 6. 博客部署到github pages上线&emsp;&emsp;&emsp;&emsp;6.1 安装git pages部署器：在博客根目录下打开git bash运行[$ npm install hexo-deployer-git –save]命令&emsp;&emsp;&emsp;&emsp;6.2 修改博客根目录下的配置文件[_config.yml]中的deploy参数：123deploy: type: git repo: [你注册的github pages的仓库地址] &emsp;&emsp;&emsp;&emsp;6.3 部署至github上：12$hexo generate $hexo deploy &emsp;&emsp;&emsp;&emsp;或者1$hexo d -g&emsp;&emsp;&emsp;&emsp;成功之后你可以在线访问你的github pages地址[你的github仓库名.github.io]来查看你的博客了 恭喜你，你的博客已经搭建成功并上线了! 之后我会再写一篇文章介绍hexo写作的基本方法、使用markdown格式写作、图床的使用技巧等博文写作知识，敬请期待。","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://harviealwayshere.github.io/tags/Hexo/"},{"name":"GithubPages","slug":"GithubPages","permalink":"https://harviealwayshere.github.io/tags/GithubPages/"}]}]}