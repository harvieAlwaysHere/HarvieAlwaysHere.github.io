{"meta":{"title":"Harvie Blog","subtitle":"Fright For Better Day","description":"IT Blog","author":"Harvie Yao","url":"https://harviealwayshere.github.io"},"pages":[{"title":"about","date":"2018-01-30T09:37:04.000Z","updated":"2018-01-30T09:37:04.587Z","comments":true,"path":"about/index.html","permalink":"https://harviealwayshere.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"Swoole(十六)实现一个长连接的网络聊天室","slug":"swoole16","date":"2018-02-21T11:09:56.000Z","updated":"2018-02-22T10:19:50.016Z","comments":true,"path":"2018/02/21/swoole16/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/21/swoole16/","excerpt":"","text":"这次我们首先一个类似IM的网络聊天室，服务器端使用websocket，客户端使用JS连接。 1.Websocket服务器首先将服务器端代码写好1234567891011121314151617181920212223242526272829303132333435363738&lt;?php//创建Websocket服务器$ws = new swoole_websocket_server(&quot;0.0.0.0&quot;, 9501);//on监听事件函数 open/message/close$ws-&gt;on(&apos;open&apos;, function ($ws, $request) &#123; echo &quot;user&quot;.$request-&gt;fd.&quot;in\\n&quot;; //将新用户存在全局变量里 $GLOBALS[&apos;fd&apos;][$request-&gt;fd][&apos;id&apos;] = $request-&gt;fd; $GLOBALS[&apos;fd&apos;][$request-&gt;fd][&apos;name&apos;] = &quot;noName&quot;;&#125;);$ws-&gt;on(&apos;message&apos;, function ($ws, $request) &#123; //若接受的数据中含#name# 则为设置用户名 if(strstr($request-&gt;data, &quot;#name#&quot;))&#123; //将接受到的数据中的#name#替换成空白后存入相应的全局变量中 $GLOBALS[&apos;fd&apos;][$request-&gt;fd][&apos;name&apos;] = str_replace(&quot;#name#&quot;, &apos;&apos;, $request-&gt;data); &#125;else&#123;//若接受的数据中不含#name#, 则为用户发送消息 //编辑消息格式 $msg = $GLOBALS[&apos;fd&apos;][$request-&gt;fd][&apos;name&apos;].&quot;:&quot;.$request-&gt;data.&quot;\\n&quot;; //向所连接的每个客户端发送消息 foreach ($GLOBALS[&apos;fd&apos;] as $client) &#123; //使用push推送消息 $ws-&gt;push($client[&apos;id&apos;],$msg); &#125; &#125;&#125;);$ws-&gt;on(&apos;close&apos;, function ($ws, $request) &#123; echo &quot;user&quot;.$request-&gt;fd.&quot;out\\n&quot;; //删除用户信息 unset( $GLOBALS[&apos;fd&apos;][$request-&gt;fd]);&#125;);//启动服务器$ws-&gt;start(); 2.配置LAMP环境LP我们已经具备了，现在配置AM环境2.1 安装Apache查询是否有Apache安装包：yum list httpd若有直接安装（如我的有x86_64版本的）:yum install httpd.x86_64若没有则使用yum安装Apache：yum -y install httpd设置开机启动：chkconfig –levels 235 httpd on启动Apache：service httpd start(重启Apache：service httpd restart)查询Apache是否启动：ps -ef|grep httpd [Apache默认网站目录/var/www/html]测试是否访问正常：cd /var/www/html/vim index.php&lt;?php phpinfo();?&gt;此时可访问localhost或者使用外网IP访问，出现phpinfo信息则正常 2.2 安装Mysql由于CentOS7默认是安装Maridb，但是不用担心，因为Maridb是mysql的一个分支且支持任何mysql语句，所以我们安装maridb，命令和操作都照常使用mysql的就可以拉，具体maridb和mysql的渊源可以看看知乎这里安装Maridb：yum install -y mariadb-server启动Maridb： service mariadb start（停止和重启服务是 service+服务名+stop/restart）查询是否启动：ps -ef|grep mariadb （此时可查询mysql服务，也可以查询出结果）设置开启启动：chkconfig –levels 235 mariadb on设置root账户密码：mysql_secure_installationTips:一开始提示输入原密码直接回车就好，因为原密码为空，然后输入新密码，之后一直y即可登录mariadb：mysql -u root -p (输入刚才设定的密码即可) 2.3 安装phpmyadmin远程管理数据库安装phpmyadmin：yum install phomyadmin由于默认情况下CentOS7上的phpmyadmin只允许从本地访问，因此我们需要修改phpmyadmin的配置phpMyAdmin默认配置目录为/etc/httpd/conf.d/phpMyAdmin.conf然后将限制ip访问的改成允许(共有4条语句要注释，增加两条Require all granted语句)，如下详情可点击这里查看之后输入IP地址/phpmyadmin即可远程登录数据库管理在开发环境想不用频繁登录phpmyadmin可以在/etc/phpMyAdmin/config.inc.php中修改登录模式，有自动登录模式，详情可查看这里 3.客户端实现客户端代码就十分简易，功能大概就是检验是否连接、设置昵称和发送消息12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;IM聊天室&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;msg&quot;&gt;&lt;/div&gt; &lt;input type=&quot;text&quot; id=&quot;text&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;发送数据&quot; onclick=&quot;send()&quot;&gt;&lt;/body&gt;&lt;script&gt; var msg = document.getElementById(&quot;msg&quot;); var connectIp = &apos;ws://39.108.210.229:9501&apos;; //调用websocket对象建立连接： //参数：ws/wss(加密)：//ip:port （字符串） var websocket = new WebSocket(connectIp); //onopen监听连接打开 websocket.onopen = function (evt) &#123; //websocket.readyState 属性： /* CONNECTING 0 The connection is not yet open. OPEN 1 The connection is open and ready to communicate. CLOSING 2 The connection is in the process of closing. CLOSED 3 The connection is closed or couldn&apos;t be opened. */ if(websocket.readyState == 1) &#123; msg.innerHTML=&quot;连接成功!&lt;br&gt;可使用&apos;#name#+您的昵称&apos;设置昵称&lt;br&gt;&quot;; &#125; //msg.innerHTML = websocket.readyState; &#125;; function send()&#123; var text = document.getElementById(&apos;text&apos;).value; document.getElementById(&apos;text&apos;).value = &apos;&apos;; //向服务器发送数据 websocket.send(text); &#125; //监听连接关闭// websocket.onclose = function (evt) &#123;// console.log(&quot;Disconnected&quot;);// &#125;; //onmessage 监听服务器数据推送 websocket.onmessage = function (evt) &#123; msg.innerHTML += evt.data +&apos;&lt;br&gt;&apos;;// console.log(&apos;Retrieved data from server: &apos; + evt.data); &#125;;//监听连接错误信息// websocket.onerror = function (evt, e) &#123;// console.log(&apos;Error occured: &apos; + evt.data);// &#125;;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;上传到服务器端的网页目录[/var/www/html]，之后运行服务器端代码，之后随意用任意浏览器访问客户端页面[ip/xxx.html]即可，具体效果如下，运行服务器脚本后当浏览器两个请求访问时可以看到两个用户加入了，然后我们可以设置昵称开始发送消息，每个客户端发送的消息到服务器端都会被服务器端推送至每个客户端","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"php项目","slug":"php项目","permalink":"https://harviealwayshere.github.io/tags/php项目/"},{"name":"swoole","slug":"swoole","permalink":"https://harviealwayshere.github.io/tags/swoole/"}]},{"title":"Swoole(十五)异步文件写入","slug":"swoole15","date":"2018-02-20T10:17:56.000Z","updated":"2018-02-21T09:01:56.087Z","comments":true,"path":"2018/02/20/swoole15/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/20/swoole15/","excerpt":"","text":"Swoole增加了异步文件读写，异步DNS，异步Http/WebSocket客户端等特性。开发纯异步非阻塞IO的程序时，不能使用PHP自带的网络客户端，如curl、file_get_contents、stream、sockets、mysql、redis。 1.(小文件)异步写文件：swoole_async_writefile提供了两种风格函数风格：swoole_async_writefile($filename, $fileContent, function($filename){}, $flags = 0);面向对象风格：Swoole\\Async::writeFile(string $filename, string $fileContent, callable $callback = null, int $flags = 0)$filename：文件名称，须有可写权限，文件不存在会自动创建，打开文件失败会返回false$fileContent：写入文件的内容，最大可写入4M$callback：写入成功的回调函数，可选flags：写入选项，可以使用FILE_APPEND表示追加到文件末尾Tips：Linux原生异步IO不支持FILE_APPEND，并且写入的内容长度必须为4096的整数倍，否则底层会自动在末尾填充0 2.(大文件)异步写文件：swoole_async_write函数原型：bool swoole_async_write(string $filename, string $content, int $offset = -1, mixed $callback = NULL);$filename：文件名称$content：写入文件的内容，因为是分段写入，所以无限制$offset：写入方式，-1为追加写入到文件末尾$callback：写入成功的回调函数，可选swoole_async_write是分段写的。不需要一次性将要写的内容放到内存里，所以只占用少量内存。swoole_async_write通过传入的offset参数来确定写入的位置。 3.两种写入方式测试将脚本上传到服务器运行可以看到我们用vim打开写入的文件看看内容可以看到由于是异步写入，write比writeFile2的写入还要早执行，但是三个写入函数都执行成功了，一个是直接写入，一个是追加写入，还有一个是大文件的写入","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"php项目","slug":"php项目","permalink":"https://harviealwayshere.github.io/tags/php项目/"},{"name":"swoole","slug":"swoole","permalink":"https://harviealwayshere.github.io/tags/swoole/"}]},{"title":"Swoole(十四)异步文件读取","slug":"swoole14","date":"2018-02-20T10:17:51.000Z","updated":"2018-02-21T08:27:33.779Z","comments":true,"path":"2018/02/20/swoole14/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/20/swoole14/","excerpt":"","text":"Swoole增加了异步文件读写，异步DNS，异步Http/WebSocket客户端等特性。开发纯异步非阻塞IO的程序时，不能使用PHP自带的网络客户端，如curl、file_get_contents、stream、sockets、mysql、redis。 1.(小文件)异步读取文件内容：swoole_async_readfile提供了两种风格函数风格：swoole_async_readfile(string $filename, mixed $callback);面向对象风格：Swoole\\Async::readFile(string $filename, mixed $callback);$filename：路径下的文件名$callback：由于是异步非阻塞，数据读取完毕后会立即调用指定的回调函数Tips：swoole_async_readfile会将文件内容全部复制到内存，所以不能用于大文件的读取如果要读取超大文件，请使用swoole_async_read函数 2.(大文件)异步读取文件内容：swoole_async_read函数原型：bool swoole_async_read(string $filename, mixed $callback, int $size = 8192, int $offset = 0);$filename：路径下的文件名$callback：回调函数接受两个参数bool callback(string $filename, string $content);，$filename-文件名称，$content-读取到的分段内容，如果内容为空，表明文件已读完，在回调函数中可通过return true/false，来控制继续读下一段内容/停止读取并关闭文件。$size：读取的分段内容的大小，单位字节Tips：此函数与swoole_async_readfile不同，它是分段读取，可以用于读取超大文件。每次只读$size个字节，不会占用太多内存。 3.两种读取方式测试123456789101112131415161718192021&lt;?phpecho &quot;swoole_async_readfile \\n&quot;;//readFile读取swoole_async_readfile(__DIR__.&quot;/testFile.txt&quot;, function($filename, $content) &#123; echo &quot;swoole_async_readfile-[$filename] : $content \\n&quot;;&#125;);echo &quot;swoole_async_read \\n&quot;;//read读取swoole_async_read(__DIR__.&quot;/testFile.txt&quot;, function($filename, $content) &#123; if($content)&#123; echo &quot;swoole_async_read-[$filename] : $content \\n&quot;; return true; &#125;else&#123; return false; &#125; &#125;); 上传脚本和测试文本到服务器可以看到由于是异步读取，两个echo都在文件读取之前输出出来了，之后就是两个文件读取内容的打印","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"php项目","slug":"php项目","permalink":"https://harviealwayshere.github.io/tags/php项目/"},{"name":"swoole","slug":"swoole","permalink":"https://harviealwayshere.github.io/tags/swoole/"}]},{"title":"Swoole(十三)DNS查询","slug":"swoole13","date":"2018-02-20T10:17:48.000Z","updated":"2018-02-21T07:16:18.752Z","comments":true,"path":"2018/02/20/swoole13/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/20/swoole13/","excerpt":"","text":"Swoole有(异步)DNS查询功能(我也不知道为什么集成了) 1.（异步）将域名解析为IP地址：swoole_async_dns_lookup函数原型：swoole_async_dns_lookup($domainName,callback function($host,$ip){});$domainName：传入的域名DNS查询完成：自动回调指定的callback函数。DNS查询失败：比如域名不存在，回调函数传入的$ip为空调用此函数是非阻塞的，调用会立即返回。将向下执行后面的代码。 2.执行DNS查询123swoole_async_dns_lookup(&quot;www.baidu.com&quot;, function($host, $ip)&#123; echo &quot;&#123;$host&#125; : &#123;$ip&#125;\\n&quot;;&#125;); 脚本在服务器运行，可以看到执行成功","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"php项目","slug":"php项目","permalink":"https://harviealwayshere.github.io/tags/php项目/"},{"name":"swoole","slug":"swoole","permalink":"https://harviealwayshere.github.io/tags/swoole/"}]},{"title":"Swoole(十二)锁机制","slug":"swoole12","date":"2018-02-20T10:17:41.000Z","updated":"2018-02-20T17:41:02.115Z","comments":true,"path":"2018/02/20/swoole12/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/20/swoole12/","excerpt":"","text":"Swoole针对内存的其他提供了一系列的锁机制swoole_lock类支持5种锁的类型： 文件锁 SWOOLE_FILELOCK 读写锁 SWOOLE_RWLOCK 信号量 SWOOLE_SEM 互斥锁 SWOOLE_MUTEX 自旋锁 SWOOLE_SPINLOCKTips：之前学习单例模式算法的时候，为了防止两个进程创建两个单例，就需要使用锁机制，C++/C#有private static object syncObj = new object();，JAVA中有synchronized(Singleton2.class){}，没想到PHP也有Swoole扩展的锁机制。 1.创建锁对象：$lock = new swoole_lock();函数原型：swoole_lock-&gt;__construct(int $type, [string $lockfile]);$type：锁的类型，具体为以上五种锁$lockfile：当类型为SWOOLE_FILELOCK(文件锁)时必须传入，指定文件锁的路径注意每一种类型的锁支持的方法都不一样，如读写锁、文件锁可以支持$lock-&gt;lock_read()。另外除文件锁外，其他类型的锁必须在父进程内创建，这样fork出的子进程之间才可以互相争抢锁。 2.加锁：swoole_lock-&gt;lock函数原型：bool $lock-&gt;lock();如果有其他进程持有锁，那这里将进入阻塞，直到持有锁的进程unlock。 3.释放锁：swoole_lock-&gt;unlock函数原型：bool $lock-&gt;unlock();解锁成功返回true。 4.创建一个互斥锁并通过主进程和子进程演示123456789101112131415161718192021222324&lt;?php//创建锁对象（互斥锁）$lock = new swoole_lock(SWOOLE_MUTEX);echo &quot;[Master]create mutex lock\\n&quot;;//主进程 加锁$lock-&gt;lock();//创建子进程if(pcntl_fork() &gt; 0)&#123; //创建成功则主进程解锁 sleep(1); $lock-&gt;unlock();&#125;else&#123; //创建失败则子进程等待主进程解锁后子进程再加锁进行自身的操作 echo &quot;[Child] Wait Lock\\n&quot;; $lock-&gt;lock(); echo &quot;[Child] Get Lock\\n&quot;; $lock-&gt;unlock(); exit(&quot;[Child] exit\\n&quot;);&#125;echo &quot;[Master]release lock\\n&quot;;unset($lock);sleep(1);echo &quot;[Master]exit\\n&quot;; 运行脚本在服务器上，可以看到首先主进程创建互斥锁并上锁(create mutex lock)此时子进程创建失败只能等待(wait lock)等到主进程释放锁(release lock)主进程释放锁后，子进程首先加锁(get lock)之后子进程做自己的事情，完成后解锁退出(exit)此时主进程再退出(exit)","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"php项目","slug":"php项目","permalink":"https://harviealwayshere.github.io/tags/php项目/"},{"name":"swoole","slug":"swoole","permalink":"https://harviealwayshere.github.io/tags/swoole/"}]},{"title":"Swoole(十一)进程信号触发器","slug":"swoole11","date":"2018-02-20T09:29:28.000Z","updated":"2018-02-21T11:21:50.053Z","comments":true,"path":"2018/02/20/swoole11/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/20/swoole11/","excerpt":"","text":"Swoole具备进程管理模块，用来代替PHP的pcntl拓展。1.设置异步信号监听：swoole_process::signal函数原型：bool swoole_process::signal(int $signo, callable $callback);此方法基于signalfd和eventloop是异步IO，不能用于同步程序中同步阻塞的程序可以使用pcntl扩展提供的pcntl_signal$callback如果为null，表示移除信号监听 如果已设置了此信号的回调函数，重新设置时会覆盖历史设置2.高精度定时器：swoole_process::alarm高精度定时器，是操作系统setitimer系统调用的封装，可以设置微秒级别的定时器。定时器会触发信号，需要与swoole_process::signal（异步）或pcntl_signal（同步）配合使用。函数原型：function swoole_process::alarm(int $interval_usec, int $type = ITIMER_REAL) : bool$interval_usec：定时器间隔时间，单位为微秒。如果为负数表示清除定时器$type：定时器类型 0 表示为真实时间,触发SIGALAM信号 1 表示用户态CPU时间，触发SIGVTALAM信号 2 表示用户态+内核态时间，触发SIGPROF信号 3.创建定时器及信号监听函数12345678910111213141516&lt;?php//触发函数 异步执行 达到条件停止swoole_process::signal(SIGALRM,function()&#123; //计时器 用于停止定时器触发信号 static $i=0; echo &quot;hello!\\n&quot;; $i++; if($i&gt;10)&#123; //触发十次 清除定时器 swoole_process::alarm(-1); &#125;&#125;);//定时信号swoole_process::alarm(100*1000); 将脚本上传至服务器并运行，可以看到成功发送了10次信号并触发后清除定时器停止程序","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"php项目","slug":"php项目","permalink":"https://harviealwayshere.github.io/tags/php项目/"},{"name":"swoole","slug":"swoole","permalink":"https://harviealwayshere.github.io/tags/swoole/"}]},{"title":"Swoole(十)进程队列通信","slug":"swoole10","date":"2018-02-20T09:25:28.000Z","updated":"2018-02-20T10:16:51.686Z","comments":true,"path":"2018/02/20/swoole10/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/20/swoole10/","excerpt":"","text":"Swoole具备进程管理模块，用来代替PHP的pcntl拓展。 1.投递数据到消息队列：swoole_process-&gt;push函数原型：bool swoole_process-&gt;push(string $data);$data：投递的数据，长度受限与操作系统内核参数的限制。默认为8192，最大不超过65536默认模式下（阻塞模式）：队列已满，push方法会阻塞等待非阻塞模式下：队列已满，push方法会立即返回false 2.从队列中提取数据：swoole_process-&gt;pop函数原型：string swoole_process-&gt;pop(int $maxsize = 8192);$maxsize：表示获取数据的最大尺寸，默认为8192操作成功会返回提取到的数据内容，失败返回false默认模式下：队列中没有数据，pop方法会阻塞等待非阻塞模式下：队列中没有数据，pop方法会立即返回false，并设置错误码为ENOMSG 3.回收结束运行的子进程：swoole_process::wait子进程结束必须要执行wait进行回收，否则子进程会变成僵尸进程函数原型：array(‘code’ =&gt; 0, ‘pid’ =&gt; 15001, ‘signal’ =&gt; 15) swoole_process::wait(bool $blocking = true);$blocking：可以指定是否阻塞等待，默认为阻塞操作成功会返回一个数组包含子进程的PID、退出状态码、被哪种信号KILL如果在异步信号回调中执行wait123456swoole_process::signal(SIGCHLD, function($sig) &#123; //必须循环执行wait直到返回false while($ret = swoole_process::wait(false)) &#123; echo &quot;PID=&#123;$ret[&apos;pid&apos;]&#125;\\n&quot;; &#125;&#125;); 4.启用消息队列作为进程间通信：swoole_process-&gt;useQueue函数原型：bool swoole_process-&gt;useQueue(int $msgkey = 0, int $mode = 2);$msgkey：消息队列的key，默认会使用ftok(FILE, 1)作为KEY$mode：通信模式，默认为2，表示争抢模式，所有创建的子进程都会从队列中取数据 5.退出子进程：swoole_process-&gt;exit函数原型：int swoole_process-&gt;exit(int $status=0);$status是退出进程的状态码，如果为0表示正常结束，会继续执行PHP的shutdown_function，其他扩展的清理工作。$status不为0，表示异常退出，会立即终止进程。不再执行PHP的shutdown_function，其他扩展的清理工作。在父进程中，执行swoole_process::wait可以得到子进程退出的事件和状态码。 6.创建进程队列并通信123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?php//进程池 存储进程$workers = []; //进程数量$worker_num = 2;//创建并启动进程for($i=0;$i&lt;$worker_num;$i++)&#123; //创建新进程，注意第三个参数为false，不启动pipe通信 $process = new swoole_process(&apos;doProcess&apos;,false,false); //启用消息队列作为进程间通信 $process-&gt;useQueue(); $pid = $process-&gt;start(); //启动进程并获取进程ID $workers[$pid] = $process; //将进程存入进程池&#125;//编写进程执行函数function doProcess(swoole_process $worker)&#123; //从主进程(master)中获取数据 $recv = $worker-&gt;pop(); echo &quot;Worker(&quot;.$worker-&gt;pid.&quot;)From Master: &quot;.$recv.&quot;\\n&quot;; sleep(2); //退出子进程 0表示正常结束 $worker-&gt;exit(0);&#125;//主进程向子进程添加数据foreach ($workers as $process) &#123; $process-&gt;push(&quot;hello worker[&quot;.$process-&gt;pid.&quot;]\\n&quot;);&#125;//等待子进程结束回收资源for($i = 0; $i &lt; $worker_num; $i++)&#123; //等待执行完成 $ret = swoole_process::wait(); $pid = $ret[&apos;pid&apos;]; //释放进程池中的进程资源 unset($workers[$pid]); echo &quot;Worker Exit, PID=&quot;.$pid.PHP_EOL;&#125; 将PHP脚本上传至服务器并运行，可以看到进程确实pop到了主进程push的数据，但是不知道为什么主进程push数据的时候识别的子进程的ID打印出来是错误的，可以看到子进程的PID分别是9922和9921，回收进程时也是这两个ID，可是接收到主进程push的数据时的PID确实9918和9919","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"php项目","slug":"php项目","permalink":"https://harviealwayshere.github.io/tags/php项目/"},{"name":"swoole","slug":"swoole","permalink":"https://harviealwayshere.github.io/tags/swoole/"}]},{"title":"Swoole(九)同步/异步进程","slug":"swoole9","date":"2018-02-19T09:40:20.000Z","updated":"2018-02-20T09:36:35.836Z","comments":true,"path":"2018/02/19/swoole9/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/19/swoole9/","excerpt":"","text":"Swoole具备进程管理模块，用来代替PHP的pcntl拓展。Process进程是系统中十分昂贵的资源，创建进程消耗很大，可以使用vmstat指令查看系统每秒进程切换次数 1.PHP自带pcntl拓展存在很多不足 pcntl没有提供进程间通信的功能 pcntl不支持重定向标准输入和输出 pcntl只提供了fork这样原始的接口，容易使用错误 swoole_process提供了比pcntl更强大的功能，更易用的API，使PHP在多进程编程方面更加轻松。 2.swoole_process提供了如下特性 swoole_process提供了基于unixsock的进程间通信，使用很简单只需调用write/read或者push/pop即可 swoole_process支持重定向标准输入和输出，在子进程内echo不会打印屏幕，而是写入管道，读键盘 输入可以重定向为*管道读取数据 配合swoole_event模块，创建的PHP子进程可以异步的事件驱动模式swoole_process提供了exec接口，创建的进程可以执行其他程序，与原PHP父进程之间可以方便的通信 3.创建进程：new swoole_process()函数原型：swoole_process::__construct(callable $function, $redirect_stdin_stdout = false, $create_pipe = true);参数： callable $function：子进程创建成功后要执行的函数，底层会自动将函数保存在对象的callback属性上，若要更改执行函数则可赋值新的函数在对象的callback属性。 $redirect_stdin_stdout：重定向子进程的标准输入输出，启动此选项后，子进程输出内容不是打印到屏幕而是写入主进程管道，读取键盘输入变成从管道中读取数据，默认为阻塞读取。 $create_pipe：是否创建管道，启动重定向后此项强制为1/true，如果子进程内没有进程间通信科设置为false。 管道类型：0/false =&gt; 不创建管道，1/true =&gt; 管道类型将设置为SOCK_STREAM(流式)，2 =&gt; 管道类型将设置为SOCK_DGRAM(数据包) 4.启动进程：swoole_process-&gt;start执行fork系统调用，启动进程函数原型：int swoole_process-&gt;start();返回参数：创建成功返回子进程的PID，创建失败返回false启动后可用属性： $process-&gt;pid属性为子进程的PID $process-&gt;pipe属性为管道的文件描述符 5.向管道写入数据：swoole_process-&gt;write函数原型：int swoole_process-&gt;write(string $data);参数：$data的长度在Linux系统下最大不超过8K，MacOS/FreeBSD下最大不超过2K父/子进程调用write，子/父进程可调用read接收数据同步模式：进程内未使用任何异步IO，则管道为同步阻塞模式，如果缓冲区满了，将阻塞直到write操作完成。如Task进程就是同步阻塞模式。异步模式：进程内使用了异步IO，如swoole_event_add(进程事件),进程内wirte操作变成异步模式，swoole底层会监听可写事件，自动完成管道写入。 6.从管道中读取数据：swoole_process-&gt;read函数原型：function swoole_process-&gt;read(int $buffer_size=8192) : string | bool; $buffer_size是缓冲区的大小，默认为8192，最大不超过64K 管道类型为DGRAM数据报(2)时，read可以读取完整的一个数据包 管道类型为STREAM(1/true)时，read是流式的，需要自行处理包完整性问题 读取成功返回二进制数据字符串，读取失败返回false 7.添加进程事件：异步IO，swoole_event_addswoole_event_add函数用于将一个socket加入到底层的reactor事件监听中。此函数可以用在Server或Client模式下。函数原型：bool swoole_event_add(int $sock, mixed $read_callback, mixed $write_callback = null, int $flags = null); int $sock：可以为一下三种类型1.int，就是文件描述符,包括swoole_client的socket,以及第三方扩展的socket（比如mysql）2.stream资源，就是stream_socket_client/fsockopen创建的资源3.sockets资源，就是sockets扩展中socket_create创建的资源，需要在编译时加入 ./configure –enable-sockets mixed $read_callback：可读回调函数 mixed $write_callback:可写事件回调，可以是字符串函数名、对象+方法、类静态方法或匿名函数，当此socket可读时回调指定的函数。 int $flags：事件类型的掩码，可选择关闭/开启可读可写事件，如SWOOLE_EVENT_READ，SWOOLE_EVENT_WRITE，或者SWOOLE_EVENT_READ | SWOOLE_EVENT_WRITE 8.创建同步进程123456789101112131415161718192021222324&lt;?php//创建进程对应的执行函数function doProcess(swoole_process $worker)&#123; var_dump($worker); echo &quot;\\n&quot;; echo &quot;PID : &quot;.$worker-&gt;pid.&quot;\\n&quot;; sleep(5);&#125;//创建进程 没有启动重定向$process = new swoole_process(&quot;doProcess&quot;);$pid = $process-&gt;start();//匿名函数创建进程(启动重定向)$process = new swoole_process(function (swoole_process $process) &#123; $process-&gt;write(&apos;Hello&apos;);&#125;, true);$process-&gt;start();sleep(10);echo $process-&gt;read(); //从管道输出//等待结束，关闭子进程(若不等待结束，容易出现僵尸进程)swoole_process::wait(); 将脚本上传至服务器并启动，可以看到，无重定向打印了$worker的内容和PID，重定向输出了Hello 9.创建异步进程因为子进程会继承父进程的内存和IO句柄，所以如果父进程要创建多个子进程，务必要等待创建完毕后再使用swoole_event_add/异步swoole_client/定时器/信号等异步IO函数。12345678910111213141516171819202122232425262728&lt;?php//进程池 存储进程$workers = []; //进程数量$worker_num = 3;//创建并启动进程for($i=0;$i&lt;$worker_num;$i++)&#123; $process = new swoole_process(&apos;doProcess&apos;); //创建单独新进程 $pid = $process-&gt;start(); //启动进程并获取进程ID $workers[$pid] = $process; //将进程存入进程池&#125;//编写进程执行函数function doProcess(swoole_process $process)&#123; $process-&gt;write(&quot;PID : (&quot;.$process-&gt;pid.&quot;)\\t CallbackFunction(&quot;.$process-&gt;callback .&quot;)&quot;.PHP_EOL); echo &quot;Write Msg : PID(&quot;.$process-&gt;pid.&quot;)\\t CallbackFunction(&quot;.$process-&gt;callback .&quot;)&quot;.PHP_EOL;&#125;//添加进程事件 向每个子进程添加需要执行的事件foreach ($workers as $process) &#123; //子进程也会包含此事件 swoole_event_add($process-&gt;pipe,function($pipe) use($process)&#123; $data = $process-&gt;read(); echo &quot;Receive Msg : &quot;.$data.PHP_EOL; &#125;);&#125;将脚本上传至服务器并启动，可以看到成功将PID和Callback函数写入管道并且读出来了","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"php项目","slug":"php项目","permalink":"https://harviealwayshere.github.io/tags/php项目/"},{"name":"swoole","slug":"swoole","permalink":"https://harviealwayshere.github.io/tags/swoole/"}]},{"title":"Swoole(八)同步TCP客户端","slug":"swoole8","date":"2018-02-18T12:06:51.000Z","updated":"2018-02-21T08:29:45.375Z","comments":true,"path":"2018/02/18/swoole8/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/18/swoole8/","excerpt":"","text":"创建一个TCP的同步客户端，可用于连接我们之前的实例TCP服务器 1.函数讲解1.建立TCP客户端对象：$client = new swoole_client(SWOOLE_SOCK_TCP);2.连接到服务器使用客户端对象的connect方法，参数分别为服务器$ip、服务器端口号$port和连接超时时间$time1$client-&gt;connect(&apos;127.0.0.1&apos;, 9501, 0.5);TCP需要进行3次握手，所以connect至少需要3次网络传输过程3.向服务器发送数据使用客户端对象的send方法，参数为字符串1$client-&gt;send(&quot;hello world&quot;);在发送少量数据时$client-&gt;send都是可以立即返回的。发送大量数据时，socket缓存区可能会塞满，send操作会阻塞。4.从服务器接收数据使用客户端对象的recv方法1$data = $client-&gt;recv();recv操作会阻塞等待服务器返回数据，recv耗时等于服务器处理时间+网络传输耗时之合。5.关闭连接1$client-&gt;close(); 这个客户端是同步阻塞的，connect/send/recv 会等待IO完成后再返回。同步阻塞操作并不消耗CPU资源，IO操作未完成当前进程会自动转入sleep模式，当IO完成后操作系统会唤醒当前进程，继续向下执行代码。 2.代码构建1234567891011121314151617181920212223&lt;?php$client = new swoole_client(SWOOLE_SOCK_TCP);//连接到服务器if (!$client-&gt;connect(&apos;0.0.0.0&apos;, 9501, 0.5))&#123; die(&quot;connect failed.&quot;);&#125;//向服务器发送数据if (!$client-&gt;send(&quot;hello world&quot;))&#123; die(&quot;send failed.&quot;);&#125;//从服务器接收数据$data = $client-&gt;recv();if (!$data)&#123; die(&quot;recv failed.&quot;);&#125;echo &quot;recv data is :&quot;.$data.&quot;\\n&quot;;//关闭连接$client-&gt;close();3.代码演示首先我们打开一个终端，执行一个tcp服务器的脚本之后我们上传tcp客户端脚本至服务器并运行，可以看到客户端连接服务器并发送数据成功，而且还接受到了服务器返回的数据，看看服务器端的反应证明客户端连接成功并且断开连接成功了","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"php项目","slug":"php项目","permalink":"https://harviealwayshere.github.io/tags/php项目/"},{"name":"swoole","slug":"swoole","permalink":"https://harviealwayshere.github.io/tags/swoole/"}]},{"title":"Swoole(七)异步TCP服务器","slug":"swoole7","date":"2018-02-18T11:14:06.000Z","updated":"2018-02-18T12:40:11.428Z","comments":true,"path":"2018/02/18/swoole7/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/18/swoole7/","excerpt":"","text":"Swoole提供了异步任务处理的功能，可以投递一个异步任务到TaskWorker进程池中执行，不影响当前请求的处理速度。在Server程序中如果需要执行很耗时的操作，比如一个聊天服务器发送广播，Web服务器中发送邮件。如果直接去执行这些函数就会阻塞当前进程，导致服务器响应变慢。 1.代码讲解1.创建TCP服务器：$serv = new swoole_server(“0.0.0.0”, 9501);2.设置异步任务的工作进程数1$serv-&gt;set(array(&apos;task_worker_num&apos; =&gt; 4));3.onReceive事件，用来投递异步任务，同时获取此次异步任务的ID12345//投递异步任务$serv-&gt;on(&apos;receive&apos;, function($serv, $fd, $from_id, $data) &#123; //获取此次异步任务的ID $task_id = $serv-&gt;task($data);&#125;);4.onTask事件，用来处理异步任务，同时返回任务执行的结果1234$serv-&gt;on(&apos;task&apos;, function ($serv, $task_id, $from_id, $data) &#123; //返回任务执行的结果 $serv-&gt;finish(&quot;$data -&gt; OK&quot;);&#125;);5.onFinish事件，用来处理异步任务的结果1234//处理异步任务的结果$serv-&gt;on(&apos;finish&apos;, function ($serv, $task_id, $data) &#123; &#125;);6.启动服务器，$serv-&gt;start(); 2.代码运行上传脚本代码至服务器并运行，再开启一个终端可以看到已经有4个额外的worker进程在运行我们把这个终端当作TCP客户端采用TCP方式连接服务器测试，并发送消息此时在另一个终端即TCP服务器端可以看到如下","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"php项目","slug":"php项目","permalink":"https://harviealwayshere.github.io/tags/php项目/"},{"name":"swoole","slug":"swoole","permalink":"https://harviealwayshere.github.io/tags/swoole/"}]},{"title":"Swoole(六)设置定时器","slug":"swoole6","date":"2018-02-18T08:26:36.000Z","updated":"2018-02-18T12:05:24.854Z","comments":true,"path":"2018/02/18/swoole6/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/18/swoole6/","excerpt":"","text":"swoole提供了类似JavaScript的setInterval/setTimeout异步高精度定时器，粒度为毫秒级。使用也非常简单。1.swoole_timer_tick相当于setInterval，是持续触发的函数原型：int $timer_id swoole_timer_tick(int $after_time_ms, mixed $callback function, mixed $user_param)参数： int $after_time_ms：指定触发的时间，单位为毫秒 mixed $callback function：执行的函数，参数有$timer_id mixed $user_param：用户参数返回值：int $timer_id，表示定时器ID 2.swoole_timer_after相当于setTimeout，仅在约定的时间触发一次函数原型：int $timer_id swoole_timer_after(int $after_time_ms, mixed $callback function, mixed $user_param)参数： int $after_time_ms：指定触发的时间，单位为毫秒 mixed $callback function：执行的函数 mixed $user_param：用户参数返回值：int $timer_id，表示定时器ID Tips：可以使用swoole_timer_clear(int $timer_id)清除定时器，参数为定时器ID 3.代码1234567891011&lt;?php//定时器 循环执行swoole_timer_tick(5000,function($timer_id)&#123; echo &quot;Tick 5s timer(ID:&quot;.$timer_id.&quot;) \\n&quot;;&#125;);//定时器 单次执行swoole_timer_after(3000,function($timer_id)&#123; echo &quot;After 3s timer(ID:&quot;.$timer_id.&quot;) \\n&quot;;&#125;);4.演示将脚本上传服务器后执行可看到如下结果","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"php项目","slug":"php项目","permalink":"https://harviealwayshere.github.io/tags/php项目/"},{"name":"swoole","slug":"swoole","permalink":"https://harviealwayshere.github.io/tags/swoole/"}]},{"title":"Swoole(五)配置WebSocket服务器","slug":"swoole5","date":"2018-02-16T12:21:49.000Z","updated":"2018-02-16T18:47:06.365Z","comments":true,"path":"2018/02/16/swoole5/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/16/swoole5/","excerpt":"","text":"接来下我们来学习配置一个WebSocket服务器1.首先介绍下什么是websocket初次接触 WebSocket 的人，都会问同样的问题：我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？答案很简单，因为 HTTP 协议有一个缺陷：通信只能由客户端发起。这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。一般有两种方法 AJAX轮询：让浏览器隔个几秒就发送一次请求，询问服务器是否有新信息。 Long Poll：原理跟AJAX轮询差不多，都是采用轮询的方式，不过采取的是阻塞模型，也就是说，客户端发起连接后，如果没消息，就一直不返回Response给客户端。直到有消息才返回，返回完之后，客户端再次建立连接，周而复始。 WebSocket协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。 2.Swoole实现Websocket服务端先上代码然后解释12345678910111213141516171819&lt;?php$ws = new swoole_websocket_server(&quot;0.0.0.0&quot;, 9504);$ws-&gt;on(&apos;open&apos;, function ($ws, $request) &#123; var_dump($request); $ws-&gt;push($request-&gt;fd,&quot;welcome to harvie&apos;s home !\\n&quot;)&#125;);$ws-&gt;on(&apos;message&apos;, function ($ws, $frame) &#123; echo &quot;receive from &#123;$frame-&gt;fd&#125;:&#123;$frame-&gt;data&#125;,opcode:&#123;$frame-&gt;opcode&#125;,fin:&#123;$frame-&gt;finish&#125;\\n&quot;; $ws-&gt;push($frame-&gt;fd, &quot;get it message !&quot;);&#125;);$ws-&gt;on(&apos;close&apos;, function ($ws, $fd) &#123; echo &quot;client &#123;$fd&#125; closed\\n&quot;;&#125;);$ws-&gt;start(); 3.代码解释1.构建websocket服务器对象：swoole_websocket_server($ip,$port)2.设置回调函数事件:2.1 open事件：建立连接事件， function (swoole_websocket_server $server, $request)，$server是服务器信息，$request是客户端信息2.2 message事件：接收消息事件，function (swoole_websocket_server $server, $request)，$server是服务器信息，$frame是客户端信息2.3 close：关闭连接事件，function (swoole_websocket_server $server, $fd)，$server是服务器信息，$frame是客户端信息2.4 使用swoole_websocket_server-&gt;push(int $fd, string $data, int $opcode = 1, bool $finish = true);向websocket客户端连接推送数据 $fd为客户端连接的ID $data为发送的数据内容 $opcode指定发送数据内容的格式，默认为文本。发送二进制内容$opcode参数需要设置为WEBSOCKET_OPCODE_BINARY $finish发送成功返回true，发送失败返回false3.启动服务器 4.测试运行将脚本上传到服务器并运行，打开浏览器，输入ip地址和端口号可以看到并不能成功访问，必须实现WebSocket协议才能和WebSocket服务器通信，我们创建一个前台websocket页面，代码如下12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=&quot;text/javascript&quot;&gt; var wsServer = &apos;ws://39.108.210.229:9504&apos;; var websocket = new WebSocket(wsServer); websocket.onopen = function (evt) &#123; console.log(&quot;连接成功&quot;); &#125;; websocket.onclose = function (evt) &#123; console.log(&quot;连接关闭&quot;); &#125;; websocket.onmessage = function (evt) &#123; console.log(&apos;从服务器接受到的数据为：&apos; + evt.data); &#125;; websocket.onerror = function (evt, e) &#123; console.log(&apos;错误发生信息: &apos; + evt.data); &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;然后放在我们Windows客户端下的Apache服务器下执行，可以打开浏览器看到此时我们可以看到服务器中打印了相关的请求信息","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"php项目","slug":"php项目","permalink":"https://harviealwayshere.github.io/tags/php项目/"},{"name":"swoole","slug":"swoole","permalink":"https://harviealwayshere.github.io/tags/swoole/"}]},{"title":"Swoole(四)配置Web服务器","slug":"swoole4","date":"2018-02-16T11:56:47.000Z","updated":"2018-02-16T18:25:40.553Z","comments":true,"path":"2018/02/16/swoole4/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/16/swoole4/","excerpt":"","text":"接来下我们来学习Swoole的基本函数，以此来配置一个Web服务器1.基本函数1.1 swoole_http_server：swoole_http_server继承自swoole_server，是一个完整的http服务器实现，支持同步和异步2种模式。函数原型：$http = new swoole_http_server($ip, $port); $ip：监听的ip $port：监听的端口 1.2 swoole_http_server-&gt;on:注册事件回调函数。swoole_http_server-&gt;on不接受onConnect/onReceive回调设置，swoole_http_server-&gt;on 额外接受1种新的事件类型onRequest123$http_server-&gt;on(&apos;request&apos;, function($request,$response) &#123; $response-&gt;end(&quot;&lt;h1&gt;hello swoole&lt;/h1&gt;&quot;);&#125;);在收到一个完整的Http请求后，会回调此函数。回调函数共有2个参数： $request：Http请求信息对象，包含了header/get/post/cookie等相关信息 $response：Http响应对象，支持cookie/header/status等Http操作 $response-&gt;end()：向客户端发送信息Tips：在onRequest回调函数返回时底层会销毁$request和$response对象，如果未执行$response-&gt;end()操作，底层会自动执行一次$response-&gt;end(“”) 2.构建基本的Web服务器1.构建swoole_http_server对象，设置监听对象为所有ip地址，端口为9503端口2.注册回调事件request，打印请求信息对象和返回Hello Swoole+一个随机数(证明每次访问返回不同)，$response-&gt;end()方法表示输出一段HTML内容，并结束此请求。3.启动服务器123456789$http = new swoole_http_server(&quot;0.0.0.0&quot;, 9503);$http-&gt;on(&apos;request&apos;, function ($request, $response) &#123; var_dump($request); $response-&gt;header(&quot;Content-Type&quot;, &quot;text/html; charset=utf-8&quot;); $response-&gt;end(&quot;&lt;h1&gt;Hello Swoole. #&quot;.rand(1000, 9999).&quot;&lt;/h1&gt;&quot;);&#125;);$http-&gt;start();我们先上传php脚本到服务器，之后执行然后我们使用浏览器访问服务器的ip地址，可以看到此时我们可以看到服务器会打印请求对象的信息我们再次刷新服务器可以看到随机数会变化","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"php项目","slug":"php项目","permalink":"https://harviealwayshere.github.io/tags/php项目/"},{"name":"swoole","slug":"swoole","permalink":"https://harviealwayshere.github.io/tags/swoole/"}]},{"title":"Swoole()配置UDP服务器","slug":"swoole3","date":"2018-02-16T09:23:01.000Z","updated":"2018-02-16T10:32:02.589Z","comments":true,"path":"2018/02/16/swoole3/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/16/swoole3/","excerpt":"","text":"接来下我们来学习Swoole的基本函数，以此来配置一个UDP服务器1.基本函数1.1 swoole_server-&gt;sendto：向任意的客户端IP:PORT发送UDP数据包。函数原型：bool swoole_server-&gt;sendto(string $ip, int $port, string $data, int $server_socket = -1); $ip:为IPv4字符串，如192.168.1.102。如果IP不合法会返回错误 $port:为 1-65535的网络端口号，如果端口错误发送会失败 $data:要发送的数据内容，可以是文本或者二进制内容 $server_socket服务器可能会同时监听多个UDP端口，此参数可以指定使用哪个端口发送数据包 2.构建基本的UDP服务器UDP服务器与TCP服务器不同，UDP没有连接的概念。启动Server后，客户端无需Connect，直接可以向Server监听的9502端口发送数据包。对应的事件为onPacket。构建步骤：1.创建swoole_server对象，注意$sock_type类型选择SWOOLE_SOCK_UDP2.注册监听事件，对应事件为Packet，回调函数类型为function ($serv, $data, $clientInfo)3.调用$server-&gt;sendto方法向客户端发送数据4.启动服务器 12345678910111213&lt;?php//创建Server对象，监听 0.0.0.0:9502端口，类型为SWOOLE_SOCK_UDP$serv = new swoole_server(&quot;127.0.0.1&quot;, 9502, SWOOLE_PROCESS, SWOOLE_SOCK_UDP); //监听数据接收事件$serv-&gt;on(&apos;Packet&apos;, function ($serv, $data, $clientInfo) &#123; $serv-&gt;sendto($clientInfo[&apos;address&apos;], $clientInfo[&apos;port&apos;], &quot;Server &quot;.$data); var_dump($clientInfo);&#125;);//启动服务器$serv-&gt;start(); 接下来我们上传文件到服务器并启动可以看到已经启动了，为了确保启动成功我们可以再开一个终端连接服务器查看进程接下来我们使用网络调试助手NetAssist来测试，上次使用windows自带的telnet感觉太鸡肋了，这个小工具简单好用，我下载的是V3.8.1，其实都大同小异","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"php项目","slug":"php项目","permalink":"https://harviealwayshere.github.io/tags/php项目/"},{"name":"swoole","slug":"swoole","permalink":"https://harviealwayshere.github.io/tags/swoole/"}]},{"title":"Swoole(二)配置TCP服务器","slug":"swoole2","date":"2018-02-14T17:55:02.000Z","updated":"2018-02-16T11:39:36.344Z","comments":true,"path":"2018/02/15/swoole2/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/15/swoole2/","excerpt":"","text":"接来下我们来学习Swoole的基本函数，以此来配置一个TCP服务器1.基本函数1.1 swoole_server：创建一个异步Server对象。函数原型：$serv = new swoole_server(string $host, int $port = 0, int $mode = SWOOLE_PROCESS, int $sock_type = SWOOLE_SOCK_TCP); $host:指定监听的ip地址IPv4使用 127.0.0.1表示监听本机，0.0.0.0表示监听所有地址IPv6使用::1表示监听本机，:: (相当于0:0:0:0:0:0:0:0) 表示监听所有地址 $port:监听的端口如果$sock_type为UnixSocket Stream/Dgram，此参数将被忽略监听小于1024端口需要root权限如果此端口被占用server-&gt;start时会失败 $mode:运行的模式SWOOLE_PROCESS多进程模式（默认）SWOOLE_BASE基本模式 $sock_type:指定Socket的类型支持TCP、UDP、TCP6、UDP6、UnixSocket Stream/Dgram 6种 1.2 swoole_server-&gt;on：注册Server的事件回调函数。函数原型：bool swoole_server-&gt;on(string $event, mixed $callback); $event:回调的名称connect：建立连接时receive：接收到数据时close：关闭连接时 $callback:回调的PHP函数，可以是函数名的字符串，类静态方法，对象方法数组，匿名函数。connect：function ($serv, $fd){} $serv:服务器信息 $fd:客户端信息receive：function ($serv, $fd, $from_id, $data){} $from_id:客户端ID $data:接收的数据close：function ($serv, $fd){} $serv:服务器信息 $fd:客户端信息 1.3 swoole_server-&gt;start：启动server，监听所有TCP/UDP端口。函数原型：bool swoole_server-&gt;start()启动成功后会创建:Master进程+Manager进程+serv-&gt;worker_num个Worker进程 Master进程:主进程内有多个Reactor线程，基于epoll/kqueue进行网络事件轮询。收到数据后转发到worker进程去处理 Manager进程:对所有worker进程进行管理，worker进程生命周期结束或者发生异常时自动回收，并创建新的worker进程 Worker进程:对收到的数据进行处理，包括协议解析和响应请求。 启动失败会立即返回false启动成功后将进入事件循环，等待客户端连接请求。start方法之后的代码不会执行服务器关闭后，start函数返回true，并继续向下执行 1.4 swoole_server-&gt;send：向客户端发送数据。函数原型：bool swoole_server-&gt;send(int $fd, string $data, int $extraData = 0); $data:发送的数据TCP协议最大不得超过2M，可修改buffer_output_size改变允许发送的最大包长度UDP协议不得超过65507，UDP包头占8字节, IP包头占20字节，65535-28 = 65507 UDP服务器使用$fd保存客户端IP，$extraData保存server_fd和port 发送成功会返回true发送失败会返回false，调用$server-&gt;getLastError()方法可以得到失败的错误码 2.构建基本的TCP服务器使用上述三个函数就可以构建出一个基本的TCP服务器了12345678910111213141516171819202122&lt;?php//创建Server对象，监听 0.0.0.0:9501端口$serv = new swoole_server(&quot;0.0.0.0&quot;, 9501); //监听连接进入事件$serv-&gt;on(&apos;connect&apos;, function ($serv, $fd) &#123; echo &quot;Client: Connect.\\n&quot;;&#125;);//监听数据接收事件$serv-&gt;on(&apos;receive&apos;, function ($serv, $fd, $from_id, $data) &#123; $serv-&gt;send($fd, &quot;Server: &quot;.$data);&#125;);//监听连接关闭事件$serv-&gt;on(&apos;close&apos;, function ($serv, $fd) &#123; echo &quot;Client: Close.\\n&quot;;&#125;);//启动服务器$serv-&gt;start(); 之后我们把tcpServer.php上传到服务器上在服务器端运行这个脚本我们可以再次连接服务器，通过查看进程确认脚本是否执行首先可以看到有一个进程-bash在使用一个子进程ps -ajft查看进程，这个bash就是我们连接服务器的进程然后可以看到有一个进程-bash有三个子进程在执行，可以看出分别是Master进程(32680)、Manager进程(32681)和Worker进程(32683)此时我们可以通过客户端使用网络工具来连接服务器（x为ip地址，y为端口号），我使用的是windows自带的telnet服务，具有TCP连接功能，如何开启请看这里可以看到成功连接并且实现了向客户端返回数据的功能，若是无法正常连接，可能有如下三种原因 在Linux下，使用netstat -an | grep 端口或者lsof -i:9501，查看端口是否已经被打开处于Listening状态，若处于可以看看是什么哪个进程在使用这个端口，并用kill -9 进程号(PID)，结束这个进程重新开放端口 上一步确认后，检查防火墙问题，最好使用命令systemctl stop firewalld.service 注意服务器所使用的IP地址，如果是127.0.0.1回环地址，则客户端只能使用127.0.0.1才能连接上 若是阿里云服务器，记得在阿里云控制台中安全组设置开放外界端口号 这时我们的基本的tcp服务器就已经搭建好了，若需要关闭这个进程，可以使用kill -9 进程号关闭掉Master的父进程-bash(32618)即可，此时再使用ps -ajft和netstat -an | grep 9501，可看到进程结束并且端口不再处于监听状态即可 我们搭建基本tcp服务器的过程就结束了，接下来我们将会学习如何搭建别的类型服务器，如UDP、Web、Websocket、异步TCP，还有一些队列通信、信号触发、DNS查询、异步文件IO、异步mysql等。","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"php项目","slug":"php项目","permalink":"https://harviealwayshere.github.io/tags/php项目/"},{"name":"swoole","slug":"swoole","permalink":"https://harviealwayshere.github.io/tags/swoole/"}]},{"title":"剑指Offer算法记录(二)算法","slug":"offer2","date":"2018-02-14T10:24:24.000Z","updated":"2018-02-14T12:07:04.290Z","comments":true,"path":"2018/02/14/offer2/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/14/offer2/","excerpt":"","text":"本文主要记录阅读剑指Offer这本书所遇到的算法解释并作一些个人的拓展 第二章2.4 算法和数据操作排序和查找是面试时考查算法的重点，如二分查找、归并排序、快速排序等。递归和循环是两种算法实现的方式，基于递归的实现较整洁但性能不如基于循环实现的方法，我们应该根据题目特点来选择使用哪种实现方式。 位运算可以看做一类特殊的算法，共有与、或、异或、左移和右移五种位运算2.4.1 查找和排序查找不外乎：顺序查找、二分查找、哈希表查找和二叉排序树查找，无论用递归还是循环都需要掌握这些查找方法的实现。排序则复杂一些：插入排序、冒泡排序、归并排序、快速排序等不同算法的优劣，能够从额外空间消耗、平均时间复杂度和最差时间复杂度等方面去比较它们的优缺点。值得一提的是，快速排序的实现代码是面试官钟爱的。快速排序思路:选择一个数字(有多种选择法)，接下来把数组中的数字分成两部分，比选择的数字小的数字移到数组的左边，比选择数字大的数字移到数组右边1234567891011121314151617181920212223int Partition(int data[], int length, int start, int end)&#123; if(data==NULL || length&lt;=0 || start&lt;0 || end&gt;=length) //输入参数有效行检验 throw new std::exception(&quot;Invalid Parameters&quot;); int index = RandomInRange(start,end); //函数RandomInRange生成[start,end]的随机数 Swap(&amp;data[index], &amp;data[end]); int small = start-1; for(index=start; index&lt;end; index++) &#123; if(data[index]&lt;data[end]) &#123; small++; if(small!=index) Swap(&amp;data[index], &amp;data[small]); &#125; &#125; small++; Swap(&amp;data[small], &amp;data[end]); return small;&#125;","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://harviealwayshere.github.io/tags/算法/"}]},{"title":"Swoole(一)安装","slug":"swoole1","date":"2018-02-09T16:29:04.000Z","updated":"2018-02-09T17:55:49.101Z","comments":true,"path":"2018/02/10/swoole1/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/10/swoole1/","excerpt":"","text":"说到PHP异步网络通信框架，相信PHPer脑海里第一个浮现的便是Swoole。 商业应用：IM聊天、战旗TV、虎牙直播、YY语音等。 应用领域：互联网、网络通信、企业软件、云计算、网络游戏、物理网等。 特点：1.异步、并行、高性能2.纯C编写，接近应用底层3.php扩展 应用：1.异步多线程服务器及客户端2.异步MySQL、Redis、数据库连接池、任务队列3.http/websocket服务器/客户端4.异步文件读写5.Swoole2.0支持协程 安装Swoole大致可分成3个步骤:1.搭建Linux操作系统2.安装环境依赖(php,gcc,httpd，pecl)3.安装Swoole并修改php.ini Part1:搭建Linux操作系统查看官方文档可知Swoole并不支持Windows系统，所以我们这里搭建一个CentOS 7.3 64位的操作系统，我是使用阿里云云服务器 ECS搭建的，使用系统盘安装即可，安装完毕之后可以远程连接进入云服务器中的Linux系统中Tips:如果想在Windows下便捷操作云服务器的系统，推荐使用SSH连接软件，这里我使用的是SSH Secure Shell Client3.2.9，安装完成后有两个工具可以使用，分别对应Linux系统的命令行界面和Linux文件系统的GUI界面的，十分便捷客观，提供工作效率。可参考这篇博客安装使用。连接成功后的界面为 Part2:安装环境依赖(php,gcc,httpd，pecl)在CentOS中使用yum安装php7，由于初始yum所安装的php版本是5.*的，我们首先要获取php7的yum源1234567891011//1.安装epel-releaseyum -y install epel-release //2.获取php7的yum源rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm//3.安装php7yum install php70w//4.验证安装php -v安装完成后可看到php版本之后我们要安装gcc和httpd1yum install httpd gcc最后我们要安装pecl，因为swoole项目已收录到PHP官方扩展库，可直接使用pecl安装swoole12wget http://pear.php.net/go-pear.pharphp go-pear.phar Part3:安装Swoole并修改php.ini1sudo pecl install swoole 会报错如下，别着急输入1vi `which pecl`进入Linux的Vim编辑模式，一直向下查找找到这个文件的最后一行按I进入Vim的插入模式，之后将-n标志去掉，按ESC进入Vim的退出(末行)模式，输入[:wq!]保存并退出之后安装 php-devel1sudo yum install php70w-devel再次安装swoole1sudo pecl install swoole成功安装！根据提示要添加”extension=swoole.so”在php配置文件php.ini中，我这里由于对于Vim的操作并不熟悉，我直接通过SSH软件将php.ini文件拉取到本地之后修改再上传到服务器php.ini一般在/etc目录下拉取到本地后添加”extension=swoole.so”语句，随意在任何两个配置语句中增加之后通过语句[php -m]可查看php拓展安装情况，如果看到swoole则安装成功！ 如果你实践完成了本教程，意味着你对于Linux和Windows系统的协同开发、php拓展安装已经了解了基本情形了，接下来我们将使用swoole开发php应用，敬请期待。","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"php项目","slug":"php项目","permalink":"https://harviealwayshere.github.io/tags/php项目/"},{"name":"swoole","slug":"swoole","permalink":"https://harviealwayshere.github.io/tags/swoole/"}]},{"title":"剑指Offer算法记录(一)数据结构","slug":"offer","date":"2018-02-07T08:20:05.000Z","updated":"2018-02-14T10:24:04.055Z","comments":true,"path":"2018/02/07/offer/","link":"","permalink":"https://harviealwayshere.github.io/2018/02/07/offer/","excerpt":"","text":"本文主要记录阅读剑指Offer这本书所遇到的算法解释并作一些个人的拓展 第二章2.2.1 关于sizeof的小知识 sizeof 对于空类型(无成员变量和成员函数)的实例 = 1字节：由于声明空类型的实例必须在内存中占用一定空间否则无法使用，占用多少内存由编译器决定，在VS中每个空类型实例占用1字节。 sizeof 对于空类型+构造和析构函数的实例 = 1字节 ：调用函数只需知道函数地址即可，函数地址只与类型有关而与类型的实例无关，因此sizeof实例还是1字节。 sizeof 对于空类型+构造函数+虚析构函数(虚函数) = 1个指针大小：一个类型中有虚拟函数就会为该类型生成虚函数表，并为这个类型的每个实例中添加一个指向虚函数表的指针，指针大小与机器有关，32为指针为4字节，64位指针为8字节。1234567891011121314151617181920212223242526class B //空类型&#123;&#125;;class C //空类型+构造和析构函数&#123;public: C()&#123;&#125;; ~C()&#123;&#125;;&#125;;class D //空类型+构造函数+虚析构函数(虚函数)&#123;public: D()&#123;&#125;; virtual ~D()&#123;&#125;;&#125;;int main()&#123; B b; C c; D d; cout &lt;&lt; &quot;空类型大小:&quot; &lt;&lt; sizeof(b)&lt;&lt;endl; cout &lt;&lt; &quot;空类型+构造和析构函数大小:&quot; &lt;&lt; sizeof(c) &lt;&lt; endl; cout &lt;&lt; &quot;空类型+构造函数+虚析构函数(虚函数)大小:&quot; &lt;&lt; sizeof(d) &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 总结：空的类是会占用内存空间的，而且大小是1，原因是C++要求每个实例在内存中都有独一无二的地址。 类内部的成员变量：*普通的变量：是要占用内存的，但是要注意对齐原则（这点和struct类型很相似）。*static修饰的静态变量：不占用内容，原因是编译器将其放在全局变量区。 类内部的成员函数：*普通函数：不占用内存。*虚函数：要占用4个字节，用来指定虚函数的虚拟函数表的入口地址。所以一个类的虚函数所占用的地址是不变的，和虚函数的个数是没有关系的 2.2.1 关于复制函数的小知识C++标准不允许复制构造函数传值参数，否则会造成递归重复调用，编译错误。12345678910111213141516171819202122232425262728293031323334353637383940class E&#123;private: int num;public: //构造函数 E(int x) :num(x) &#123; cout &lt;&lt; &quot;constructor call&quot; &lt;&lt; endl; &#125; //复制构造函数 传引用调用 E(E&amp; x) &#123; num = x.num; cout &lt;&lt; &quot;copy constructor call&quot; &lt;&lt; endl; &#125; //赋值运算符重载 E&amp; operator = (E&amp; x) &#123; num = x.num; cout &lt;&lt; &quot;assignment operator call&quot; &lt;&lt; endl; return *this; &#125; //函数调用 void showNum(E x) &#123; &#125; &#125;;int main()&#123; E a(1); //1式 E b(2); //2式 b = a; //3式 E c = a; //4式 c.showNum(a); //5式 system(&quot;pause&quot;); return 0;&#125;运行结果如图： 1/2式 =&gt; 若是实例创建并初始化时调用相应参数的构造函数 3式 =&gt; 若是实例已经创建初始化后再用=赋值，则调用=重载赋值函数 4式 =&gt; 若是实例用另一个同类实例初始化，则调用复制构造函数 5式 =&gt; 若是实例使用方法调用另一个实例，则首先调用复制构造函数将实参复制给形参后执行相关操作 因此就可以解释为什么C++不允许复制构造函数传值了，若是传值，则调用E c = a或者c.showNum(a)或者的时候，a作为参数传值给c的复制构造函数的参数E x，因为x没有被初始化，所以要调用x的复制构造函数将a复制给x，即x.E(a)，然而x的复制构造函数也是传值的，因此又要将a作为参数传值给c的复制构造函数的参数x的复制构造函数的参数E x，又因为这个x也没有被初始化，又要调用这个x的复制构造函数，造成了无限的递归。因此复制构造函数的参数使用引用调用不是为了减少一次内存的复制，而是为了避免复制构造函数无限递归调用的情况出现。下面这几种情况下会调用复制构造函数:（1）显式或隐式地用同类型的一个对象来初始化另外一个对象。如上例中的E c=a;（2）作为实参传递给一个函数。如上例中的c.showNum(a);（3）在函数体内返回一个对象时，也会调用返回值类型的拷贝构造函数（4）初始化序列容器中的元素时。比如vector svec(5)，string的缺省构造函数和拷贝构造函数都会被调用。（5）用列表的方式初始化数组元素时。string a[] = {string(“hello”),string(“world”)};会调用string的拷贝构造函数。 面试题 1：赋值运算符函数赋值运算符函数基础4要数:1.返回值类型声明为该类型的引用并在函数结束前返回实例自身引用：只有这样才能实现连续赋值运算2.参数类型声明为常量引用:常量是因为在函数体内不改变传入实参状态，引用是可以减少一次从形参到实参的复制构造函数的调用，节省空间开销提高代码效率3.释放实例自身已有内存:在分配新内存之前释放已有空间，避免内存泄露4.需要判断传入参数和当前实例(*this)是不是同一个实例:若是同一个则不进行赋值直接返回，若没有判断则在释放实例自身内存时传入的参数的内存也被释放了，就再也找不到需要赋值的内容了结合以上4点的解法1234567891011CMyString&amp; CMyString::operator =(const CMyString &amp;str) //返回值+参数(1.2.)&#123; if(this == $str) return *this; //判断是否是自身赋值自身(4.) delete []m_pData; //被赋值的实例的成员变量delete释放内存(3.) m_pData = NULL; //初始化变量 m_pData = new char[strlen(str.m_pData)+1]; //new分配内存 strcpy(m_pData,str.m_pData); //赋值 return *this; //返回自身实例用于连续赋值运算(1.)&#125; 考虑异常安全性:若new char时内存不足导致抛出异常，m_pData将是空指针，程序十分容易崩溃，此时由于被赋值的实例的成员变量已经被delete了，实例改变了自身的状态，违背了异常安全原则。解决方案:1.先new分配内存再delete释放内存，当new失败时我们能确保实例不会被修改原先状态2.先创建一个临时实例，再交换临时实例和原来的实例，如下1234567891011121314CMyString&amp; CMyString::operator =(const CMyString &amp;str) &#123; if(this != $str) &#123; CMyString strTemp(str); //调用复制构造函数新创建一个临时实例 char* pTemp = strTemp.m_pData; //利用一个中间变量pTemp将变量值交换 strTemp.m_pData = m_pData; m_pData = pTemp; &#125; //在if作用域外，由于strTemp是局部变量会自动调用析构函数释放内存，//其中strTemp中的成员变量m_pData所指向的内存就是原来被赋值实例成员函数的内存，刚好一并释放 return *this;&#125; 面试题 2：实现Singleton（单例）模式首先单例模式最基本的有3点：1.构造函数私有:不能被外界随意调用2.单例对象实例:此类型只能生成一个实例3.单例获取函数:只能获取到同一个实例基于这三点我们可以写出第一版单例模式123456789101112public class Singleton1&#123; private Singleton1()&#123;&#125; //私有构造函数 private static Singleton1 instance = NULL; //单例对象实例 public static Singleton1 getInstance() //单例获取函数 &#123; if(instance == NULL) instance = new Singleton1(); return instance; &#125;&#125;//其中第四行我们也可以写成private static Singleton1 instance = new Singleton1();//这样在getInstance()中就不需要判空操作，这属于饿汉模式(主动创造)，一开始初始值是NULL属于懒汉模式(等人调用才创造)第二版单例模式:第一版的单例模式是非线程安全的，当最初情况两个线程同时判断instance是否为空时(针对懒汉模式)，则两个线程会创建两个实例不满足单例模式要求，因此在多线程下我们要加上一个同步锁12345678910111213141516171819202122232425public class Singleton2&#123; private Singleton2()&#123;&#125; private static Singleton1 instance = NULL; private static object syncObj = new object(); //C#同步锁 public static Singleton2 getInstance() &#123; if(instance == NULL) //一次检测:只有instance为NULL时需要加锁操作，节省开销 &#123; lock(syncObj) &#123; //二次检测:当两个进程同时访问，线程A创建完对象开锁后 //线程B还是会进入临界区创建对象，因此需要第二次检测 if(instance == NULL) instance = new Singleton1(); &#125; &#125; return instance; &#125;&#125;//其中第十二行只是C#同步锁的操作，JAVA中可使用synchronized(Singleton2.class)&#123;&#125;操作第三版单例模式:C#中有一个函数确保只调用一次，就是静态构造函数(饿汉模式)123456789public class Singleton3&#123; private Singleton3()&#123;&#125; private static Singleton3 instance = new Singleton3(); //由于C#在调用静态构造函数时初始化静态变量，.NET运行时能够确保只调用一次静态构造函数 public static Singleton3 getInstance() &#123; return instance; &#125;&#125;第四版单例模式:按需创造/懒加载 JAVA中可以使用静态内部类1.因为从外部无法访问静态内部类，只有调用Singleton.getInstance方法才能得到单例对象INSTANCE2.INSTANCE对象初始化并不是在类Singleton被加载时，而是在调用getInstance方法时加载静态内部类LazyHolder时才被初始化，这种方式是利用classloader的加载机制实现懒加载（需要时才创建），从而保证偶见单例的线程安全1234567891011121314public class Singleton4&#123; private Singleton4()&#123;&#125; private static class LazyHolder //静态内部类 &#123; private static final Singleton INSTANCE = new Singleton4(); &#125; public static Singleton4 getInstance() &#123; return LazyHolder.INSTANCE; &#125;&#125; C++中可以使用嵌套类型123456789101112131415public class Singleton4&#123; private Singleton4()&#123;&#125; class Nested //嵌套类型 &#123; static Newted()&#123;&#125; //嵌套类型的构造函数 internal static readonly Singleton4 instance = new Singleton4(); &#125; public static Singleton4 getInstance() &#123; return Nested.instance; &#125;&#125;第五版单例模式:无论怎么样设计单例模式，均可以通过反射打破单例反射打破单例过程：123456789//第一步：获得单例类的构造器Constructor con = SingletonEnum.class.getDeclaredConstructor();//第二步：把构造器设置为可访问con.setAccessible(true);//第三步：使用newInstance构造不同的对象SingletonEnum singleton1 = (SingletonEnum)con.newInstance();SingletonEnum singleton2 = (SingletonEnum)con.newInstance();//验证是否是同一对象 =&gt; falseSystem.out.println(singleton1.equals(singleton2));针对防止反射的方式构建对象，在JAVA中可以使用枚举的方式构建类，因为JAM会住址反射获取枚举类的私有构造方法，这还可以实现线程安全性，但是唯一的缺点就是并非使用懒加载，单例对象是在枚举类被加载的时候进行初始化的。1234//枚举实现单例模式public enum SingletonEnum&#123; INSTANCE;&#125; 总结：单例模式升级步骤——基本模式(1.)+线程安全(2.)+懒加载(提升使用效率)(3.4.)+防止反射构建(5.)2.3 数组和指针区别输出 “20,4,4”20：data1是一个数组，包含五个整数，每个整数占4字节，一共20字节4：data2是一个指针指向data1数组的第一个数字，指针大小为4字节4：在C/C++中数组作为参数传递时自动退化为同类型的指针，因此为4字节 面试题3：二维数组中的查找一般的思路是从左上角开始做比较，但是减小排除的范围无规律，若是从右上角或者左下角做比较，则可以以行或者列减小排查范围，而二维数组以连续内存存储的特性让我们可以通过下标访问数组以矩阵形式的空间位置。1234567891011121314151617181920212223bool Find(int* matrix, int rows, int columns, int number)&#123; bool found = false; if(matrix != NULL &amp;&amp; rows &gt;0 &amp;&amp; columns &gt;0) //矩阵有效性检测（若输入空指针） &#123; int row = 0; int column = column -1; while(row &lt; rows &amp;&amp; column &gt;=0) //循环停止条件:最后一行或者第一列 &#123; if(matrix[row * columns + column] == number) //第row行第column列，相当于[row][column] &#123; found = true; break; &#125; else if(matrix[row * columns + column] &gt;number) column--; else row++; &#125; &#125; return found;&#125; 2.3.2字符串小知识C/C++中每个字符串以’/0’作为结尾，这样可以方便地找到字符串的结尾，但有额外字符开销，易越界。C/C++将常量字符串放到一个单独的内存区域节省内存，当几个指针赋值给相同的常量字符串时，他们实际上会指向相同的内存地址，但是用常量内存初始化数组却会创建新空间。 面试题4：替换空格网络编程中，URL参数中特殊字符串(空格、#等)需要替换成服务器端可以识别的字符，转换的规则是在’%’后面加上字符ASCII码的两位十六进制表示，如空格的ASCII码为32，十六进制为0x20，因此空格被替换成”%20”。解题思路:题目理解有两种，第一种是创建新的字符串并在新的字符串上做替换，则我们可以分配足够多的内存，第二种是在原字符串上做替换，则我们需要保证输入字符串后有足够多的空余内存并且不能覆盖原字符串的内存。解法一:字符串从前往后遍历找到一个空格则空格后的字符集体向后移动两个字节大小。时间复杂度为O(n^2)，多次移动次数，不是好的解决方案。解法二:先遍历一次字符串，统计出字符串中空格总数由此计算出替换后字符串的长度，之后从字符串末尾开始复制和替换，这样所有字符只移动一次，算法的时间效率是O(n)。具体的复制和替换过程为使用两个指针 123456789101112131415161718192021222324252627282930313233343536373839404142void ReplaceBlank(char string[], int maxLength)&#123; if(string == NULL &amp;&amp; length &lt;= 0) //输入参数有效性检测性 return; //originalLength为字符串原先长度 int originalLength = 0; int numberOfBlank = 0; int i = 0; while(string[i] != &apos;\\0&apos;) &#123; originalLength++; if(string[i] == &apos; &apos;) numberOfBlank++; i++; &#125; //newLength为替换后的字符串长度 int newLength = originalLength + numberOfBlank * 2; if(newLength &gt; maxLength) //如果替换后字符串长度大于字符串总容量 return; int indexOfOriginal = originalLength; int indexOfNew = newLength; while(indexOfOriginal &gt;= 0 &amp;&amp; indexOfNew &gt; indexOfOriginal)//替换完成条件 &#123; //若是空格则后面的标记添加并前移三个字节 if(string[indexOfOriginal] == &apos; &apos;) &#123; string[indexOfNew --] = &apos;0&apos;; string[indexOfNew --] = &apos;2&apos;; string[indexOfNew --] = &apos;%&apos;; &#125; else &#123; //若不空格则复制前面指针的字符到后面指针的位置，并前移指针 string[indexOfNew --] = string[indexOfOriginal]; &#125; -- indexOfOriginal; &#125; &#125;2.3.3 链表小知识链表是由指针把若干个节点连接成链状结构，链表的创建、插入节点、删除节点等操作只需要20行代码就可以实现，比较适合面试。链表是一种动态结构，创建时无需知道链表的长度，每添加一次节点再分配新内存，然后调整指针的指向。单向链表的节点定义如下12345struct ListNode&#123; int Value; ListNode* Next;&#125;往链表末尾添加一个节点的函数如下要点：1.头指针的传参 2.插入的节点是第一个节点的情况(空链表/头指针为空)1234567891011121314151617181920void addToTail(ListNode** pHead, int value) //由于头指针可能改变，因此要以传指针的形式传参，否则出了函数头指针依然是空指针&#123; ListNode* pNew = new ListNode(); pNew-&gt;Value = value; pNew-&gt;Next = NULL; //注意新节点的Next初始化为NULL if(*pHead == NULL) //若是往一个空链表插入节点，则头指针指向新节点 &#123; *pHead = pNew; &#125; else //否则找到头指针指向第一个节点，开始遍历找到最后一个节点，将节点的Next指向新节点 &#123; ListNode* pNode = *pHead; while(pNode-&gt;Next != NULL) pNode = pNode-&gt;Next; pNode-&gt;Next = pNew; &#125;&#125;在链表中找到第一个含有某值的节点并删除该节点的函数如下要点： 123456789101112131415161718192021222324252627282930void removeNode(ListNode** pHead, int value)&#123; if(pHead == NULL || *pHead == NULL) //空链表直接返回 return; ListNode* pToBeDelete = NULL; //找到需要删除的节点 if((*pHead)-&gt;Value == value) //当第一个节点是需要删除的节点，则需要改变头指针的指向 &#123; pToBeDelete = *pHead; *pHead = (*pHead)-&gt;Next; &#125; else //否则开始遍历节点 &#123; ListNode* pNode = *pHead; while(pNode-&gt;Next != NULL &amp;&amp; pNode-&gt;Next-&gt;Value != value) //遍历到最后一个节点或者找到需要删除的节点的前一个节点则停止遍历 pNode = pNode-&gt;Next; if(pNode-&gt;Next != NULL &amp;&amp; pNode-&gt;Next-&gt;Value ==value) //找到需要删除的节点的前一个节点 &#123; pToBeDelete = pNode-&gt;Next; pNode-&gt;Next = pNode-&gt;Next-&gt;Next; //这里包含了当需要删除的节点是最后一个节点的情况，若是最后一个节点则它的前一个节点会指向NULL &#125; &#125; if(pToBeDelete != NULL) &#123; delete pToBeDelete; pToBeDelete = NULL; &#125;&#125;面试题5：从尾到头打印链表面试中如果我们打算修改输入数据，最好先问面试官允不允许。若允许我们可以将链表中的节点指针反转改变链表方向就可以了。通常打印是一个只读操作，假设面试官要求这个题目不能改变链表结构。思路：遍历是从头到尾，输出却是从尾到头，这是典型的后进先出的栈结构，然后递归的本质就是栈结构，于是我们可以每访问一个节点先递归输出它后面的节点，再输出该节点自身。显示用栈调用代码如下12345678910111213141516171819//Reversingly-倒置地void printListReversingly(ListNode* pHead) //不用改变头指针，可传值&#123; std::stack&lt;ListNode*&gt; nodes; ListNode *pNode = pHead; while(pNode != NULL) &#123; node.push(pNode); //入栈 pNode = pNode-&gt;Next; &#125; while(!node.empty()) &#123; pNode = nodes.top(); //取栈顶元素 cout &lt;&lt; pNode-&gt;Value &lt;&lt; endl; //输出节点值 nodes.pop(); //弹出栈顶元素 &#125;&#125;基于递归的栈调用代码如下 12345678910//Recursively-递归地void printListReversinglyRecursively(ListNode* pHead) //不用改变头指针，可传值&#123; if(pHead != NULL) //判断是不是空链表 &#123; if(pHead-&gt;Next != NULL) printListReversinglyRecursively(pHead-&gt;Next); //判断是不是最后一个结点，若是最后一个结点则递归结束 cout &lt;&lt; pHead-&gt;Value &lt;&lt; endl; &#125; &#125;Tips:链表长时，导致函数调用层级很深，有可能导致函数调用栈移除，鲁棒性(程序稳定性)不好。2.3.4 树小知识树是一种数据结构: 除了根节点外每个节点只有一个父节点，根节点没有父节点 除了叶节点外每个节点有一个或多个子节点，叶节点没有子节点 父节点与子节点之间用指针连接 二叉树：树的特殊结构，每个节点最多有两个子节点遍历方式： 前序：根-左-右 中序：左-根-右 后序：左-右-根 宽度优先：按照层的顺序从顶到底遍历，同一层的节点按从左到右遍历 二叉搜索树：左节点小于等于根节点，右节点大于等于根节点的二叉树堆：最大堆中根节点的值最大，最小堆中根节点的值最小红黑树：把树中的节点定义为红、黑两种颜色，并通过规则确保从根节点到叶节点的最长路径的长度不超过最短路径的两倍，C++中STL中set、multiset、map、multimap等数据结构都是基于红黑树实现的 面试题6：重建二叉树思路：前序遍历可以确定树的根节点(第一个数字)，中序遍历在知道了根节点的值后可以知道左子树的结点值(根节点左边的所有值)和右子树的结点值(根节点右边的所有值)，之后用递归的方式完成剩下子树的建立12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//树的主构造函数BinaryTreeNode* Construct(int* preorder, int* inorder, int length)&#123; if(preorder == NULL || inorder == NULL || length &lt;= 0) //输入有效性检测 return NULL; return ConstructCore(preorder, preorder+length-1, inorder, inorder+length-1);&#125;//树的核心构造函数，通过传入前序遍历的头尾指针、中序遍历的头尾指针递归建树BinaryTreeNode* ConstructCore(int* startPreorder, int *endPreorder, int* startInorder, int* endInorder)&#123; //前序遍历的第一个数字是根节点的值 int rootValue = startPreorder[0]; BinaryTreeNode* root = new BinaryTreeNode(); root-&gt;m_nValue = rootValue; root-&gt;m_pLeft = root-&gt;m_pRight = NULL; if(startPreorder == endPreorder) &#123; //若是输入的树前序只有一个值、中序也只有一个值且这两个值是同一个值 //则输入的这个值就是这棵树的根节点，否则是无效输入 if(startInorder == endInorder &amp;&amp; *startPreorder == *startInorder) return root; else throw std::exception(&quot;Invalid input&quot;); &#125; //在中序遍历中找到根节点的值 int* rootInorder = startInorder; while(rootInorder &lt;= endInorder &amp;&amp; *rootInorder != rootValue) rootInorder++; //如果找到的节点在中序的末尾且值并不是根节点的值，返回错误 if(rootInorder == endInorder &amp;&amp; *rootInorder != rootValue) throw std::exception(&quot;Invalid input&quot;); //可以通过找到的节点确定左子树长度和左子树范围 int leftLength = rootInorder - startInorder; int* leftPreorderEnd = startPreorder + leftLength; if(leftLength &gt;0) &#123; //构建左子树 root-&gt;m_pLeft = ConstructCore(startPreorder+1,leftPreorderEnd,startInorder,rootInorder-1); &#125; if(leftLength &lt; endPreorder-startPreorder) &#123; //构建右子树 root-&gt;m_pRight = ConstructCore(leftPreorderEnd+1,endPreorder,rootInorder+1,endInorder); &#125; return root;&#125;让我们来看看ConstructCore做了什么事 2.3.5 栈和队列小知识栈：先进先出，即最后入栈(push)的元素会第一个被弹出(pop) 队列：先进先出，即第一个进入队列的元素会第一个出来面试题7：用两个栈实现队列思路：插入元素直接插入第一个栈即可，删除元素则若是第二个栈有元素就pop，若是第二个栈没有元素，则将第一个栈的元素全部pop并push进第一个栈，之后按照第二个栈有元素的方式pop123456789101112131415161718192021222324252627//元素入队template&lt;typename T&gt; void CQueue&lt;T&gt;::appendTail(const T&amp; element)&#123; stack1.push(element);&#125;//元素出队template&lt;typename T&gt; T CQueue&lt;T&gt;::deleteHead()&#123; if(stack2.size() &lt;= 0) //stack2空则将stack1全部弹出压如stack2 &#123; while(stack1.size() &gt; 0) &#123; T&amp; data = stack1.top(); stack1.pop(); stack2.push(data); &#125; &#125; //此时若是stack2还是空，则证明队列是空的 if(stack2.size() = 0) throw new exception(&quot;queue is empty&quot;); T head = stack2.top(); //否则弹出栈顶元素 stack2.pop(); return head;&#125;两个栈实现一个队列像是一个是插入栈一个是删除栈，而两个队列实现一个栈呢？思路如下","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://harviealwayshere.github.io/tags/数据结构/"}]},{"title":"C++基础语法","slug":"cplusplus","date":"2018-01-31T07:31:56.000Z","updated":"2018-02-07T08:09:25.136Z","comments":true,"path":"2018/01/31/cplusplus/","link":"","permalink":"https://harviealwayshere.github.io/2018/01/31/cplusplus/","excerpt":"","text":"刚想刷剑指offer和leetcode上的题目，本来享用python写的，毕竟是刷算法感觉无论是什么语言总是相通的，但看到剑指offer上写到 大一学的C++基础语法都忘记的差不多了，还是先来巩固一下C++基础语法，本文以runoob和C++ Primer(第五版)为基础编写。 Part1：C++基础语法标准的 C++ 由三个重要部分组成： 核心语言，提供了所有构件块，包括变量、数据类型和常量，等等。 C++ 标准库，提供了大量的函数，用于操作文件、字符串等。 标准模板库（STL），提供了大量的方法，用于操作数据结构等。 C++面向对象四大特点:封装、抽象、继承和多态。 C++基本程序结构：12345678#include &lt;iostream&gt; //添加头文件using namespace std; //使用std命名空间 int main() //主函数，程序执行入口&#123; cout &lt;&lt; &quot;Hello World&quot;; // 输出 Hello World return 0; //终止main函数并返回0值&#125; C++内置数据类型：类型&emsp;&emsp;&emsp;&emsp;关键字&emsp;&emsp;&emsp;&emsp;内存(字节)布尔型 &emsp;&emsp;&emsp;bool&emsp;&emsp;&emsp;&emsp;&emsp;1字符型 &emsp;&emsp;&emsp;char&emsp;&emsp;&emsp;&emsp;&emsp;1整型 &emsp;&emsp;&emsp;&emsp;int&emsp;&emsp;&emsp;&emsp;&emsp;&nbsp;&nbsp;&nbsp;4浮点型 &emsp;&emsp;&emsp;float&emsp;&emsp;&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;4双浮点型 &emsp;&emsp;double&emsp;&emsp;&emsp;&emsp;8无类型 &emsp;&emsp;&emsp;void&emsp;&emsp;&emsp;&emsp;&emsp;宽字符型 &emsp;&emsp;wchar_t&emsp;&emsp;&emsp;&nbsp;&nbsp;4一些类型可用修饰符修饰:signed,unsigned,short,long.Tip:其实知道了字节数很简单计算范围，1字节=8位，每位存储一个二进制0/1，有几位二进制则可以存储2^位数范围大小的数字。Tip:存储有符号数的时候，例如int，虽然是4字节的，但是只能是1符号位+31数值为位，所以最大为2^31=2147483647。可以使用typedef为一个已有的类型取一个新的名字:typedef type newname;12typedef int SSS;SSS a = 2; 枚举类型(enumeration)：是C++中的一种派生数据类型，它是由用户定义的若干枚举常量的集合:语法为:enum name {IDentifier0[=int 0],IDentifier1=[int 1]} Variable;12enum color &#123; red, green, blue &#125; c; //定义变量c是枚举类型colorc = blue; //c赋值为blue 变量声明和定义:您可以使用extern关键字在任何地方声明一个变量。虽然您可以在 C++ 程序中多次声明一个变量，但变量只能在某个文件、函数或代码块中被定义一次。123456789101112// 变量声明extern int a; //可进行多次int main ()&#123; // 变量定义 //仅可进行一次 int a; // 实际初始化 a = 10; return 0;&#125; 函数声明和定义:在函数声明时，提供一个函数名，而函数的实际定义则可以在任何地方进行。1234567891011121314// 函数声明int func();int main ()&#123; // 函数调用 int i = func(); return 0;&#125;// 函数定义int func()&#123; return 666;&#125; 变量作用域: 在函数或一个代码块内部声明的变量，称为局部变量。 在函数参数的定义中声明的变量，称为形式参数。 在所有函数外部声明的变量，称为全局变量。 初始化:定义全局变量时，系统会根据数据类型自动初始化；定义局部变量时，系统不会自动初始化。 C++常量:定义后不能进行修改的固定值。整数常量: 前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制 后缀指定修饰符:是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。 浮点常量：由整数部分、小数点、小数部分和指数部分组成。 小数形式：必须包含整数部分、小数部分，或同时包含两者。 指数形式：必须包含小数点、指数，或同时包含两者。带符号的指数是用 e 或 E 引入的。 布尔常量：true/false字符常量：括在单引号中的可以是一个普通的字符（例如 ‘x’）、一个转义序列（例如 ‘\\t’），或一个通用的字符（例如 ‘\\u02C0’）。 宽字符常量：以 L（仅当大写时）开头存储在 wchar_t 类型的变量中（例如 L’x’）。 窄字符常量：存储在 char 类型的简单变量中（例如 ‘x’）。 字符串常量：括在双引号 “” 中的。一个字符串包含类似于字符常量的字符：普通的字符、转义序列和通用的字符。C++有两种简单定义常量方式: 使用 #define 预处理器:#define identifier value 使用 const 关键字:const type variable = value; Tips:常量一般被定义成大写字母形式 C++ 修饰符类型修饰符 signed、unsigned、long 、short可应用于整型，signed 和 unsigned可应用于字符型，long 可应用于双精度型。修饰符 signed 和 unsigned 也可以作为 long 或 short 修饰符的前缀。例如：unsigned long int。 C++ 类型限定符用于限定类型和类型成员的声明 const：限定对象在程序执行期间不能被修改改变。 volatile：限定变量的值可能以程序未明确指定的方式被改变。(多线程使用) C++ 存储类存储类定义 C++ 程序中变量/函数的范围（可见性）和生命周期，常有auto、static、extern、mutable、thread_local (C++11)。auto关键字用于两种情况： 声明变量时根据初始化表达式自动推断该变量的类型。 声明函数时函数返回值的占位符。1234auto f=3.14;cout&lt;&lt;typeid(f).name()&lt;&lt;endl; //doubleauto z = new auto(9); cout&lt;&lt;typeid(z).name()&lt;&lt;endl; // int* static关键字指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。 static修饰局部变量：变量在全局数据区分配内存，程序执行第一次时首次初始化，以后函数调用不再进行初始化，没有显式初始化则会被自动初始化为0。 static修饰全局变量：使变量的作用域限制在声明它的文件内。 static修饰类的成员变量：类外初始化，先于类存在，类所有对象共同一个静态成员变量，可通过类名直接调用公共(public)静态成员变量。123456789101112131415class A&#123;public: A()&#123; count++; &#125; //先于类存在，在类的构造方法中已经可以调用 static int count;&#125;;int A::count = 0; //类外初始化int main()&#123; A c; A d; cout &lt;&lt; A::count &lt;&lt; endl; //共用性和直接类名调用 system(&quot;pause&quot;); return 0;&#125; static修饰类的成员方法:先于类存在，方法中不能使用非静态成员(无this指针),可通过类名直接调用公共(public)静态成员方法。12345678910111213141516171819class A&#123;public: A()&#123; count++; &#125; static int count; static void showCount() &#123; cout &lt;&lt; &quot;count is &quot; &lt;&lt; count &lt;&lt; endl; //不用this指针织带变量 &#125;&#125;;int A::count = 0; int main()&#123; A c; A d; A::showCount(); //类名直接调用 system(&quot;pause&quot;); return 0;&#125; C++ 运算符运算符是一种告诉编译器执行特定的数学或逻辑操作的符号,有算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符和其他运算符。算数运算符:+、-、、/、%(取模,整除后的余数)、++(自增)、–(自减).关系运算符:==、!=、&gt;、&lt;、&gt;=、&lt;=.逻辑运算符:&amp;&amp;(逻辑与，均非零为真)、||(逻辑或，存在非零则为真)、!(逻辑非，逆转逻辑状态).Tips:&amp;&amp;(||)具有短路功能，即若第一个条件为false(true)，则不再计算第二个表达式；&amp;(|)则无论如何均会计算两个表达式.利用这点可将A&amp;&amp;B中的A作为一个条件语句(if)不满足则不执行B，如下1234567891011121314151617/*不用任何循环语句，不用if，来实现1+2+3+...+10的值*/#include &lt;iostream&gt;using namespace std;int add(int c)&#123; int a=0; c&amp;&amp;(a=add(c-1));//递归循环，直到传入c的值为0则结束循环不执行右式 //(用&amp;则会执行造成溢出错误) cout&lt;&lt;c+a&lt;&lt;endl; return c+a;&#125;int main()&#123; add(10); return 0;&#125;位运算:若A = 60，且 B = 13，以二进制表示如下A = 0011 1100B = 0000 1101赋值运算:=、+=、-=、=、/=、%=、&lt;&lt;=、&gt;&gt;=、&amp;=(按位与或且赋值)、^=(按位异或且赋值)、|=(按位或且赋值)杂项运算: C++ 循环 while:1234while(condition)&#123; statement(s);&#125; for:1234for ( init; condition; increment )&#123; statement(s);&#125; do…while:12345do&#123; statement(s);&#125;while( condition ); 循环控制语句: break：跳出循环。 continue:跳过循环主体的剩余部分，立即重新开始测试条件。 C++ 判断 if:1234if(boolean_expression)&#123; statement(true); // 如果布尔表达式为真将执行的语句&#125; if…else:12345678if(boolean_expression)&#123; statement(true); // 如果布尔表达式为真将执行的语句&#125;else&#123; statement(false); // 如果布尔表达式为假将执行的语句&#125; switch:123456789101112switch(expression)&#123; case constant-expression : statement(s); break; // 可选的 case constant-expression : statement(s); break; // 可选的 // 您可以有任意数量的 case 语句 default : // 可选的 statement(s);&#125; [ ? : ]运算符:1Exp1 ? Exp2 : Exp3; C++ 函数函数声明包含函数的名称、返回类型和参数C++中的函数声明形式：1return_type function_name( parameter list );函数定义提供了函数的实际主体。C++中的函数定义形式：1234return_type function_name( parameter list )&#123; body of the function&#125;函数参数:函数内使用的局部变量称作形式参数，有三种调用方式 传值调用(默认)：把参数的实际值复制给形式参数。在这种情况下，修改函数内的形式参数不会影响实际参数。 指针调用：把参数的地址复制给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。修改形式参数会影响实际参数。如函数声明:void swap(int *x, int *y)函数调用:swap(&amp;a,&amp;b) 引用调用：把参数的引用赋值给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。如函数声明:void swap(int &amp;x, int &amp;y)函数调用:swap(a,b) 参数默认值:定义函数时可以为参数列表中每一个参数指定默认值,如int sum(int a=10,int b=20)Lambda 函数与表达式:Lambda 表达式把函数看作对象。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。 C++ 数字数学运算:引用数学头文件 内有许多内置数学函数随机数:标准库（被包含于中）提供两个帮助生成伪随机数的函数 void srand(unsigned seed)：设置随机数种子，通常用time()初始化(使用time需要引入头文件)，如srand( (unsigned)time( NULL ) ); int rand(void)：从srand (seed)中指定的seed开始，返回一个[seed, RAND_MAX（0x7fff）)间的随机整数。 指定生成范围的随机数1234(low,up) (rand()%(up-low+1)) + low - 1[low,up) (rand()%(up-low)) + low(low,up] (rand()%(up-low))+ low + 1[low,up] (rand()%(up-low+1)) + low C++ 数组声明数组:type arrayName [ arraySize ];初始化数组:type arrayName [ arraySize ] = { data } ;访问数组元素:数组名称+索引，arrayName[index];数组详解: 多维数组:type arrayName[size1][size2]…[sizeN]; 数组指针:声明的数组名其实是指向数组第一个元素的指针，即*arrayName == &amp;arrayName[0]所以也可以使用指针形式访问数组*(arrayName + i ) == arrayName[i] 传递数组给函数:是以指针的形式传递的，因此有三种传递方式：(type *param)(type param[size])(type param[]) 函数返回数组:数组以指针的形式返回的，另外C++不支持在函数外返回局部变量的地址，因此返回的数组需要均是static变量 C++ 字符串 C风格字符串:实质是一个以’\\0’(null)结尾的char数组，例如123//以下msg1和msg2初始化规则相同char msg1[6] = &#123;&apos;H&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, &apos;o&apos;, &apos;\\0&apos;&#125;;char msg2[] = &quot;Hello&quot;; C++有大量函数操作以null结尾的字符串： C++引入的 string 类类型:C++标准库提供了string类型(需引入#include &lt; string >库)且支持上述函数操作1234string str1 = &quot;Hello&quot;;string str2 = str1; //复制string str3 = str1 + str2; //连接int length = str3.size(); //长度 C++ 指针 内存地址:每个C++变量都有一个内存地址，可用寻址（&amp;）运算符访问变量的内存地址 指针:是一个特殊的变量，其值为另一个变量的内存地址，声明形式为:type *var-name; 使用指针:过程一般为声明、存储、访问（对指针使用间址(*)运算符可访问指针存储地址的变量值）12345678string str = &quot;Hello&quot;;string *ip;ip = &amp;str;cout &lt;&lt; &quot;Address of str : &quot; &lt;&lt; &amp;str &lt;&lt; endl;cout &lt;&lt; &quot;Value of str : &quot; &lt;&lt; str &lt;&lt; endl;cout &lt;&lt; &quot;Stored Address of ip : &quot; &lt;&lt; ip &lt;&lt; endl; //指针存储的变量的地址cout &lt;&lt; &quot;Address of ip : &quot; &lt;&lt; &amp;ip &lt;&lt; endl; //指针本身的地址cout &lt;&lt; &quot;Value of ip : &quot; &lt;&lt; *ip &lt;&lt; endl; 执行结果如下: Null指针:指针初始化时指定NULL值被称作空指针可以避免越界使用指针1type *ptr = NULL; 指针的算数运算:指针是一个用数值表示的地址，可以执行四种算数运算（++，–，+，-）具体运算数值与指针的类型有关(如整形指针一次递增4个字节，字符指针一次递增1个字节等) 指针与数组的异同:（同）均可通过指针的算数运算和数组索引来访问数组（异）声明数组的数组名的指针是一个指向数组第一个元素地址的常量指针，不可改变指向的地址 指针数组:可声明一个数组来存放指针，其中每个数组元素都是一个指针，如type *ptr[size]; 多级指针:一个指针指向另一个指针的地址123type var;type *ptr1 = &amp;var;type *ptr2 = &amp;ptr1; //ptr2就是一个多级指针指向一级指针ptr1 指针参数:声明函数参数为指针类型即可，这种属于指针调用函数参数，将参数地址复制给函数的形式参数，在函数内修改形式参数会影响实际参数。 函数返回指针类型:声明函数返回类型为指针类型即可，但由于C++不支持在函数外返回局部变量的地址，因此可返回指针类型的变量需要声明为static变量。 C++ 引用引用变量是一个实际变量的别名。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。 引用于指针的区别:1.引用必须在创建时初始化，指针可以在任何时间初始化。2.引出初始化为一个对象后不能更改，指针可以在任何时候指向另一个对象。3.不存在空引用，引用必须连接到一个合法内存。 引用创建初始化使用:type&amp; name = variable; 引用参数:声明函数参数为引用类型即可，属于引用调用的函数参数。这比传一般参数安全。 函数返回引用类型:声明函数返回类型为引用类型，但是实际上函数返回一个引用时是返回一个指向返回值的隐式指针，这样函数可以放在赋值语句的左边。返回引用最大的好处是在内存中不产生被返回值的副本，节省内存，但是不能返回局部变量的引用。 C++ 日期和时间C++继承了C语言用于日期和时间操作的结构和函数,需要引入 &lt; ctime > 头文件 有四个与时间有关的类型，其中clock_t、time_t、size_t 将系统时间和日期表示为某种整数，tm结构类型将日期和时间以C结构形式保存。 C/C++中关于日期和时间的重要函数:1.time(): 返回从 1970-01-01 到 当前的日历时间的秒数123//函数原型:time_t time(time_t *t)time_t nowSeconds = time(NULL);cout &lt;&lt; nowSeconds &lt;&lt; endl; 2.ctime():返回一个格式为[Www Mmm dd hh:mm:ss yyyy]基于参数timer的时间的字符串1234//函数原型:char *ctime(const time_t *timer)#pragma warning(disable:4996) //接触安全警报限制time_t curtime = time(NULL);cout &lt;&lt; ctime(&amp;curtime) &lt;&lt; endl; 3.localtime(): struct tm *localtime(const time_t *timer)，将参数timer的值分解为tm结构，并用本地时区表示12345678910//函数原型:struct tm *localtime(const time_t *timer)#pragma warning(disable:4996) //接触安全警报限制time_t curtime = time(NULL);struct tm *info = localtime(&amp;curtime);cout &lt;&lt; &quot;tm_sec:&quot; &lt;&lt; info-&gt;tm_sec &lt;&lt; endl;cout &lt;&lt; &quot;tm_min:&quot; &lt;&lt; info-&gt;tm_min &lt;&lt; endl;cout &lt;&lt; &quot;tm_hour:&quot; &lt;&lt; info-&gt;tm_hour &lt;&lt; endl;cout &lt;&lt; &quot;tm_mday:&quot; &lt;&lt; info-&gt;tm_mday &lt;&lt; endl;cout &lt;&lt; &quot;tm_mon:&quot; &lt;&lt; info-&gt;tm_mon &lt;&lt; endl;cout &lt;&lt; &quot;tm_year:&quot; &lt;&lt; info-&gt;tm_year &lt;&lt; endl; 4.clock(): 返回程序执行起处理器时钟所使用的时间，为了获取CPU所使用秒数需要除以CLOCKS_PER_SEC常量12345678910111213//函数原型:clock_t clock(void)#pragma warning(disable:4996) //接触安全警报限制clock_t start_t, end_t;start_t = clock();cout &lt;&lt; &quot;程序启动：&quot; &lt;&lt; start_t &lt;&lt; endl;for(int i=0; i&lt; 10000000; i++)&#123;&#125;end_t = clock();cout &lt;&lt; &quot;程序结束：&quot; &lt;&lt; end_t &lt;&lt; endl;double total_t;total_t = (double)(end_t - start_t) / CLOCKS_PER_SEC;cout &lt;&lt; &quot;CPU占用时间:&quot; &lt;&lt; total_t &lt;&lt; endl; 5.asctime()：返回一个基于timeptr的时期和时间的字符串的指针12345//函数原型:char *asctime(const struct tm *timeptr)#pragma warning(disable:4996) //接触安全警报限制time_t curtime = time(NULL);struct tm *info = localtime(&amp;curtime);cout &lt;&lt; asctime(info) &lt;&lt; endl; 6.gmtime():使用timer来填充tm的结构，并协调世界时(UTC)也被称作格林尼治标准时间(GMT)表示12345//函数原型:struct tm *gmtime(const time_t *timer)#pragma warning(disable:4996) //接触安全警报限制time_t curtime = time(NULL);struct tm *info = gmtime(&amp;curtime);cout &lt;&lt; asctime(info) &lt;&lt; endl; 7.mktime():将tm结构的timer转换成一个依据本地时区的time_t值123456//函数原型:time_t mktime(struct tm *timeptr)#pragma warning(disable:4996) //接触安全警报限制time_t curtime = time(NULL);struct tm *info = localtime(&amp;curtime);time_t localtime = mktime(info); cout &lt;&lt; ctime(&amp;localtime) &lt;&lt; endl; 8.difftime(): 返回time1和time2之间的相差秒数1234567891011// double difftime(time_t time1, time_t time2)#pragma warning(disable:4996) //接触安全警报限制#include &lt;windows.h&gt; //sleep函数time_t start_t, end_t;time(&amp;start_t);cout &lt;&lt; &quot;程序启动：&quot; &lt;&lt; start_t &lt;&lt; endl;Sleep(5632);time(&amp;end_t);cout &lt;&lt; &quot;程序结束：&quot; &lt;&lt; end_t &lt;&lt; endl;double diff_t = difftime(end_t, start_t); //以秒为单位精度是double我也不太清楚为什么....cout &lt;&lt; &quot;程序占用时间:&quot; &lt;&lt; diff_t &lt;&lt; endl; 9.strftime(): size_t strftime(char *str, size_t maxsize, const char *format, const struct tm *timeptr)，根据format中定义的格式化规则，格式化数据结构timeptr表示的时间，并把它存储在str中12345time_t now = time(NULL);struct tm *info = localtime(&amp;now);char buffer[80];strftime(buffer, 80, &quot;%x - %I:%M%p&quot;, info);cout &lt;&lt; &quot;格式化时间：&quot; &lt;&lt; buffer &lt;&lt; endl; C++ 基本输入输出 C++的I/O 发生在流中，流是字节序列。输入操作：字节流是从设备（如键盘、磁盘驱动器、网络连接等）流向内存。输出操作：字节流是从内存流向设备（如显示屏、打印机、磁盘驱动器、网络连接等）。 I/O 库头文件：1.标准输出流(cout):是ostream类的实例，与运算符&lt;&lt;将对象连接到标准输出设备2.标准输入流(cin):是istream类的实例，与运算符&gt;&gt;将对象连接到标准输入设备3.标准错误流(cerr):是ostream类的实例，是非缓冲的，每个流插入cerr会立即输出4.标准日志流(clog):是ostream类的实例，是缓冲的，每个流插入clog会先存储到缓冲区直到其填满或者刷新时才会输出 C++ 结构用户自定义的数据类型，允许存储不同类型的数据项，格式如下1234567struct type_name &#123;member_type1 member_name1;member_type2 member_name2;member_type3 member_name3;..&#125; object_names; 访问结构成员:使用成员访问运算符(.)，如1object_names.member_name 访问指向结构的指针:可定以指向结构的指针，则使用指针访问运算符(-&gt;)，如12struct type_name *struct_ptr = &amp;object_names;struct_pointer-&gt;title","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://harviealwayshere.github.io/tags/C/"}]},{"title":"粤语歌单","slug":"musicYueYu","date":"2018-01-30T08:34:19.000Z","updated":"2018-01-31T09:45:01.985Z","comments":true,"path":"2018/01/30/musicYueYu/","link":"","permalink":"https://harviealwayshere.github.io/2018/01/30/musicYueYu/","excerpt":"","text":"今天推荐的歌单是粤语抒情相关的，怎么说呢，感觉粤语歌与普通话的歌听觉上有所不同，粤语歌的咬文嚼字可能并不需要那么清晰，但是情感却十分饱满浓郁。第一位着重推荐的是我喜欢的比较冷门的粤语歌手侧田，听他的歌总是能感受的到他的力量、他的硬朗，能身临其境地走入他的内心感受他歌唱时的情感，听他的歌总能汲取歌中的能量，让听众奋发向上。 第二位推荐的是杨千嬅，她总是吟唱悲伤无助的歌曲，高亮干净的嗓音让她的歌总是令人心生怜意，比较适合一个人、悲伤的时候听，也许她的歌可以让你明白，悲剧才是最感动的。 第三位推荐的是谢安琪，”男不听七友，女不听钟无艳”相比很多人都听过，都是伤感情歌，谢安琪更是把以好友身份苦恋无果、甘做备胎的状态演唱的淋漓尽致。由于版权原因，请移步钟无艳 试听。","categories":[{"name":"Music","slug":"Music","permalink":"https://harviealwayshere.github.io/categories/Music/"}],"tags":[{"name":"粤语","slug":"粤语","permalink":"https://harviealwayshere.github.io/tags/粤语/"},{"name":"music","slug":"music","permalink":"https://harviealwayshere.github.io/tags/music/"}]},{"title":"使用Hexo和Markdown写作","slug":"hexoWrite","date":"2018-01-27T10:03:33.000Z","updated":"2018-01-30T08:30:23.412Z","comments":true,"path":"2018/01/27/hexoWrite/","link":"","permalink":"https://harviealwayshere.github.io/2018/01/27/hexoWrite/","excerpt":"","text":"终于开始激动人心的写博客环节了，但是在hexo上写博客跟word上写博客可不太一样。 Hexo特性：hexo可以用命令行创建文章，hexo可以自定义写作布局layout，hexo的资源文件的引用 Markdown语法：hexo生成的文章都是.md格式，需要使用特殊的编辑器来进行写作，还有特殊的markdown写作语法 资源的引用：使用外链（图床）和本地引用方法 严格规范markdown语法看来写博客也是一件不省心的事情，就让我们按部就班一步步来看看各个环节的特性吧。 1.Hexo特性建议参考官方文档&emsp; &emsp;&emsp;&emsp;&emsp;1.1 修改layout布局：&emsp;&emsp;&emsp;&emsp;打开博客文件夹根目录下的[scaffolds]中的[post.md]文件，可以看到初始只有title/date/tags三种文件变量称作Front-matter,可以添加updated/categories等基本变量如下&emsp;&emsp;&emsp;&emsp;Tips:并列的tips需要使用- (-和空格)否则会编译出错 &emsp;&emsp;&emsp;&emsp;1.2 创建文章语法：1$ hexo new [layout] &lt;title&gt; &emsp;&emsp;&emsp;&emsp;1.3 Hexo自带语法：&emsp;&emsp;&emsp;&emsp;Hexo也有一些用于写作的不同于md的基本语法称作标签插件(Tag Plugins)比如引用块真是不知命运所馈赠的礼物，早已在暗中标明了价格。 茨威格断头王后比如代码块1alert(&apos;Hello World!&apos;); 2.Markdown语法&emsp;&emsp;&emsp;&emsp;Markdown语法很多很细致但是很简单，网上有很多文章介绍，这里我就推荐一个写的很好的博主文章供大家学习，相信很多人都是看这篇文章入门的，我就不露丑介绍了。 3.资源引用&emsp;&emsp;&emsp;&emsp;相信很多人在写博文为了增强用户体验都会插入一些图片表达，md中都是依靠链接来插入图片的，唯一不同的是这个链接是本地链接还是外部链接呢，本地链接无风险但是插入的图片会占据github空间而且不灵活不好分享毕竟我们写的博文都是需要部署到github上的，外部链接节省github空间但是万一失效了图片就显示不出来了俗称图片挂了，我个人原则是 小图片用本地链接大图片可以尝试外部链接，重要图片用本地链接稍微不那么关键的图片用外部链接。 &emsp;&emsp;&emsp;&emsp;3.1 本地链接的使用：&emsp;&emsp;&emsp;&emsp;本地链接的使用其实很简单，但是由于图片在本地路径和在生成($ hexo g)文件的路径并不相同，所以我的做法是首先将图片放在跟博文文件一个目录下，在本地预览完成需要部署的时候，再将图片剪切到[博客根目录/source/images/]文件夹里面同时要修改博文中对于图片的引用变成(/images/picture.png)因为编译后图片放在网站根目录的images中。 &emsp;&emsp;&emsp;&emsp;3.2 外部链接的使用：&emsp;&emsp;&emsp;&emsp;外部链接的使用其实就是利用一些网站服务器的空间来存储你的图片俗称图床，在博文中直接使用直接路径调用图片，如类似这种链接https://i.loli.net/2018/01/25/5a69a60eeda77.gif&emsp;&emsp;&emsp;&emsp;图床有许多，有免费的也有收费的，有些有浏览流量的限制，收费的我推荐七牛云,免费的我推荐SM.MS,用到现在还没有出现挂图的迹象。&emsp;&emsp;&emsp;&emsp;Tips：其实图床蛮多托的，有人建议直接放在github仓库上用绝对连接访问就好。 在repository的根目录下建立文件夹，然后将图片放在其中，在写链接的时候直接使用自己的GitHub Pages根路径加图片地址访问即可。 4.严格规范markdown语法&emsp;&emsp;&emsp;&emsp;Markdown语法看似简单，其实有许多坑需要踩。比如最简单的用[###]表示字体大小，也许在markdown编辑器上可以直接使用[###你好]表示，但是生成页面的时候却显示不出来，这是因为[#]的严格语法是[#+空格+内容]，缺少一个空格将会造成无法编译。还有一些小技巧，比如想打出空格,换行，底色等，最好还是用字符或者Html语法的形式，如下1234567&amp;emsp; //空格&lt;br&gt; //换行&lt;font face=&quot;微软雅黑&quot;&gt;&lt;/font&gt; //字号&lt;font color=red&gt;&lt;/font&gt; //字体颜色&lt;font color=#0099ff size=7&gt;&lt;/font&gt; //字体[1-7]&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=orange&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; //背景色--- //分割线 相信你已经初步了解怎么使用hexo和markdown语法写作了，你肯定迫不及待地想写下自己第一篇博文打了吧，去吧！","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://harviealwayshere.github.io/tags/Hexo/"},{"name":"GithubPages","slug":"GithubPages","permalink":"https://harviealwayshere.github.io/tags/GithubPages/"}]},{"title":"大三上寒假计划","slug":"planOfHoliday","date":"2018-01-27T09:13:41.000Z","updated":"2018-01-30T08:30:21.686Z","comments":true,"path":"2018/01/27/planOfHoliday/","link":"","permalink":"https://harviealwayshere.github.io/2018/01/27/planOfHoliday/","excerpt":"","text":"我的寒假学习计划同时也是博客的更新计划，大致有以下几个方面： 算法：LeetCode、牛客网、剑指Offer的题目解法总结 专业相关：机器学习的实践相关内容总结 实战：Laravel框架的学习和一个网页功能开发实战的更新总结 python：python相关的库使用，如爬虫、机器学习、可视化、游戏等 影评：休闲之时也会写一些影评推荐一些精品电影给大家（资源也会放出来） 每部分的更新频率不一定，但是会尽量面面俱到、频繁更新的，敬请期待哦！","categories":[{"name":"Life","slug":"Life","permalink":"https://harviealwayshere.github.io/categories/Life/"}],"tags":[{"name":"Plan","slug":"Plan","permalink":"https://harviealwayshere.github.io/tags/Plan/"}]},{"title":"使用github pages和hexo搭建个人博客","slug":"gitPagesAndHexo","date":"2018-01-14T12:51:14.000Z","updated":"2018-01-30T08:30:24.530Z","comments":true,"path":"2018/01/14/gitPagesAndHexo/","link":"","permalink":"https://harviealwayshere.github.io/2018/01/14/gitPagesAndHexo/","excerpt":"","text":"大致步骤可以分为6步 下载安装Node.js（可以使用npm下载和管理包） 申请github账户（用于注册github pages仓库） 下载git（最好是bash 便于使用命令行操作系统） 安装hexo并配置基本参数 安装hexo主题并配置基本参数 博客部署到github pages上线 1. 下载安装Node.js（可以使用npm下载和管理包）1.1访问Node.js中文官网下载安装包:根据你的操作系统和系统类型（位数）选择下载哪一个安装包Tips：32位安装包兼容64位操作系统，64位安装包不兼容32位操作系统&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;建议使用.msi格式一键安装&nbsp;&nbsp;1.2安装Node.js:&emsp;&emsp;&emsp;&emsp;.zip文件：运行node.exe文件会跳出命令行安装&emsp;&emsp;&emsp;&emsp;.msi文件:根据提示步骤安装（安装路径最好是全英文）1.3测试是否安装成功:&emsp;&emsp;&emsp;&emsp;1.3.1 打开命令提示符:&emsp;&emsp;&emsp;&emsp;windows系统下用+R）打开运行窗口输入cmd打开命令提示符&emsp;&emsp;&emsp;&emsp;1.3.2： 输入命令 node -v 和npm -v 查看node.js和npm是否安装成功：&emsp;&emsp;&emsp;&emsp; &emsp;&emsp;&emsp;&emsp; 若有版本号（不一定与我的相同）则安装成功 否则安装失败则重新安装即可 2. 申请github账户（用于注册github pages仓库）&emsp;&emsp;&emsp;&emsp;2.1 访问github官网注册账号&emsp;&emsp;&emsp;&emsp;2.3 申请一个仓库:&emsp;&emsp;&emsp;&emsp;登录你的github账号点击上方的New repository 如下图所示&emsp;&emsp;&emsp;&emsp;在Repository name上填写 [你注册的github名称.github.io] 即可&emsp;&emsp;&emsp;&emsp;如我注册的github名称是xxx则我的Repository name为 [xxx.github.io]&emsp;&emsp;&emsp;&emsp;其他的都不用填写 之后点击[Create repository]即可 3. 下载安装git（最好是bash 便于使用命令行操作系统） Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 此部分内容建议参考廖雪峰老师的git安装文档&emsp;&emsp;&emsp;&emsp;3.1 通俗来说git就是一个软件类似于cmd命令行，但是它可以使用git命令和linux命令来操控系统，这是cmd所做不到的。在此项目中，我们主要使用它来编写npm命令、hexo命令、git命令来生成和部署自己的博客到github pages上&emsp;&emsp;&emsp;&emsp;访问git下载页面下载对应系统的git &emsp;&emsp;&emsp;&emsp;安装完毕之后打开gitbash即可使用&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;首次使用git的用户还需配置自己的用户名和地址用于验证身份：12$ git config --global user.name &quot;Your Name&quot; $ git config --global user.email &quot;email@example.com&quot; &emsp;&emsp;&emsp;&emsp;3.2 将计算机的ssh key设置到你的github账号上，你才能将本地的文件上传到你的github上面&emsp;&emsp;&emsp;&emsp;具体操作可参考廖雪峰老师的ssh key设置教程 4. 全局安装hexo建立自己的博客并配置基本参数此部分内容建议参考hexo官方文档&emsp;&emsp;&emsp;&emsp; 4.1 全局安装hexo：&emsp;&emsp;&emsp;&emsp;访问hexo官方网站查看安装命令，运行Git Bash输入安装命令npm install hexo-cli -g&emsp;&emsp;&emsp;&emsp; 4.2 建立自己的博客：在Git Bash中输入123$ hexo init [你的博客文件夹名称] $ cd [你的博客文件夹名称] $ npm install&emsp;&emsp;&emsp;&emsp;我这里演示的文件夹名称是[testBlog]&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Tips:输入pwd可查看当前文件夹的路径&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&nbsp;输入explorer .可打开命令行当前文件夹&emsp;&emsp;&emsp;&emsp;如果看到以下内容，那么恭喜你hexo建站成功了&emsp;&emsp;&emsp;&emsp; &emsp;&emsp;&emsp;&emsp; 4.3 配置基本参数博客本地预览&emsp;&emsp;&emsp;&emsp;您可以在 _config.yml 文件中修改大部份的配置具体参数意义可参考官方文档&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;输入以下命令可在本地预览你生成的博客网址123$ npm install hexo-server --save $ hexo generate$ hexo server &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;你可以像我一样用[$ hexo g]和[$ hexo s]来简化命令&emsp;&emsp;&emsp;&emsp;[$ npm install hexo-server –save]用来安装hexo本地预览的服务器 只用第一次执行一次就可以了&emsp;&emsp;&emsp;&emsp;以后每次改动就只用[$ hexo g]生成文件和[$ hexo s]启动服务器就可以了&emsp;&emsp;&emsp;&emsp;之后在浏览器输入[http://localhost:4000]就可以查看你的博客页面了&emsp;&emsp;&emsp;&emsp; 5. 安装hexo主题并配置基本参数&emsp;&emsp;&emsp;&emsp;到目前为止，是不是觉得hexo默认的主题不符合你的心意，没关系，hexo爱好者们提供了上千个主题供你挑选使用，安装主题的方法也十分简单，让我们一起来让博客的面目焕然一新吧&emsp;&emsp;&emsp;&emsp;5.1 挑选你喜爱的主题下载&emsp;&emsp;&emsp;&emsp;可以参考官方主题推荐文档或者github大神整理来寻找自己喜欢的主题并按照对应主题的文档说明下载使用&emsp;&emsp;&emsp;&emsp;如我的博客采用的主题是Huemen下载就十分简单，按照官方文档按部就班即可&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;5.2 配置主题的基本参数：&emsp;&emsp;&emsp;&emsp;主题的配置是类似于hexo配置，修改主题文件下中的[_config.yml]文件即可具体每个参数的意义请参考主题的说明文档&emsp;&emsp;&emsp;&emsp;5.3 配置成功之后可运行命令预览自己的博客了（在博客根目录下运行命令）123$ hexo clean $ hexo g $ hexo s 6. 博客部署到github pages上线&emsp;&emsp;&emsp;&emsp;6.1 安装git pages部署器：在博客根目录下打开git bash运行[$ npm install hexo-deployer-git –save]命令&emsp;&emsp;&emsp;&emsp;6.2 修改博客根目录下的配置文件[_config.yml]中的deploy参数：123deploy: type: git repo: [你注册的github pages的仓库地址] &emsp;&emsp;&emsp;&emsp;6.3 部署至github上：12$hexo generate $hexo deploy &emsp;&emsp;&emsp;&emsp;或者1$hexo d -g&emsp;&emsp;&emsp;&emsp;成功之后你可以在线访问你的github pages地址[你的github仓库名.github.io]来查看你的博客了 恭喜你，你的博客已经搭建成功并上线了! 之后我会再写一篇文章介绍hexo写作的基本方法、使用markdown格式写作、图床的使用技巧等博文写作知识，敬请期待。","categories":[{"name":"ItEassy","slug":"ItEassy","permalink":"https://harviealwayshere.github.io/categories/ItEassy/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://harviealwayshere.github.io/tags/Hexo/"},{"name":"GithubPages","slug":"GithubPages","permalink":"https://harviealwayshere.github.io/tags/GithubPages/"}]}]}