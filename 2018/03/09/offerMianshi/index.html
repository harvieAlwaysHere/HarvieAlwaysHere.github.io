<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    
    <title>剑指Offer面试题集 | Harvie Blog</title>
    
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
        <meta name="keywords" content="算法,数据结构,剑指Offer" />
    
    <meta name="description" content="本文记录剑指Offer中的50道面试题及一些个人个人拓展大纲 面试题 1：赋值运算符函数 面试题 2：实现Singleton（单例）模式 面试题 3：二维数组中的查找 面试题 4：替换空格 面试题 5：从尾到头打印链表 面试题 6：重建二叉树 面试题 7：用两个栈实现队列 面试题 8：旋转数组的最小数字 面试题 9：斐波那契数列 面试题 10：二进制中1的个数 面试题 11：数值的整数次方 面试">
<meta name="keywords" content="算法,数据结构,剑指Offer">
<meta property="og:type" content="article">
<meta property="og:title" content="剑指Offer面试题集">
<meta property="og:url" content="https://harviealwayshere.github.io/2018/03/09/offerMianshi/index.html">
<meta property="og:site_name" content="Harvie Blog">
<meta property="og:description" content="本文记录剑指Offer中的50道面试题及一些个人个人拓展大纲 面试题 1：赋值运算符函数 面试题 2：实现Singleton（单例）模式 面试题 3：二维数组中的查找 面试题 4：替换空格 面试题 5：从尾到头打印链表 面试题 6：重建二叉树 面试题 7：用两个栈实现队列 面试题 8：旋转数组的最小数字 面试题 9：斐波那契数列 面试题 10：二进制中1的个数 面试题 11：数值的整数次方 面试">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://harviealwayshere.github.io/images/offer.png">
<meta property="og:updated_time" content="2018-03-22T08:37:29.278Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="剑指Offer面试题集">
<meta name="twitter:description" content="本文记录剑指Offer中的50道面试题及一些个人个人拓展大纲 面试题 1：赋值运算符函数 面试题 2：实现Singleton（单例）模式 面试题 3：二维数组中的查找 面试题 4：替换空格 面试题 5：从尾到头打印链表 面试题 6：重建二叉树 面试题 7：用两个栈实现队列 面试题 8：旋转数组的最小数字 面试题 9：斐波那契数列 面试题 10：二进制中1的个数 面试题 11：数值的整数次方 面试">
<meta name="twitter:image" content="https://harviealwayshere.github.io/images/offer.png">
    

    

    
        <link rel="icon" href="/css/images/favicon.png" />
    

    <link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/libs/titillium-web/styles.css">
    <link rel="stylesheet" href="/libs/source-code-pro/styles.css">

    <link rel="stylesheet" href="/css/style.css">

    <script src="/libs/jquery/2.0.3/jquery.min.js"></script>
    
    
        <link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">
    
    
        <link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">
    
    
    
        <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?7e541fcb9e4a4f1848c6b2345451b88d";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>

    


</head>

<body>
    <div id="wrap">
        <header id="header">
    <div id="header-outer" class="outer">
        <div class="container">
            <div class="container-inner">
                <div id="header-title">
                    <h1 class="logo-wrap">
                        <a href="/" class="logo"></a>
                    </h1>
                    
                        <h2 class="subtitle-wrap">
                            <p class="subtitle">Fright For Better Day</p>
                        </h2>
                    
                </div>
                <div id="header-inner" class="nav-container">
                    <a id="main-nav-toggle" class="nav-icon fa fa-bars"></a>
                    <div class="nav-container-inner">
                        <ul id="main-nav">
                            
                                <li class="main-nav-list-item" >
                                    <a class="main-nav-list-link" href="/">主页</a>
                                </li>
                            
                                <li class="main-nav-list-item" >
                                    <a class="main-nav-list-link" href="/categories/ItEassy">IT文章</a>
                                </li>
                            
                                <li class="main-nav-list-item" >
                                    <a class="main-nav-list-link" href="/categories/Life">生活</a>
                                </li>
                            
                                <li class="main-nav-list-item" >
                                    <a class="main-nav-list-link" href="/categories/Music">音乐歌单</a>
                                </li>
                            
                                <li class="main-nav-list-item" >
                                    <a class="main-nav-list-link" href="https://github.com/harvieAlwaysHere">GitHub</a>
                                </li>
                            
                                <li class="main-nav-list-item" >
                                    <a class="main-nav-list-link" href="/about/index.html">关于</a>
                                </li>
                            
                        </ul>
                        <nav id="sub-nav">
                            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="想要查找什么..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
                        </nav>
                    </div>
                </div>
            </div>
        </div>
    </div>
</header>
        <div class="container">
            <div class="main-body container-inner">
                <div class="main-body-inner">
                    <section id="main">
                        <div class="main-body-header">
    <h1 class="header">
    
    <a class="page-title-link" href="/categories/ItEassy/">ItEassy</a>
    </h1>
</div>
                        <div class="main-body-content">
                            <article id="post-offerMianshi" class="article article-single article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
            <header class="article-header">
                
    
        <h1 class="article-title" itemprop="name">
        剑指Offer面试题集
        </h1>
    

            </header>
        
        
            <div class="article-meta">
                
    <div class="article-date">
        <a href="/2018/03/09/offerMianshi/" class="article-date">
            <time datetime="2018-03-09T03:21:35.000Z" itemprop="datePublished">2018-03-09</time>
        </a>
    </div>

                
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/剑指Offer/">剑指Offer</a>, <a class="tag-link" href="/tags/数据结构/">数据结构</a>, <a class="tag-link" href="/tags/算法/">算法</a>
    </div>

            </div>
        
        
        <div class="article-entry" itemprop="articleBody">
            <p><img src="/images/offer.png" alt=""></p>
<h3 id="本文记录剑指Offer中的50道面试题及一些个人个人拓展"><a href="#本文记录剑指Offer中的50道面试题及一些个人个人拓展" class="headerlink" title="本文记录剑指Offer中的50道面试题及一些个人个人拓展"></a>本文记录剑指Offer中的50道面试题及一些个人个人拓展</h3><h3 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h3><ul>
<li>面试题 1：<a href="#a01">赋值运算符函数</a></li>
<li>面试题 2：<a href="#a02">实现Singleton（单例）模式</a></li>
<li>面试题 3：<a href="#a03">二维数组中的查找</a></li>
<li>面试题 4：<a href="#a04">替换空格</a></li>
<li>面试题 5：<a href="#a05">从尾到头打印链表</a></li>
<li>面试题 6：<a href="#a06">重建二叉树</a></li>
<li>面试题 7：<a href="#a07">用两个栈实现队列</a></li>
<li>面试题 8：<a href="#a08">旋转数组的最小数字</a></li>
<li>面试题 9：<a href="#a09">斐波那契数列</a></li>
<li>面试题 10：<a href="#a10">二进制中1的个数</a></li>
<li>面试题 11：<a href="#a11">数值的整数次方</a></li>
<li>面试题 12：<a href="#a12">打印1到最大的n位数</a></li>
<li>面试题 13：<a href="#a13">在O(1)时间删除链表结点</a></li>
<li>面试题 14：<a href="#a14">调整数组顺序使奇数位于偶数前面</a></li>
<li>面试题 15：<a href="#a15">链表中倒数第K个结点</a></li>
<li>面试题 16：<a href="#a16">反转链表</a></li>
<li>面试题 17：<a href="#a17">合并两个排序的链表</a></li>
</ul>
<hr>
<p></p><p id="a01"></p><p></p>
<h3 id="面试题-1：赋值运算符函数"><a href="#面试题-1：赋值运算符函数" class="headerlink" title="面试题 1：赋值运算符函数"></a>面试题 1：赋值运算符函数</h3><p><img src="/images/mianshi1.png" alt=""><br><img src="/images/mianshi1+.png" alt=""><br>赋值运算符函数基础4要数:<br>1.返回值类型声明为该类型的引用并在函数结束前返回实例自身引用：只有这样才能实现连续赋值运算<br>2.参数类型声明为常量引用:常量是因为在函数体内不改变传入实参状态，引用是可以减少一次从形参到实参的复制构造函数的调用，节省空间开销提高代码效率<br>3.释放实例自身已有内存:在分配新内存之前释放已有空间，避免内存泄露<br>4.需要判断传入参数和当前实例(*this)是不是同一个实例:若是同一个则不进行赋值直接返回，若没有判断则在释放实例自身内存时传入的参数的内存也被释放了，就再也找不到需要赋值的内容了<br>结合以上4点的解法<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CMyString&amp; CMyString::<span class="keyword">operator</span> =(<span class="keyword">const</span> CMyString &amp;str)  <span class="comment">//返回值+参数(1.2.)</span></span><br><span class="line">&#123;</span><br><span class="line"> 	<span class="keyword">if</span>(<span class="keyword">this</span> == $str) <span class="keyword">return</span> *<span class="keyword">this</span>;		<span class="comment">//判断是否是自身赋值自身(4.)</span></span><br><span class="line">	</span><br><span class="line"> 	<span class="keyword">delete</span> []m_pData;		<span class="comment">//被赋值的实例的成员变量delete释放内存(3.)</span></span><br><span class="line"> 	m_pData = <span class="literal">NULL</span>;			<span class="comment">//初始化变量</span></span><br><span class="line"> 	m_pData = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str.m_pData)+<span class="number">1</span>];	<span class="comment">//new分配内存</span></span><br><span class="line"> 	<span class="built_in">strcpy</span>(m_pData,str.m_pData);		<span class="comment">//赋值</span></span><br><span class="line">	</span><br><span class="line"> 	<span class="keyword">return</span> *<span class="keyword">this</span>;			<span class="comment">//返回自身实例用于连续赋值运算(1.)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>考虑<strong>异常安全性</strong>:若new char时内存不足导致抛出异常，m_pData将是空指针，程序十分容易崩溃，此时由于被赋值的实例的成员变量已经被delete了，实例改变了自身的状态，违背了异常安全原则。<br>解决方案:<br>1.先new分配内存再delete释放内存，当new失败时我们能确保实例不会被修改原先状态<br>2.先创建一个临时实例，再交换临时实例和原来的实例，如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CMyString&amp; CMyString::<span class="keyword">operator</span> =(<span class="keyword">const</span> CMyString &amp;str)  </span><br><span class="line">&#123;</span><br><span class="line"> 	<span class="keyword">if</span>(<span class="keyword">this</span> != $str)</span><br><span class="line"> 	&#123;</span><br><span class="line"> 		CMyString strTemp(str);        <span class="comment">//调用复制构造函数新创建一个临时实例</span></span><br><span class="line"> 	  	<span class="keyword">char</span>* pTemp = strTemp.m_pData; <span class="comment">//利用一个中间变量pTemp将变量值交换</span></span><br><span class="line"> 		strTemp.m_pData = m_pData;</span><br><span class="line"> 		m_pData = pTemp;</span><br><span class="line"> 	&#125;								</span><br><span class="line"><span class="comment">//在if作用域外，由于strTemp是局部变量会自动调用析构函数释放内存，</span></span><br><span class="line"><span class="comment">//其中strTemp中的成员变量m_pData所指向的内存就是原来被赋值实例成员函数的内存，刚好一并释放</span></span><br><span class="line"></span><br><span class="line"> 	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p></p><p id="a03"></p><p></p>
<h3 id="面试题-3：二维数组中的查找"><a href="#面试题-3：二维数组中的查找" class="headerlink" title="面试题 3：二维数组中的查找"></a>面试题 3：二维数组中的查找</h3><p><img src="/images/mianshi3.png" alt=""><br>一般的思路是从左上角开始做比较，但是减小排除的范围无规律，若是从<strong>右上角</strong>或者<strong>左下角</strong>做比较，则可以以行或者列减小排查范围，而二维数组以<strong>连续内存存储</strong>的特性让我们可以通过下标访问数组以矩阵形式的空间位置。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span>* matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> columns, <span class="keyword">int</span> number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line"> 	</span><br><span class="line">  <span class="keyword">if</span>(matrix != <span class="literal">NULL</span> &amp;&amp; rows &gt;<span class="number">0</span> &amp;&amp; columns &gt;<span class="number">0</span>) <span class="comment">//矩阵有效性检测（若输入空指针）</span></span><br><span class="line">  &#123;</span><br><span class="line"> 	<span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line"> 	<span class="keyword">int</span> column = column <span class="number">-1</span>;</span><br><span class="line"> 	<span class="keyword">while</span>(row &lt; rows &amp;&amp; column &gt;=<span class="number">0</span>) <span class="comment">//循环停止条件:最后一行或者第一列</span></span><br><span class="line"> 	&#123;</span><br><span class="line"> 	  <span class="keyword">if</span>(matrix[row * columns + column] == number) <span class="comment">//第row行第column列，相当于[row][column]</span></span><br><span class="line"> 	  &#123;</span><br><span class="line"> 		  found = <span class="literal">true</span>;</span><br><span class="line"> 		  <span class="keyword">break</span>;</span><br><span class="line"> 	  &#125;</span><br><span class="line"> 	  <span class="keyword">else</span> <span class="keyword">if</span>(matrix[row * columns + column] &gt;number)</span><br><span class="line"> 	 		  column--;</span><br><span class="line"> 	  <span class="keyword">else</span> row++;</span><br><span class="line"> 	&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p></p><p id="a04"></p><p></p>
<h3 id="面试题-4：替换空格"><a href="#面试题-4：替换空格" class="headerlink" title="面试题 4：替换空格"></a>面试题 4：替换空格</h3><p><img src="/images/mianshi4.png" alt=""><br>网络编程中，URL参数中特殊字符串(空格、#等)需要替换成服务器端可以识别的字符，转换的规则是<strong>在’%’后面加上字符ASCII码的两位十六进制表示</strong>，如空格的ASCII码为32，十六进制为0x20，因此空格被替换成”%20”。<br>解题思路:题目理解有两种，第一种是创建新的字符串并在新的字符串上做替换，则我们可以<strong>分配足够多的内存</strong>，第二种是在原字符串上做替换，则我们需要保证输入字符串后有<strong>足够多的空余内存</strong>并且<strong>不能覆盖原字符串的内存</strong>。<br><strong>解法一</strong>:字符串从前往后遍历找到一个空格则空格后的字符集体向后移动两个字节大小。时间复杂度为<strong>O(n^2)</strong>，<strong>多次移动次数</strong>，不是好的解决方案。<br><strong>解法二</strong>:先遍历一次字符串，统计出字符串中空格总数由此计算出<strong>替换后字符串的长度</strong>，之后<strong>从字符串末尾开始复制和替换</strong>，这样所有字符只移动一次，算法的时间效率是<strong>O(n)</strong>。<br>具体的复制和替换过程为使用<strong>两个指针</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReplaceBlank</span><span class="params">(<span class="keyword">char</span> <span class="built_in">string</span>[], <span class="keyword">int</span> maxLength)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	<span class="keyword">if</span>(<span class="built_in">string</span> == <span class="literal">NULL</span> &amp;&amp; length &lt;= <span class="number">0</span>)   <span class="comment">//输入参数有效性检测性</span></span><br><span class="line"> 		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">//originalLength为字符串原先长度</span></span><br><span class="line"> 	<span class="keyword">int</span> originalLength = <span class="number">0</span>;</span><br><span class="line"> 	<span class="keyword">int</span> numberOfBlank = <span class="number">0</span>;</span><br><span class="line"> 	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"> 	<span class="keyword">while</span>(<span class="built_in">string</span>[i] != <span class="string">'\0'</span>)</span><br><span class="line"> 	&#123;</span><br><span class="line"> 		originalLength++;</span><br><span class="line"> 		<span class="keyword">if</span>(<span class="built_in">string</span>[i] == <span class="string">' '</span>) numberOfBlank++;</span><br><span class="line"> 		i++;</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">//newLength为替换后的字符串长度</span></span><br><span class="line"> 	<span class="keyword">int</span> newLength = originalLength + numberOfBlank * <span class="number">2</span>;</span><br><span class="line"> 	<span class="keyword">if</span>(newLength &gt; maxLength)     <span class="comment">//如果替换后字符串长度大于字符串总容量</span></span><br><span class="line"> 		<span class="keyword">return</span>;</span><br><span class="line"> 	</span><br><span class="line"> 	<span class="keyword">int</span> indexOfOriginal = originalLength;</span><br><span class="line"> 	<span class="keyword">int</span> indexOfNew = newLength;</span><br><span class="line"> 	<span class="keyword">while</span>(indexOfOriginal &gt;= <span class="number">0</span> &amp;&amp; indexOfNew &gt; indexOfOriginal)<span class="comment">//替换完成条件</span></span><br><span class="line"> 	&#123;</span><br><span class="line"> 		<span class="comment">//若是空格则后面的标记添加并前移三个字节</span></span><br><span class="line"> 		<span class="keyword">if</span>(<span class="built_in">string</span>[indexOfOriginal] == <span class="string">' '</span>)  </span><br><span class="line"> 		&#123;</span><br><span class="line"> 			<span class="built_in">string</span>[indexOfNew --] = <span class="string">'0'</span>;</span><br><span class="line"> 			<span class="built_in">string</span>[indexOfNew --] = <span class="string">'2'</span>;</span><br><span class="line"> 			<span class="built_in">string</span>[indexOfNew --] = <span class="string">'%'</span>;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="keyword">else</span></span><br><span class="line"> 		&#123;	<span class="comment">//若不空格则复制前面指针的字符到后面指针的位置，并前移指针</span></span><br><span class="line"> 			<span class="built_in">string</span>[indexOfNew --] = <span class="built_in">string</span>[indexOfOriginal]; </span><br><span class="line"> 		&#125;</span><br><span class="line"> 		</span><br><span class="line"> 		-- indexOfOriginal;</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p></p><p id="a05"></p><p></p>
<h3 id="面试题-5：从尾到头打印链表"><a href="#面试题-5：从尾到头打印链表" class="headerlink" title="面试题 5：从尾到头打印链表"></a>面试题 5：从尾到头打印链表</h3><p><img src="/images/mianshi5.png" alt=""><br>面试中如果我们打算<strong>修改输入数据</strong>，最好先问面试官允不允许。<br>若允许我们可以将链表中的节点指针<strong>反转改变链表方向</strong>就可以了。<br>通常打印是一个只读操作，假设面试官要求这个题目不能改变链表结构。<br>思路：遍历是<strong>从头到尾</strong>，输出却是<strong>从尾到头</strong>，这是典型的<font color="red">后进先出的栈结构</font>，然后<font color="red">递归的本质就是栈结构</font>，于是我们可以每访问一个节点先递归输出它后面的节点，再输出该节点自身。<br>显示用栈调用代码如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Reversingly-倒置地</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printListReversingly</span><span class="params">(ListNode* pHead)</span> <span class="comment">//不用改变头指针，可传值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;ListNode*&gt; nodes;</span><br><span class="line"></span><br><span class="line">  ListNode *pNode = pHead;</span><br><span class="line">  <span class="keyword">while</span>(pNode != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    node.push(pNode);  <span class="comment">//入栈</span></span><br><span class="line">    pNode = pNode-&gt;Next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(!node.empty())</span><br><span class="line">  &#123;</span><br><span class="line">    pNode = nodes.top();  <span class="comment">//取栈顶元素</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pNode-&gt;Value &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出节点值</span></span><br><span class="line">    nodes.pop();  <span class="comment">//弹出栈顶元素</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>基于递归的栈调用代码如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Recursively-递归地</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printListReversinglyRecursively</span><span class="params">(ListNode* pHead)</span> <span class="comment">//不用改变头指针，可传值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(pHead != <span class="literal">NULL</span>)  <span class="comment">//判断是不是空链表</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(pHead-&gt;Next != <span class="literal">NULL</span>) printListReversinglyRecursively(pHead-&gt;Next);  <span class="comment">//判断是不是最后一个结点，若是最后一个结点则递归结束		</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pHead-&gt;Value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;	</span><br><span class="line">&#125;</span><br><span class="line">Tips:链表长时，导致函数调用层级很深，有可能导致函数调用栈移除，鲁棒性(程序稳定性)不好。</span><br></pre></td></tr></table></figure></p>
<hr>
<p></p><p id="a06"></p><p></p>
<h3 id="面试题-6：重建二叉树"><a href="#面试题-6：重建二叉树" class="headerlink" title="面试题 6：重建二叉树"></a>面试题 6：重建二叉树</h3><p><img src="/images/mianshi6.png" alt=""><br>思路：前序遍历可以确定<strong>树的根节点</strong>(第一个数字)，中序遍历在知道了根节点的值后可以知道<strong>左子树的结点值</strong>(根节点左边的所有值)和<strong>右子树的结点值</strong>(根节点右边的所有值)，之后用<font color="red">递归的方式</font>完成剩下子树的建立<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//树的主构造函数</span></span><br><span class="line"><span class="function">BinaryTreeNode* <span class="title">Construct</span><span class="params">(<span class="keyword">int</span>* preorder, <span class="keyword">int</span>* inorder, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(preorder == <span class="literal">NULL</span> || inorder == <span class="literal">NULL</span> || length &lt;= <span class="number">0</span>)  <span class="comment">//输入有效性检测</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ConstructCore(preorder, preorder+length<span class="number">-1</span>, inorder, inorder+length<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树的核心构造函数，通过传入前序遍历的头尾指针、中序遍历的头尾指针递归建树</span></span><br><span class="line"><span class="function">BinaryTreeNode* <span class="title">ConstructCore</span><span class="params">(<span class="keyword">int</span>* startPreorder, <span class="keyword">int</span> *endPreorder, <span class="keyword">int</span>* startInorder, <span class="keyword">int</span>* endInorder)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//前序遍历的第一个数字是根节点的值</span></span><br><span class="line">  <span class="keyword">int</span> rootValue = startPreorder[<span class="number">0</span>];</span><br><span class="line">  BinaryTreeNode* root = <span class="keyword">new</span> BinaryTreeNode();</span><br><span class="line">  root-&gt;m_nValue = rootValue;</span><br><span class="line">  root-&gt;m_pLeft = root-&gt;m_pRight = <span class="literal">NULL</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(startPreorder == endPreorder)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//若是输入的树前序只有一个值、中序也只有一个值且这两个值是同一个值</span></span><br><span class="line">    <span class="comment">//则输入的这个值就是这棵树的根节点，否则是无效输入</span></span><br><span class="line">    <span class="keyword">if</span>(startInorder == endInorder &amp;&amp; *startPreorder == *startInorder) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">throw</span> <span class="built_in">std</span>::exception(<span class="string">"Invalid input"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//在中序遍历中找到根节点的值</span></span><br><span class="line">  <span class="keyword">int</span>* rootInorder = startInorder;</span><br><span class="line">  <span class="keyword">while</span>(rootInorder &lt;= endInorder &amp;&amp; *rootInorder != rootValue) rootInorder++;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果找到的节点在中序的末尾且值并不是根节点的值，返回错误</span></span><br><span class="line">  <span class="keyword">if</span>(rootInorder == endInorder &amp;&amp; *rootInorder != rootValue)</span><br><span class="line">  <span class="keyword">throw</span> <span class="built_in">std</span>::exception(<span class="string">"Invalid input"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//可以通过找到的节点确定左子树长度和左子树范围</span></span><br><span class="line">  <span class="keyword">int</span> leftLength = rootInorder - startInorder;</span><br><span class="line">  <span class="keyword">int</span>* leftPreorderEnd = startPreorder + leftLength;</span><br><span class="line">  <span class="keyword">if</span>(leftLength &gt;<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//构建左子树</span></span><br><span class="line">    root-&gt;m_pLeft = ConstructCore(startPreorder+<span class="number">1</span>,leftPreorderEnd,startInorder,rootInorder<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(leftLength &lt; endPreorder-startPreorder)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//构建右子树</span></span><br><span class="line">    root-&gt;m_pRight = ConstructCore(leftPreorderEnd+<span class="number">1</span>,endPreorder,rootInorder+<span class="number">1</span>,endInorder);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>让我们来看看ConstructCore做了什么事<br><img src="/images/saomiao1.jpg" alt=""></p>
<hr>
<p></p><p id="a07"></p><p></p>
<h4 id="面试题-7：用两个栈实现队列"><a href="#面试题-7：用两个栈实现队列" class="headerlink" title="面试题 7：用两个栈实现队列"></a>面试题 7：用两个栈实现队列</h4><p><img src="/images/mianshi7.png" alt=""><br>思路：插入元素直接插入第一个栈即可，删除元素则若是第二个栈有元素就pop，若是第二个栈没有元素，则将第一个栈的元素全部pop并push进第一个栈，之后按照第二个栈有元素的方式pop<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//元素入队</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> CQueue&lt;T&gt;::appendTail(<span class="keyword">const</span> T&amp; element)</span><br><span class="line">&#123;</span><br><span class="line">  stack1.push(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//元素出队</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; T CQueue&lt;T&gt;::deleteHead()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(stack2.size() &lt;= <span class="number">0</span>)  <span class="comment">//stack2空则将stack1全部弹出压如stack2</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span>(stack1.size() &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      T&amp; data = stack1.top();</span><br><span class="line">      stack1.pop();</span><br><span class="line">      stack2.push(data);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//此时若是stack2还是空，则证明队列是空的</span></span><br><span class="line">  <span class="keyword">if</span>(stack2.size() = <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> exception(<span class="string">"queue is empty"</span>);  </span><br><span class="line"></span><br><span class="line">  T head = stack2.top();  <span class="comment">//否则弹出栈顶元素</span></span><br><span class="line">  stack2.pop();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>两个栈实现一个队列像是一个是<strong>插入栈</strong>一个是<strong>删除栈</strong>，而<font color="red">两个队列实现一个栈</font>呢？<br>思路如下<br><img src="/images/saomiao2.jpg" alt=""></p>
<hr>
<p></p><p id="a08"></p><p></p>
<h3 id="面试题-8：旋转数组的最小数字"><a href="#面试题-8：旋转数组的最小数字" class="headerlink" title="面试题 8：旋转数组的最小数字"></a>面试题 8：旋转数组的最小数字</h3><p><img src="/images/offer20.png" alt=""><br>输入：{3,4,5,1,2}为数组{1,2,|3,4,5}的旋转<br>输出：1<br>思路：</p>
<ul>
<li>1.直接遍历：时间复杂度为O(n)，但没有利用<strong>旋转数组的特性</strong></li>
<li>2.二分查找法：将数组看成<strong>两个递增数组</strong>，设置两个指针指向<font color="red">第一个元素p</font>和<font color="red">最后一个元素q</font>，由于一开始的数组为递增数组，则<strong>array[p]&gt;=array[q]</strong>，此时<font color="red">中间元素m</font>若<strong>大于array[p]</strong>则为<strong>前部分递增数组的元素</strong>于是将<font color="red">p=m</font>，中间元素若<strong>小于array[q]</strong>则为<strong>后部分递增数组的元素</strong>于是将<font color="red">q=m</font>，不断<strong>逼近两个递增数组的交界元素</strong>，最后若<font color="red">p=q-1</font>则找到了数组交界，此时<strong>array[q]为最小元素/array[p]为最大元素</strong></li>
<li>3.<strong>特殊情况</strong>：若<font color="red">array[p]==array[q]==array[m]</font>则<strong>无法确认arrary[m]属于哪部分数组</strong>，这种情况如下，需要使用<strong>顺序查找</strong><br><img src="/images/offerMianshi00.png" alt=""><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二分查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Min</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[],<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//输入有效性检测</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">array</span>==<span class="literal">NULL</span> || length&lt;=<span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">std</span>::exception(<span class="string">"Invaild parameters"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> p=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> q=length<span class="number">-1</span>;</span><br><span class="line">  <span class="comment">//m初始化为0，因为若旋转数组是将0个元素放在后面，最小元素则为第一个元素</span></span><br><span class="line">  <span class="keyword">int</span> m=<span class="number">0</span>;  </span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">array</span>[p]&gt;=<span class="built_in">array</span>[q])</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(q-p==<span class="number">1</span>)&#123;</span><br><span class="line">      m=q;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    m=(p+q)/<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//若array[p]==array[q]==array[m]转为顺序查找</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">array</span>[p]==<span class="built_in">array</span>[q] &amp;&amp; <span class="built_in">array</span>[m]==<span class="built_in">array</span>[p]) <span class="keyword">return</span> MinInOrder(<span class="built_in">array</span>,p,q);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">array</span>[m]&gt;=<span class="built_in">array</span>[p]) p=m;</span><br><span class="line">    <span class="keyword">else</span> q=m;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">array</span>[m];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//顺序查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MinInOrder</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[],<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result = <span class="built_in">array</span>[p];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=p+<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">array</span>[i]&lt;result) result = <span class="built_in">array</span>[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<p></p><p id="a09"></p><p></p>
<h3 id="面试题-9：斐波那契数列"><a href="#面试题-9：斐波那契数列" class="headerlink" title="面试题 9：斐波那契数列"></a>面试题 9：斐波那契数列</h3><p><img src="/images/offerMianshi01.png" alt=""><br>若用递归很简单<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> Fibonacci(n<span class="number">-1</span>)+Fibonacci(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>递归实现的<strong>效率十分低</strong>，而且设计大量的<strong>重复计算</strong>，如计算F(10)要计算F(9)+F(8)，而计算F(9)又要计算F(8)+F(7)，这样F(8)就重复计算了</p>
<font color="red"><strong>改进1：</strong></font><strong>避免重复计算</strong>，将计算得到的<strong>中间项保存</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> *result = <span class="keyword">new</span> <span class="keyword">int</span>[n];;  <span class="comment">//将中间项保存至数组中</span></span><br><span class="line">  result[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">  result[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(n&lt;<span class="number">2</span>) <span class="keyword">return</span> result[n];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    result[i]=result[i<span class="number">-1</span>]+result[i<span class="number">-2</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><font color="red"><strong>改进2：</strong></font>改进1虽然避免了重复计算，但是空间开辟了太大，我们只需要<strong>得到F(n)不关心中间项的结果</strong>，因此中间项我们不必保存下来<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result[<span class="number">2</span>];</span><br><span class="line">  result[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">  result[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(n&lt;<span class="number">2</span>) <span class="keyword">return</span> result[n];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> n_1=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> n_2=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> n_now=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)  <span class="comment">//不保存中间项，只保存前面两项，实时替换</span></span><br><span class="line">  &#123;</span><br><span class="line">    n_now = n_1 + n_2;</span><br><span class="line">    n_2=n_1;</span><br><span class="line">    n_1=n_now;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> n_now;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>—<br><br><p id="a10"></p><br><font size="5"><strong>面试题 10：二进制中1的个数</strong></font><br><img src="/images/mianshi10.png" alt=""><br><br><font color="blue"><strong>思路1:</strong></font>：1的二进制为0…01，即除了第一位为1其他位均为0，利用这点，任何数与1作<strong>与运算</strong>，若其第一位为1，则运算结果为1，其第一位为0，则运算结果为0，之后可利用<strong>右移运算符验证下一位数</strong>直到所有数为0<br><font color="red"><strong>思路1有一个问题</strong></font>是<strong>负数右移运算左边补的不是0而是1保证负数性质</strong>，因此最后数字会变成1….1<font color="red">陷入死循环</font><br><font color="blue"><strong>思路2:</strong></font>：利用将<strong>1左移</strong>可避免死循环<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numberOfNum</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> flag=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(flag)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(n &amp; flag) count++;</span><br><span class="line">    flag = flag &lt;&lt;<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><font color="red"><strong>思路2的问题</strong></font>是<strong>效率太低</strong>，有多少位的整数就要循环移动多少次<br><font color="blue"><strong>思路3:</strong></font>：改变原来的数，<strong>消除输入数中的1</strong>，输入数中至少有一个1，若为xxx1000，则<strong>减1</strong>为xxx0111，此时减去的数与输入数做<strong>与运算</strong>，得到的结果是xxx0000，与输入数相比我们<strong>消除了其右边第一个1</strong>，继续使用这种方法<strong>直到输入数所有1被消除为0时停止</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numberOfNum</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(n)</span><br><span class="line">  &#123;</span><br><span class="line">    count++;</span><br><span class="line">    n=n &amp; (n<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><font color="red"><strong>总结：</strong></font>把一个整数减去1之后再和原来的整数做与运算，得到的结果相当于把原来整数的二进制表示中的最右边的1变成0，即<strong>xxx100 &amp; xxx011 = xxx000</strong><br><br><br><br><p id="a11"></p><br><font size="5"><strong>面试题 11：数值的整数次方</strong></font><br><img src="/images/mianshi11.png" alt=""><br>类似于实现pow函数功能<br><font color="blue"><strong>思路1：</strong></font>使base与自身相乘循环exponent次数，缺点<strong>输入指数为0或者负数</strong>无法执行<br><font color="blue"><strong>思路2：</strong></font>负数时，可以对<strong>指数求绝对值</strong>，算出base的次方结果后<strong>再取倒数</strong>，当然要注意底数base是0的情况，0求倒数程序会运行出错，这时可以使用<strong>抛出异常处理</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base,<span class="keyword">int</span> exponent)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="comment">//0的负数次幂</span></span><br><span class="line">  <span class="keyword">if</span>(equal(base,<span class="number">0.0</span>) &amp;&amp; exponent&lt;<span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">std</span>::exception(<span class="string">"Invaild Base"</span>);</span><br><span class="line">  <span class="comment">//0的0次或者正数次幂为0</span></span><br><span class="line">  <span class="keyword">if</span>(equal(base,<span class="number">0.0</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">double</span> result;</span><br><span class="line">  <span class="comment">//非0的负数次幂，幂取绝对值，算pow，取倒数</span></span><br><span class="line">  <span class="keyword">if</span>(exponent &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> absExponent = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(exponent);</span><br><span class="line">    result = <span class="built_in">pow</span>(base,absExponent);</span><br><span class="line">    result = <span class="number">1.0</span>/result;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(exponent &gt; <span class="number">0</span>)&#123;  <span class="comment">//非0的整数次幂，算pow</span></span><br><span class="line">    result = <span class="built_in">pow</span>(base,exponent);</span><br><span class="line">    <span class="keyword">return</span> result;  </span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;  <span class="comment">//非0的0次幂为1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">pow</span><span class="params">(<span class="keyword">double</span> base,<span class="keyword">unsigned</span> <span class="keyword">int</span> exponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">double</span> result = <span class="number">1.0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=exponent;i++) result *= base;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断base是否为0函数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">equal</span><span class="params">(<span class="keyword">double</span> num1,<span class="keyword">double</span> num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>((num1-num2 &gt;<span class="number">-0.0000001</span>) &amp;&amp; (num1-num2 &lt;<span class="number">0.0000001</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="/images/jiqiao1.png" alt=""><br><font color="blue"><strong>思路3：</strong></font>当exponent较大时，pow函数中循环需要做<strong>多次乘法</strong>，可以优化一下乘方运算，用如下公式求a的n次方<br><img src="/images/jiqiao2.png" alt=""><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">pow</span><span class="params">(<span class="keyword">double</span> base,<span class="keyword">unsigned</span> <span class="keyword">int</span> exponent)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="comment">//递归返回条件 </span></span><br><span class="line">  <span class="keyword">if</span>(exponent ==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(exponent ==<span class="number">1</span>) <span class="keyword">return</span> base;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">double</span> result = <span class="built_in">pow</span>(base,exponent &gt;&gt;<span class="number">1</span>);  <span class="comment">//用右移运算代替除2</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//exponent为偶数时 直接相乘即可</span></span><br><span class="line">  result *= result;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//exponent为奇数时，还需乘base</span></span><br><span class="line">  <span class="keyword">if</span>(exponent &amp; <span class="number">0x1</span> ==<span class="number">1</span>) result*=base;  <span class="comment">//用位运算代替了求余运算判断是否奇数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="/images/jiqiao3.png" alt=""><br><br>—<br><br><p id="a12"></p><br><font size="5"><strong>面试题 12：打印1到最大的n位数</strong></font><br><img src="/images/mianshi12.png" alt=""><br><font color="red"><strong>陷阱：</strong></font><strong>大数问题</strong>，没有规定n的范围，若n位数大于整型(int)或者长整型(long long)时会溢出<br><font color="blue"><strong>思路1：</strong></font><strong>在字符串上模拟数字加法</strong>，<br>1.申明一个长度为n+1的字符串(最后一个是结束符号’\0’)，将字符串中数字初始化为’0’<br>2.字符串数字加法函数<br>3.打印字符串函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintToMaxDigits</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">char</span> *number = <span class="keyword">new</span> <span class="keyword">char</span>[n+<span class="number">1</span>];</span><br><span class="line">  <span class="built_in">memset</span>(number,<span class="string">'0'</span>,n);</span><br><span class="line">  number[n]=<span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(!Increment(number)) PrintNumber(number); </span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> []number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Increment</span><span class="params">(<span class="keyword">char</span>* number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">bool</span> isOverflow = <span class="literal">false</span>;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><br><br><p id="a13"></p><br><font size="5"><strong>面试题 13：在O(1)时间删除链表结点</strong></font><br><img src="/images/mianshi13.png" alt=""><br><font color="blue"><strong>思路1：</strong></font>从头指针遍历到结点指针的上一个指针，之后将上一个指针的Next指向结点指针的Next指针指向的结点即可，之后在链表中删除该结点，由于是<strong>顺序查找</strong>，时间复杂度为O(n)不符合要求<br><font color="blue"><strong>思路2：</strong></font><strong>将结点指针的下一个指针的内容复制到需要删除的节点上</strong>，再把下一个指针删除，注意有两种特殊情况<br><font color="red"><strong>1.结点指针是尾指针：</strong></font>此时没有下一个指针，因此还是需要<strong>顺序查找从头遍历</strong><br><font color="red"><strong>2.链表中只有一个结点：</strong></font>我们要删除的也是这个结点，这种情况我们删除掉结点后还要把<strong>链表的头结点设置为NULL</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode** pListHead,ListNode* pToBeDelete)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//有效性检测</span></span><br><span class="line">  <span class="keyword">if</span>(pListHead == <span class="literal">NULL</span> || pToBeDelete==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//结点指针不是尾指针</span></span><br><span class="line">  <span class="keyword">if</span>(pToBeDelete-&gt;m_pNext!=<span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    ListNode* pNext=pToBeDelete-&gt;m_pNext;  <span class="comment">//结点指针的下一个指针</span></span><br><span class="line">    <span class="comment">//将下一个指针的内容全部复制到结点指针</span></span><br><span class="line">    pToBeDelete-&gt;m_nValue=pNext-&gt;m_nValue;</span><br><span class="line">    pToBeDelete-&gt;m_pNext=pNext-&gt;m_pNext;</span><br><span class="line">    <span class="comment">//删除下一个指针</span></span><br><span class="line">    <span class="keyword">delete</span> pNext;</span><br><span class="line">    pNext=<span class="literal">NULL</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(*pListHead=pToBeDelete) <span class="comment">//若节点指针是尾指针也是头指针</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">delete</span> pToBeDelete;</span><br><span class="line">    pToBeDelete=<span class="literal">NULL</span>;</span><br><span class="line">    *pListHead=<span class="literal">NULL</span>;  <span class="comment">//头指针设置为NULL</span></span><br><span class="line">  &#125;<span class="keyword">else</span>  <span class="comment">//若节点指针是尾指针但不是头指针</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//思路1：顺序遍历删除</span></span><br><span class="line">    ListNode* pNode=*pListHead;</span><br><span class="line">    <span class="keyword">while</span>(pNode-&gt;m_pNext!=pToBeDelete) pNode=pNode-&gt;m_pNext;</span><br><span class="line">    <span class="comment">//找到节点指针的上一个指针</span></span><br><span class="line">    pNode-&gt;m_pNext=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">delete</span> pToBeDelete;</span><br><span class="line">    pToBeDelete=<span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><strong>时间复杂度</strong>：<br>对于n-1个非尾节点，为O(1);<br>对于尾节点，为O(n)；<br>平均为<strong>[(n-1)*O(1)+O(n)]/n</strong>，结果还是O(1);<br><br><br><p id="a14"></p><br><font size="5"><strong>面试题 14：调整数组顺序使奇数位于偶数前面</strong></font><br><img src="/images/mianshi14.png" alt=""><br><font color="blue"><strong>思路1：</strong></font>维护数组的两个头尾指针，头指针向后移动直到遇到偶数停下，尾指针想前移动直到遇到奇数停下，若停下时头指针在尾指针前面则交换两个指针的值继续移动，否则停止移动调整数组顺序完成<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReorderArray</span><span class="params">(<span class="keyword">int</span>* <span class="built_in">array</span>,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//有效性检测</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">array</span>==<span class="literal">NULL</span> || length &lt;=<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">int</span> *head=<span class="built_in">array</span>;  <span class="comment">//头指针</span></span><br><span class="line">  <span class="keyword">int</span> *end=<span class="built_in">array</span>+length<span class="number">-1</span>;  <span class="comment">//尾指针</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(head&lt;end)</span><br><span class="line">  &#123; </span><br><span class="line">    <span class="comment">//头指针向后移动直到遇到偶数</span></span><br><span class="line">    <span class="keyword">while</span>(head&lt;end &amp;&amp; (*head &amp; <span class="number">0x1</span>) != <span class="number">0</span>) head++;</span><br><span class="line">    <span class="comment">//尾指针向前移动直到遇到奇数</span></span><br><span class="line">    <span class="keyword">while</span>(head&lt;end &amp;&amp; (*end &amp; <span class="number">0x1</span>) == <span class="number">0</span>) end--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(head&lt;end) <span class="comment">//交换</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> temp=*head;</span><br><span class="line">      *head=*end;</span><br><span class="line">      *end=temp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><font color="blue"><strong>思路2：</strong></font><strong>解耦</strong>，可将判断条件封装成一个函数，即可拓展成许多情况，如将正数放在负数前面，将3整除的数放在3不整除的数，如<strong>快速排序中的分区函数</strong>比基准数小的数放在比基准书大的数的前面<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void ReorderArray(int* array,int length，bool (*func)(int))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">array</span>==<span class="literal">NULL</span> || length &lt;=<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">int</span> *head=<span class="built_in">array</span>; </span><br><span class="line">  <span class="keyword">int</span> *end=<span class="built_in">array</span>+length<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">while</span>(head&lt;end)</span><br><span class="line">  &#123; </span><br><span class="line">    <span class="keyword">while</span>(head&lt;end &amp;&amp; func(*head)) head++;</span><br><span class="line">    <span class="keyword">while</span>(head&lt;end &amp;&amp; func(*end)) end--;</span><br><span class="line">    <span class="keyword">if</span>(head&lt;end) </span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> temp=*head;</span><br><span class="line">      *head=*end;</span><br><span class="line">      *end=temp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEven</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (n &amp; <span class="number">1</span>)==<span class="number">0</span>;  <span class="comment">//偶数与1位运算为0 奇数与1位运算不为0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><br><br><p id="a15"></p><br><font size="5"><strong>面试题 15：链表中倒数第K个结点</strong></font><br><img src="/images/mianshi15.png" alt=""><br><font color="blue"><strong>思路1：</strong></font>由于是<strong>单向链表</strong>，因此无法从尾到头遍历，我们要找倒数第k个结点，若是知道链表中共有n个结点<strong>(尾节点为第n-1个结点)</strong>，则找的是n-(k-1)就是<strong>第n-k+1个结点</strong>；我们可以定义两个指针指向头指针，由于倒数第k个结点的指针与尾指针相差<strong>k-1</strong>个结点，则让第一个指针先走<strong>k-1</strong>个结点，之后两个指针同时向后走，第一个指针走到尾节点时，第二个指针与其也相差k-1个结点，即是倒数第k个结点<br><font color="blue"><strong>鲁棒性检测</strong></font><br>1.头指针为空指针<br>2.链表总数小于k<br>3.输入k为0<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">findKToTail</span><span class="params">(ListNode* head,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(head==<span class="literal">NULL</span> || k&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  ListNode* first=head;</span><br><span class="line">  ListNode* second=head;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k<span class="number">-1</span>;i++) <span class="comment">//第一个节点走k-1步</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(first-&gt;m_pNext != <span class="literal">NULL</span>) first=first-&gt;m_pNext;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;  <span class="comment">//链表中的元素小于k个</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//第一个节点为尾节点时 第二个节点刚好是倒数第k个结点</span></span><br><span class="line">  <span class="keyword">while</span>(first-&gt;m_pNext != <span class="literal">NULL</span>)  </span><br><span class="line">  &#123;</span><br><span class="line">    first=first-&gt;m_pNext;</span><br><span class="line">    second=second-&gt;m_pNext;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="/images/jiqiao4.png" alt=""><br><br><br><p id="a16"></p><br><font size="5"><strong>面试题 16：反转链表</strong></font><br><img src="/images/mianshi16.png" alt=""><br><font color="blue"><strong>思路：</strong></font>两个指针反转会出现<strong>链表断裂</strong>，因此需要三个指针，具体操作为前指针，当前指针，后指针，当前指针指向前指针，当前指针变前指针，后指针变当前指针，当前指针的Next指向为后指针，直到当前指针为尾指针，反转后变成头指针<br><font color="red"><strong>陷阱：</strong></font><br>1.考虑输入的头指针为NULL情况<br>2.输入的链表仅有一个节点的情况<br>3.输入的链表仅有两个结点的情况<br>4.原先头结点的Next变为NULL，头指针指向原先的尾节点<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//有效性检测(针对陷阱1)</span></span><br><span class="line">  <span class="keyword">if</span>(head==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  ListNode* front=<span class="literal">NULL</span>;</span><br><span class="line">  ListNode* now=head;</span><br><span class="line">  ListNode* back=now-&gt;m_pNext;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(back!=<span class="literal">NULL</span>)  <span class="comment">//针对陷阱2</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span>(back-&gt;m_pNext!=<span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//由于一开始front为NULL，所以当now为头节点时反转后就成尾节点，尾节点的Next刚好为NULL</span></span><br><span class="line">      now-&gt;m_pNext=front;  <span class="comment">//针对陷阱4 </span></span><br><span class="line">      front=now;</span><br><span class="line">      now=back;</span><br><span class="line">      back=now-&gt;m_pNext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//now为倒数第二个结点时情况+链表就两个结点的情况(即back的Next为NULL)</span></span><br><span class="line">    <span class="comment">//针对陷阱3</span></span><br><span class="line">    now-&gt;m_pNext=front;</span><br><span class="line">    back-&gt;m_pNext=now;</span><br><span class="line">    head=back;  <span class="comment">//针对陷阱4</span></span><br><span class="line">  &#125; </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> back;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><br><p id="a17"></p><br><font size="5"><strong>面试题 17：合并两个排序的链表</strong></font><br><img src="/images/mianshi17.png" alt=""><br><font color="blue"><strong>思路：</strong></font>类似于<strong>归并排序</strong>中的并过程，两个子数组通过两个指针比较大小值小的放在一个新数组，直到一个数组的值被遍历完之后另一个数组所有值被复制到新数组的后边<br><strong>链表合并也是如此</strong><br>1.新建一个<font color="red">头指针head</font>和<font color="red">当前指针now指向头指针</font><br>2.新建两个指向子链表头结点的指针<font color="red">p和q</font><br>3.循环比较 *p和 *q的大小，值小的赋给now-&gt;Next，<font color="red">now-&gt;Next=p(q)</font>，之后<font color="red">p(q)=p(q)-&gt;Next;now=now-&gt;Next;</font><br>4.直到<font color="red">p(q)=NULL时</font>，将<font color="red">now-&gt;Next=q(p)</font>就完成了<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  ListNode* next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">ListNode* <span class="title">mergeList</span><span class="params">(ListNode* head1, ListNode* head2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//有效性检测</span></span><br><span class="line">  <span class="keyword">if</span> (head1 == <span class="literal">NULL</span>) <span class="keyword">return</span> head2;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (head2 == <span class="literal">NULL</span>) <span class="keyword">return</span> head1;</span><br><span class="line"></span><br><span class="line">  ListNode* head = <span class="keyword">new</span> ListNode;  <span class="comment">//头指针</span></span><br><span class="line">  ListNode* now = head;  <span class="comment">//当前指针</span></span><br><span class="line">  ListNode* p = head1;</span><br><span class="line">  ListNode* q = head2;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; q!= <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;val&gt;q-&gt;val)</span><br><span class="line">    &#123;</span><br><span class="line">      now-&gt;next = q;  <span class="comment">//当前指针指向值小的结点</span></span><br><span class="line">      q = q-&gt;next;  <span class="comment">//结点跳到下一个</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      now-&gt;next = p;</span><br><span class="line">      p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    now = now-&gt;next;  <span class="comment">//当前指针跳到下一个</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (p == <span class="literal">NULL</span>) now-&gt;next = q; </span><br><span class="line">  <span class="keyword">if</span> (q == <span class="literal">NULL</span>) now-&gt;next = p;</span><br><span class="line">  <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><br><p id="a18"></p><br><font size="5"><strong>面试题 18：树的子结构</strong></font><br><img src="/images/mianshi18.png" alt=""><br><font color="blue"><strong>思路：</strong></font><br>1.找到树1中与树2根节点的值相同值的结点<br>2.<strong>递归</strong>判断是否两个相同值的结点有相同的树结构<br>3.否则继续<strong>递归</strong>遍历其他根节点<br><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  BinaryTreeNode* left;</span><br><span class="line">  BinaryTreeNode* right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//递归遍历执行1.3.步</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HasSubtree</span><span class="params">(BinaryTreeNode* root1,BinaryTreeNode* root2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">bool</span> result==<span class="literal">false</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//有效性检测</span></span><br><span class="line">  <span class="keyword">if</span>(root1 !=<span class="literal">NULL</span> &amp;&amp; root2 !=<span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(root1-&gt;val==root2-&gt;val) result=HasSameStruct(root1,root2)</span><br><span class="line">    <span class="keyword">if</span>(!result) result=HasSubtree(root1-&gt;left,root2);</span><br><span class="line">    <span class="keyword">if</span>(!result) result=HasSubtree(root1-&gt;right,root2);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归遍历执行2.步</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HasSameStruct</span><span class="params">(BinaryTreeNode* root1,BinaryTreeNode* root2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(root2==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">//正确遍历到树2的叶节点时，则证明树的结构相同</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(root1==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//遍历到树1的叶节点而不是树2的叶节点时，则证明树的结构不同</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(root1-&gt;val != root2-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//遍历到树1的内部结点和树2的内部结点的值不同时，则证明树的结构不同</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> HasSameStruct(root1-&gt;left,root2-&gt;left) &amp;&amp; HasSameStruct(root1-&gt;right,root2-&gt;right);  <span class="comment">//遍历到树1的内部结点和树2的内部结点的值相同时，则继续向下遍历</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><br><p id="a19"></p><br><font size="5"><strong>面试题 19：二叉树的镜像</strong></font><br><img src="/images/mianshi19.png" alt=""><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树结点定义结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  BinaryTreeNode* left;</span><br><span class="line">  BinaryTreeNode* right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><font color="blue"><strong>思路：</strong></font> <strong>画图</strong>可以发现，求树的镜像实质就是<br>1.前序遍历(根-左-右)树的每个结点<br>2.遍历到的结点是非叶子节点(有子节点)则交换两个子节点<br><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MirrorTree</span><span class="params">(BinaryTreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="comment">//有效性检测</span></span><br><span class="line">  <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">//遍历到叶子节点时返回</span></span><br><span class="line">  <span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span> &amp;&amp; root-&gt;right==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">//非叶子节点则交换两个子节点</span></span><br><span class="line">  BinaryTreeNode* temp=root-&gt;left;</span><br><span class="line">  root-&gt;left=root-&gt;right;</span><br><span class="line">  root-&gt;right=temp;</span><br><span class="line">  <span class="comment">//继续向下遍历</span></span><br><span class="line">  <span class="keyword">if</span>(root-&gt;left !=<span class="literal">NULL</span>) MirrorTree(root-&gt;left);</span><br><span class="line">  <span class="keyword">if</span>(root-&gt;right !=<span class="literal">NULL</span>) MirrorTree(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><br><p id="a20"></p><br><font size="5"><strong>面试题 20：顺时针打印矩阵</strong></font><br><img src="/images/mianshi20.png" alt=""><br><img src="/images/mianshi20+.png" alt=""><br><br><font color="blue"><strong>思路：</strong></font>通过<strong>画图</strong>我们知道<br><strong>1.循环打印的圈数</strong>是由<strong>矩阵matrix[x][y]中的较小的值决定的</strong>，并且每次<strong>开始循环打印的坐标点都是(start,start)</strong>，综合我们知道循环继续的条件是<strong>start*2&lt;x并且start*2&lt;y</strong><br><strong>2.打印一圈</strong>可分解成四步：<br><img src="/images/jiqiao20.jpg" alt=""><br><strong>3.关于<font color="red">二位数组传参问题</font></strong>，可参考<a href="http://blog.csdn.net/u013752202/article/details/49688717" target="_blank" rel="noopener">这里</a>，下面的程序其实会执行出错，因为<strong>访问number[i][j]需要使用(int*)number+i*columns+j</strong>的方式访问，处于程序清晰思路才写成如下访问方式<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span>** numbers,<span class="keyword">int</span> rows,<span class="keyword">int</span> columns)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="comment">//有效性检测</span></span><br><span class="line">  <span class="keyword">if</span>(numbers==<span class="literal">NULL</span> || rows&lt;=<span class="number">0</span> || columns&lt;=<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> start=<span class="number">0</span>;start*<span class="number">2</span>&lt;rows &amp;&amp; start*<span class="number">2</span>&lt;columns;start++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">int</span> endRows = rows - start - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> endColumns = columns - start - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = start; i&lt;=endColumns; i++) <span class="built_in">cout</span> &lt;&lt; numbers[start][i] &lt;&lt; ends;</span><br><span class="line">    <span class="keyword">if</span> (start &lt; endRows)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">for</span> (j = start + <span class="number">1</span>; j &lt;= endRows; j++) <span class="built_in">cout</span> &lt;&lt; numbers[j][endColumns] &lt;&lt; ends;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (start&lt;endRows &amp;&amp; start &lt; endColumns)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">for</span> (i = endColumns - <span class="number">1</span>; i &gt;= start; i--) <span class="built_in">cout</span> &lt;&lt; numbers[endRows][i] &lt;&lt; ends;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (start&lt;endRows<span class="number">-1</span> &amp;&amp; start &lt; endColumns)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">for</span> (j = endRows<span class="number">-1</span>; j&gt;start; j--) <span class="built_in">cout</span> &lt;&lt; numbers[j][start] &lt;&lt; ends;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><br><p id="a21"></p><br><font size="5"><strong>面试题 21：包含min函数的栈</strong></font><br><img src="/images/mianshi21.png" alt=""><br><font color="blue"><strong>思路：</strong></font>建立一个<strong>辅助栈</strong>存储当前栈中的最小值<br>1.若压入栈的数字大于之前栈中的最小值，则辅助栈压入之前栈中的最小值，<br>2.若压入栈的数字小于之前栈中的最小值，则辅助栈压入当前的最小值<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">stack</span> &lt;<span class="keyword">int</span>&gt;dataStack;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">stack</span> &lt;<span class="keyword">int</span>&gt;minStack;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  dataStack.push(value);</span><br><span class="line">  <span class="keyword">if</span>(minStack.size()==<span class="number">0</span> || value&lt;minStack.top()) minStack.push(value);</span><br><span class="line">  <span class="keyword">else</span> minStack.push(minStack.top());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(dataStack.size()&gt;<span class="number">0</span> &amp;&amp; minStack.size()&gt;<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    dataStack.pop();</span><br><span class="line">    minStack.pop();</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> exception(<span class="string">"stack is empty"</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">T <span class="title">minFunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(dataStack.size()&gt;<span class="number">0</span> &amp;&amp; minStack.size()&gt;<span class="number">0</span>) <span class="keyword">return</span> minStack.top();</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> exception(<span class="string">"stack is empty"</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>Tips:编写代码时的两个小<strong>错误</strong><br><strong>1.不可用min()命名函数</strong>，与系统函数名冲突<br><strong><font color="red">2.函数模板的使用</font></strong>函数模板是<strong>根据传入参数推测出数据类型</strong>，因此不能<strong>自动推导返回参数类型</strong>，要做到自动推到返回参数类型，可使用<br>- 2.1 多次显示使用特定返回值类型重载函数，如 int minFunc(),double minFunc()<br>- 2.2 使用template <typename t=""> T Func()，但是调用时要<strong>显示指定T类型</strong>，如minFunc<strong><int></int></strong>()，minFunc<strong><double></double></strong>()<br><br><br><p id="a22"></p><br><font size="5"><strong>面试题 22：栈的压入、弹出序列</strong></font><br><img src="/images/mianshi22.png" alt=""><br><font color="blue"><strong>思路：</strong></font><br><strong>检测1：</strong>面对弹出序列的下一个弹出数字，若压入栈的栈顶元素是下一个弹出数字，则弹出<br><strong>检测2：</strong>若下一个弹出数字不在栈顶，则继续将压栈序列中还没有入栈的数字压入，再次执行检测1<br><strong>检测3：</strong>若所有数字都压入栈了仍然没有找到下一个弹出数字，则该序列不可能是一个弹出序列<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPopOrder</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* pushOrder,<span class="keyword">const</span> <span class="keyword">int</span>* popOrder,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//有效性检测</span></span><br><span class="line">  <span class="keyword">if</span>(pushOrder!=<span class="literal">NULL</span> &amp;&amp; popOrder!=<span class="literal">NULL</span> &amp;&amp; length&gt;<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">stack</span> &lt;<span class="keyword">int</span>&gt;stackTest;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">      stackTest.push(pushOrder[i]);</span><br><span class="line">      <span class="keyword">while</span>(j&lt;length &amp;&amp; stackTest.top()==popOrder[j])</span><br><span class="line">      &#123;</span><br><span class="line">        stackTest.pop();</span><br><span class="line">        j++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stackTest.empty();</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><br><p id="a23"></p><br><font size="5"><strong>面试题 23：从上往下打印二叉树</strong></font><br><img src="/images/mianshi23.png" alt=""><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树结点定义结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  BinaryTreeNode* left=<span class="literal">NULL</span>;</span><br><span class="line">  BinaryTreeNode* right=<span class="literal">NULL</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><font color="blue"><strong>思路：</strong></font>通过<strong>举例</strong>可以发现，打印结点的顺序是一个<strong>队列</strong><br>1.将跟结点放入队列<br>2.打印队列头部的一个结点，若该结点有子节点，就将其左右结点放在打印队列的末尾，<br>3.重复打印队列头部的结点操作，直到队列中没有结点元素<br>Tips.小技巧：<strong>STL提供了两端可以进出的队列deque</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printFromTopToBottom</span><span class="params">(BinaryTreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;BinaryTreeNode *&gt; printNodeQueue;</span><br><span class="line">  printNodeQueue.push(root);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(printNodeQueue.size()!=<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    BinaryTreeNode* printNode=printNodeQueue.front();</span><br><span class="line">    printNodeQueue.pop_front();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;printNode-&gt;val&lt;&lt;ends;</span><br><span class="line">    <span class="keyword">if</span>(printNode-&gt;left) printNodeQueue.push_back(printNode-&gt;left);</span><br><span class="line">    <span class="keyword">if</span>(printNode-&gt;right) printNodeQueue.push_back(printNode-&gt;right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><font color="blue"><strong>技巧：</strong></font><font color="red"><strong>广度优先遍历</strong></font>一个图还是一棵树，都要用到<font color="red"><strong>队列</strong></font><br><img src="/images/jiqiao23.png" alt=""><br><br><br><p id="a24"></p><br><font size="5"><strong>面试题 24：二叉搜索树的后序遍历</strong></font><br><img src="/images/mianshi24.png" alt=""><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树结点定义结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  BinaryTreeNode* left=<span class="literal">NULL</span>;</span><br><span class="line">  BinaryTreeNode* right=<span class="literal">NULL</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><font color="blue"><strong>解题思路：递归+后续遍历特点+二叉搜索树特点</strong></font><br>1.<strong>后序遍历</strong>中，序列<strong>最后一个数字为根结点的值</strong><br>2.<strong>二叉搜索树</strong>中，<strong>左子树的值小于根节点的值</strong>，因此序列中<strong>前部分</strong>小于根节点的值的数为左子树的值<br>3.<strong>二叉搜索树</strong>中，<strong>右子树的值大于根节点的值</strong>，因此序列中<strong>后部分</strong>大于根结点的值的树为右子树的值<br>4.基于2.3.找到左子树和右子树序列，并判断<strong>左右子树中的值是否符合二叉搜索树规则</strong><br>5.<strong>递归遍历左右子树</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">verifySquenceOfBST</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[],<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//输入有效性检测</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">array</span>==<span class="literal">NULL</span> || start&lt;end || start&lt;<span class="number">0</span> || end&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span>(end-start&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">int</span> root=<span class="built_in">array</span>[end];  <span class="comment">//1.最后一个数字为根节点的值</span></span><br><span class="line">  <span class="keyword">int</span> curIndex=start;  <span class="comment">//当前结点 从头遍历 停在右子树开始结点</span></span><br><span class="line">  <span class="keyword">while</span>(curIndex&lt;end &amp;&amp; <span class="built_in">array</span>[curIndex]&lt;=root) curIndex++; <span class="comment">//2.找到左子树序列</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=curIndex;i&lt;end;i++)  <span class="comment">//3.4.找到右子树序列并判断是否符合二叉搜索树规则</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">array</span>[i]&lt;root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> verifySquenceOfBST(<span class="built_in">array</span>,start,curIndex<span class="number">-1</span>) &amp;&amp; verifySquenceOfBST(<span class="built_in">array</span>,curIndex,end<span class="number">-1</span>);  <span class="comment">//递归遍历左右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="/images/jiqiao24.png" alt=""><br><font color="red" size="4"><strong>针对后序遍历可以使用两种方式实现</strong></font><br><font color="blue"><strong>思路1：</strong></font>通过<strong>举例</strong>可以发现可以使用<strong>递归+栈</strong>的形式实现。<br>1.将当前遍历到的结点<strong>存入栈</strong>中<br>2.递归遍历<strong>右子树结点</strong><br>3.递归遍历<strong>左子树结点</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">stack</span> &lt;<span class="keyword">int</span>&gt;backOrderStack;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backOrderToStack</span><span class="params">(BinaryTreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">  backOrderStack.push(root-&gt;val);</span><br><span class="line">  <span class="keyword">if</span>(root-&gt;right) backOrderToStack(root-&gt;right);</span><br><span class="line">  <span class="keyword">if</span>(root-&gt;left) backOrderToStack(root-&gt;left);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printBackOrderStackTree</span><span class="params">(BinaryTreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  backOrderToStack(root);</span><br><span class="line">  <span class="keyword">int</span> length = backOrderStack.size();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=length.size();i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;backOrderStack.top()&lt;&lt;ends;</span><br><span class="line">    backOrderStack.pop();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><font color="blue"><strong>思路2：</strong></font>通过<strong>举例</strong>可以发现可以使用<strong>递归+队列</strong>的形式实现。<br>1.递归遍历<strong>左子树结点</strong><br>2.递归遍历<strong>右子树结点</strong><br>3.将当前遍历到的结点<strong>存入队列</strong>中<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; backOrderQueue;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backOrderToQueue</span><span class="params">(BinaryTreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span>(root-&gt;left) backOrderToQueue(root-&gt;left);</span><br><span class="line">  <span class="keyword">if</span>(root-&gt;right) backOrderToQueue(root-&gt;right);</span><br><span class="line">  backOrderQueue.push_back(root-&gt;val);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printBackOrderQueueTree</span><span class="params">(BinaryTreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  backOrderToQueue(root);</span><br><span class="line">  <span class="keyword">int</span> length=backOrderToQueue.size();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=length;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;backOrderToQueue.front()&lt;&lt;ends;</span><br><span class="line">    backOrderToQueue.pop_front();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><br><p id="a25"></p><br><font size="5"><strong>面试题 25：二叉树中和为某一值的路径</strong></font><br><img src="/images/mianshi25.png" alt=""><br><font color="blue"><strong>解题思路：前序遍历特点+递归+栈</strong></font><br>1.由于<strong>路径</strong>是从根节点出发到叶节点，二叉树遍历中只有<strong>前序遍历是首先访问根节点的</strong><br>2.遍历到一个结点时是不知道父节点是什么值的，因此遍历的时候要<strong>保存结点</strong><br>3.通过<strong>举例</strong>可以发现，若遍历到子节点这个路径加起来不是某一值时，要回溯到上一个结点，这是利用了<strong>递归的思想</strong><br>4.此时要在保存结点计算路径值的和中删除掉这个结点，重新加上后面遍历的结点，因此保存结点的数据结构实际上是一个<strong>栈</strong>，因为<strong>递归调用的本质就是一个压栈和出栈的过程</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; sumPath;  <span class="comment">//使用一个二维栈保存多个结果序列</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; findPath(BinaryTreeNode* root,<span class="keyword">int</span> target)</span><br><span class="line">&#123;   </span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">  dfs(root,target,<span class="number">0</span>,path);</span><br><span class="line">  <span class="keyword">return</span> sumPath;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(BinaryTreeNode* node,<span class="keyword">int</span> target,<span class="keyword">int</span> curSum,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(node==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">  curSum=curSum+node-&gt;val;  <span class="comment">//1.前序遍历</span></span><br><span class="line">  path.push_back(node-&gt;val);  <span class="comment">//2.保存结点</span></span><br><span class="line">  <span class="comment">//遍历到根节点时 查看是否满足条件 满足则将这个序列放入结果序列中</span></span><br><span class="line">  <span class="keyword">if</span>(curSum==target &amp;&amp; node-&gt;left==<span class="literal">NULL</span> &amp;&amp; node-&gt;right==<span class="literal">NULL</span>) sumPath.push_back(path);</span><br><span class="line">  <span class="keyword">else</span> &#123;  <span class="comment">//遍历到中间结点时继续遍历</span></span><br><span class="line">      dfs(node-&gt;left,target,curSum,path);  <span class="comment">//3.递归 遍历左结点</span></span><br><span class="line">      dfs(node-&gt;right,target,curSum,path);   <span class="comment">//3.递归 遍历右结点</span></span><br><span class="line">  &#125;</span><br><span class="line">  path.pop_back();  <span class="comment">//遍历到根节点时不满足则去掉这个结点重新回溯</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><br><p id="a26"></p><br><font size="5"><strong>面试题 26：复杂链表的复制</strong></font><br><img src="/images/mianshi26.png" alt=""><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ComplexListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  ComplexListNode* next=<span class="literal">NULL</span>;</span><br><span class="line">  ComplexListNode* sibling=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><font color="blue"><strong>解题思路：拆分：1.插入新节点+2.建立sibling连接+3.拆分</strong></font><br><img src="/images/jiqiao26.png" alt=""><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ComplexListNode* <span class="title">cloneComplexListNode</span><span class="params">(ComplexListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//有效性检测</span></span><br><span class="line">  <span class="keyword">if</span>(head==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="comment">//1.插入新节点:在每个结点后面新建新节点</span></span><br><span class="line">  ComplexListNode* cur=head;</span><br><span class="line">  <span class="keyword">while</span>(cur!=<span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    ComplexListNode* cloneNode=<span class="keyword">new</span> ComplexListNode();</span><br><span class="line">    cloneNode-&gt;val=cur-&gt;val;</span><br><span class="line">    cloneNode-&gt;next=cur-&gt;next;</span><br><span class="line">    cur-&gt;next=clone;</span><br><span class="line">    cur=clone-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//2.建立sibling连接:将新节点的sibling接到原结点的sibling-&gt;next</span></span><br><span class="line">  cur=head;</span><br><span class="line">  <span class="keyword">while</span>(cur!=<span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    ComplexListNode* clone=cur-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(cur-&gt;sibling!=<span class="literal">NULL</span>) clone-&gt;sibling=cur-&gt;sibling-&gt;next;</span><br><span class="line">    cur=clone-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//3.拆分:奇数偶数位置上的结点拆分成两个链表</span></span><br><span class="line">  cur=head;</span><br><span class="line">  ComplexListNode* cloneHead=head-&gt;next;</span><br><span class="line">  <span class="keyword">while</span>(cur-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    ComplexListNode next=cur-&gt;next;</span><br><span class="line">    cur-&gt;next=next-&gt;next;</span><br><span class="line">    cur=next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> cloneHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><p id="a27"></p><br><font size="5"><strong>面试题 27：二叉搜索树与双向链表</strong></font><br><img src="/images/mianshi27.png" alt=""><br><img src="/images/mianshi27+.png" alt=""><br><font color="blue"><strong>解题思路：搜索树特点+中序遍历+vector存储</strong></font><br>1.搜索树特点+中序遍历：结合搜索树特点，<strong>根节点的值大于左子树的值小于右子树的值</strong>，使用<strong>中序遍历</strong>刚好遍历的结点符合这个规律<br>2.vector存储：使用vector将中序遍历的节点存储之后再进行相应处理<br><img src="/images/jiqiao27.jpg" alt=""><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;BinaryTreeNode*&gt; inOrderVector;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrderToVector</span><span class="params">(BinaryTreeNode* root)</span>  <span class="comment">//1.将前序遍历的节点存储至Vector中</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (root-&gt;left) inOrderToVector(root-&gt;left);</span><br><span class="line">  inOrderVector.push_back(root);</span><br><span class="line">  <span class="keyword">if</span> (root-&gt;right) inOrderToVector(root-&gt;right);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">changeVectorNode</span><span class="params">(BinaryTreeNode* root)</span>  <span class="comment">//2.将Vector中的结点进行处理</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  inOrderToVector(root);</span><br><span class="line">  <span class="keyword">int</span> n = inOrderVector.size();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; i != n - <span class="number">1</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        inOrderVector[i]-&gt;left = inOrderVector[i - <span class="number">1</span>];</span><br><span class="line">        inOrderVector[i]-&gt;right = inOrderVector[i + <span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>) inOrderVector[i]-&gt;right = inOrderVector[i + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i == n - <span class="number">1</span>)inOrderVector[i]-&gt;left = inOrderVector[i - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><br><p id="a28"></p><br><font size="5"><strong>面试题 28：字符串的排列</strong></font><br><img src="/images/mianshi28.png" alt=""><br><font color="blue"><strong>解题思路：</strong></font>


<p></p><p id="a29"></p><p></p>
<p><font size="5"><strong>面试题 29：数组中出现次数超过一半的数字</strong></font><br><img src="/images/mianshi29.png" alt=""></p>
<p><font color="blue"><strong>解题思路：摩尔投票算法</strong></font><br>对于大多数<strong>投票</strong>问题，可以采用摩尔投票算法(Boyer-Moore Majority Vote Algorithm )，<strong>使得时间复杂度为 O(n)</strong><br><strong>摩尔投票算法</strong>：<br>1.设置变量majority存储多数元素和count存储此元素的投票数<br>2.遍历数组，若count=0，则majority设为当前数组元素，count++<br>3.遍历数组，若count!=0，则比较majority与当前数组元素，若相等则count++，若不相等则count–<br>4.检测：若数组中超过半数的元素值不存在，则majority返回随机一个元素，因此需要检测<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">moreThanHalf</span><span class="params">(<span class="keyword">int</span>* <span class="built_in">array</span>,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//有效性检测</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">array</span>==<span class="literal">NULL</span> || length&lt;=<span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> exception(<span class="string">"input is invalid!"</span>);</span><br><span class="line">  <span class="comment">//摩尔投票算法</span></span><br><span class="line">  <span class="keyword">int</span> majority=<span class="built_in">array</span>[<span class="number">0</span>],count=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;length;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(count!=<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(majority==<span class="built_in">array</span>[i]) count++;</span><br><span class="line">      <span class="keyword">else</span> count--;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      majority=<span class="built_in">array</span>[i];</span><br><span class="line">      count=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//4.检测</span></span><br><span class="line">  count=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(majority==<span class="built_in">array</span>[i]) count++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> count&gt;length/<span class="number">2</span>?majority:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p></p><p id="a30"></p><p></p>
<p><font size="5"><strong>面试题 30：最小的K个数</strong></font><br><img src="/images/mianshi30.png" alt=""></p>
<p><font color="blue"><strong>解题思路：快速排序中的分区函数/容器思想</strong></font><br>1.<strong>对输入的n个数排序：</strong>排序之后位于最前面的k个数就是最小的k个数，时间复杂度为O(nlongn)<br>2.<strong>快速排序中的分区函数：</strong>有限制条件，只有<font color="red"><strong>允许修改输入数组时可用</strong></font>，基于第k个数来调整，使<strong>比k个数字小的所有数字位于数组左边</strong>，<strong>比k个数字大的数字位于数组右边</strong>，这样数字左边的k个数字就是最小的k个数字(<strong>乱序</strong>)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span>* input,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span>  <span class="comment">//分区函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i=start,j=end,x=input[start];</span><br><span class="line">  <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j &amp;&amp; input[j]&gt;=x) j--;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;j) input[i++]=input[j];</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j &amp;&amp; input[i]&lt;=x) i++;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;j) input[j--]=input[i];</span><br><span class="line">  &#125;</span><br><span class="line">  input[i]=x;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getLeastNumbers</span><span class="params">(<span class="keyword">int</span>* input,<span class="keyword">int</span> n,<span class="keyword">int</span>* output,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//有效性检测</span></span><br><span class="line">  <span class="keyword">if</span>(input==<span class="literal">NULL</span> || output==<span class="literal">NULL</span> || n&lt;=<span class="number">0</span> || k&gt;n || k&lt;=<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> start=<span class="number">0</span>,end=n<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">int</span> index=Partition(input,start,end);</span><br><span class="line">  <span class="keyword">while</span>(index!=k<span class="number">-1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(index&gt;k<span class="number">-1</span>)  <span class="comment">//若得到正确位置的元素位置大于k-1，则需要在其左分区继续找k-1位置</span></span><br><span class="line">    &#123;</span><br><span class="line">      end=index<span class="number">-1</span>;</span><br><span class="line">      index=Partition(input,start,end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">//若得到正确位置的元素位置小于k-1，则需要在其右分区继续找k-1位置</span></span><br><span class="line">    &#123;</span><br><span class="line">      start=index+<span class="number">1</span>;</span><br><span class="line">      index=Partition(input,start,end);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++) output[i]=input[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>3.<strong>容器k：</strong>使用大小为k的数据容器存储最小的k个数字，遍历数组。<br>若容器<strong>未满时则填入容器</strong><br>若容器满了，则<strong>比较容器中最大的数和遍历到的数字</strong>，若容器中最大的数小于遍历的数字则继续遍历，若大于则删除这个数字填入遍历的数字<br>这个容器的数据结构可以采用<strong>最大堆</strong>或者<strong>红黑树</strong><br><img src="/images/jiqiao29.png" alt=""></p>
<p></p><p id="a31"></p><p></p>
<p><font size="5"><strong>面试题 31：连续子数组的最大和</strong></font><br><img src="/images/mianshi31.png" alt=""></p>
<p><font color="blue"><strong>解题思路：举例+动态规划</strong></font><br>1.<strong>举例：</strong>我们可以遍历数组，从数组第一个元素开始，分别计算<strong>最大子数组的和</strong>和<strong>累加子数组的和</strong><br>1.1累加子数组的和可以小于最大子数组的和，但若大于最大子数组的和就会<strong>刷新最大子数组的和</strong><br>1.2最大子数组的和为遇到的子数组的最大值<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findGreastestSumOfSubArray</span><span class="params">(<span class="keyword">int</span>* <span class="built_in">array</span>,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">array</span>==<span class="literal">NULL</span> || length&lt;=<span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> exception(<span class="string">"input is invalid!"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> curSum=<span class="number">0</span>;</span><br><span class="line">  <span class="comment">//累加子数组初始化为最大负数，不能初始化为0，防止数组全为负数的情况</span></span><br><span class="line">  <span class="keyword">int</span> greastestSum=<span class="number">0x80000000</span>; </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(curSum&lt;=<span class="number">0</span>) curSum=<span class="built_in">array</span>[i];  <span class="comment">//若此时累加子数组的和小于0，则重新初始化</span></span><br><span class="line">    <span class="keyword">else</span> curSum=curSum+<span class="built_in">array</span>[i];  <span class="comment">//若此时累加子数组的和大于0，则加上当前值</span></span><br><span class="line">    <span class="keyword">if</span>(curSum&gt;greastestSum) greastestSum=curSum; <span class="comment">//刷新最大子数组的和</span></span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> greastestSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>2.<strong>动态规划：</strong>针对第i个数字结尾的子数组，当其前面的子数组的数字和小于0时，此时第i个数字结尾的子数组就是第i个数字本身，若前面的子数组所有数字大于0，则与其相加<br><img src="/images/jiqiao31.png" alt=""></p>
<p></p><p id="a32"></p><p></p>
<p><font size="5"><strong>面试题 32：从1到n整数中1出现的次数</strong></font><br><img src="/images/mianshi32.png" alt=""></p>
<p><font color="blue"><strong>解题思路：<a href="https://leetcode.com/problems/number-of-digit-one/discuss/64381" target="_blank" rel="noopener">参考这里</a></strong></font><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">1</span>; m &lt;= n; m *= <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = n / m, b = n % m;</span><br><span class="line">        cnt += (a + <span class="number">8</span>) / <span class="number">10</span> * m + (a % <span class="number">10</span> == <span class="number">1</span> ? b + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p></p><p id="a33"></p><p></p>
<p><font size="5"><strong>面试题 33：把数组排成最小的数</strong></font><br><img src="/images/mianshi33.png" alt=""></p>
<p><font color="blue"><strong>解题思路：比较规则+大数问题(字符串比较)</strong></font><br>1.<strong>比较规则</strong>：若给出两个数字x、y，我们需要确定一个规则判断<strong>xy和yx哪个大</strong>，而不是比较x、y哪个大<br>2.<strong>大数问题(字符串比较)</strong>：x、y为int，但是xy或者yx可能会<strong>溢出</strong>，因此这是一个隐形的大数问题，解决方法时<strong>将数字转换成字符串</strong>，此时比较xy和yx就可以按照字符串大小比较就可以了<br>3.<strong>字符串格式化</strong>：将<strong>格式化的数据写入字符串的函数sprintf(char* str,char* format[,argument])</strong>，str为被写入的字符串，format为格式化字符串，argument为被格式化的变量，常用将<strong>整数打印到字符串中</strong>，如<br><strong>sprintf(s, “%d”, 123); </strong> 把整数123打印成一个字符串保存在s中<br><strong>sprintf(s, “%8x”, 4567);</strong>  小写16进制，宽度占8个位置，右对齐<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数字最长位数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxNumberLength=<span class="number">10</span>;</span><br><span class="line"><span class="comment">//自定义比较规则</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* x,<span class="keyword">const</span> <span class="keyword">void</span>* y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span>* xy=<span class="keyword">new</span> <span class="keyword">char</span>[MaxNumberLength*<span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line">  <span class="built_in">strcpy</span>(xy,*(<span class="keyword">const</span> <span class="keyword">char</span>**)x);  <span class="comment">// 复制x到xy中</span></span><br><span class="line">  <span class="built_in">strcat</span>(xy,*(<span class="keyword">const</span> <span class="keyword">char</span>**)y);  <span class="comment">//将y连接到xy后</span></span><br><span class="line">  <span class="keyword">char</span>* yx=<span class="keyword">new</span> <span class="keyword">char</span>[MaxNumberLength*<span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line">  <span class="built_in">strcpy</span>(yx,*(<span class="keyword">const</span> <span class="keyword">char</span>**)y);</span><br><span class="line">  <span class="built_in">strcat</span>(yx,*(<span class="keyword">const</span> <span class="keyword">char</span>**)x);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strcmp</span>(xy,yx);  <span class="comment">//比较字符串大小</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMinNumber</span><span class="params">(<span class="keyword">int</span>* numbers,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//输入有效性检测</span></span><br><span class="line">  <span class="keyword">if</span>(numbers==<span class="literal">NULL</span> || length&lt;=<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//用于保存字符数组的数组</span></span><br><span class="line">  <span class="keyword">char</span>** strNumbers=(<span class="keyword">char</span>**)(<span class="keyword">new</span> <span class="keyword">int</span>[length]); </span><br><span class="line"></span><br><span class="line">  <span class="comment">//for循环将数字格式化存储至数组中</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    strNumbers[i]=<span class="keyword">new</span> <span class="keyword">char</span>[MaxNumberLength+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(strNumbers[i],<span class="string">"%d"</span>,numbers[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//对数组中的字符数组用自定义的规则排序</span></span><br><span class="line">  qsort(strNumbers,length,<span class="keyword">sizeof</span>(<span class="keyword">char</span>*),compare);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//格式化输出并释放空间</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;strNumbers[i];</span><br><span class="line">    <span class="keyword">delete</span>[] strNumbers[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span>[] strNumbers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p></p><p id="a34"></p><p></p>
<p><font size="5"><strong>面试题 34：丑数</strong></font><br><img src="/images/mianshi34.png" alt=""></p>
<p><font color="blue"><strong>解题思路：空间换时间(创建数组保存已找到的丑数)</strong></font><br>1.<strong>丑数特点</strong>：根据定义，丑数应该是另一个丑数乘2、3、5的结果<br>2.<strong>创建数组存储已找到的丑数</strong>：将数组的丑数排序，每一个丑数是前面的丑数乘以2、3、5得到的<br>3.<strong>丑数排序</strong>，已有数组的最大丑数设为M，将之前的每个丑数乘2中的<strong>大于M的最小值</strong>记作M2，乘3乘5的大于M的最小值记作M3、M5，则下一个丑数为M2、M3、M5中的最小值<br>4.<strong>优化</strong>：并不需要之前的<strong>每一个丑数</strong>都作乘法，只需要其找到其中的阈值T2，T3，T5，T前的丑数乘对应数字小于M，T后的丑数乘对应数字大于M<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(n&lt;=<span class="number">6</span>) <span class="keyword">return</span> n;  <span class="comment">//1,2,3,4,5,6均为丑数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> *uglyNumbers=<span class="keyword">new</span> <span class="keyword">int</span>[n];  <span class="comment">//创建存储丑数的数组</span></span><br><span class="line">  uglyNumbers[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> curNumber=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> t2=<span class="number">0</span>,t3=<span class="number">0</span>,t5=<span class="number">0</span>;  <span class="comment">//阈值下标</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(curNumber&lt;n)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> m2=uglyNumbers[t2]*<span class="number">2</span>;  <span class="comment">//通过2的阈值下标找到2的阈值</span></span><br><span class="line">    <span class="keyword">int</span> m3=uglyNumbers[t3]*<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> m5=uglyNumbers[t5]*<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> min=min(m2, min(m3, m5));</span><br><span class="line">    uglyNumbers[curNumber]=min;  <span class="comment">//最小的数存入数组</span></span><br><span class="line">    curNumber++;</span><br><span class="line">    <span class="keyword">if</span>(min==m2) t2++;  <span class="comment">//最小的数属于乘2找到的，则2的阈值下标加1</span></span><br><span class="line">    <span class="keyword">if</span>(min==m3) t3++;</span><br><span class="line">    <span class="keyword">if</span>(min==m5) t5++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> ugly=uglyNumbers[n<span class="number">-1</span>];</span><br><span class="line">  <span class="keyword">delete</span>[] uglyNumbers;</span><br><span class="line">  <span class="keyword">return</span> ugly;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p></p><p id="a35"></p><p></p>
<p><font size="5"><strong>面试题 35：第一个只出现一次的字符</strong></font><br><img src="/images/mianshi35.png" alt=""></p>
<p><font color="blue"><strong>解题思路：哈希表</strong></font><br>1.由于题目与字符有关，我们需要统计<strong>字符在字符串出现的次数</strong>，需要一个数据容器存放每个字符出现的次数，也就是说这个容器的作用是<strong>将一个字符映射成一个数字</strong>，哈希表正是这个用途<br>2.定义哈希表的<strong>键值(Key)为字符</strong>，而<strong>值(Value)为字符出现的次数</strong><br>3.扫描字符串两次，第一次每扫描到一个字符就在哈希表对应项次数加1，第二次扫描出第一个出现1次的字符<br>4.<strong>实现哈希表</strong>：<strong>字符(char)</strong>是一个<strong>长度为8</strong>的数据类型，因此共有2^8=256种可能，于是可以创建一个长度为<strong>256的数组</strong>，每个字符根据其<strong>ASCII码值作为数组下标对应的数字是其出现的次数</strong><br>5.时间复杂度：若字符串长度为n，第一次扫描的时间复杂度为O(n)，第二次扫描的时间复杂度也是O(n)，于是中的时间复杂度也是O(n)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">firstCharInStr</span><span class="params">(<span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(str==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="string">'\0'</span>;</span><br><span class="line">  <span class="comment">//创建哈希表</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> tableSize=<span class="number">256</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> hashTable[tableSize];</span><br><span class="line">  <span class="comment">//初始化哈希表</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tableSize;i++)</span><br><span class="line">    hashTable[i]=<span class="number">0</span>;</span><br><span class="line">  <span class="comment">//第一次遍历，将遍历到的字符以字符的ASCII码作为下标的数组值加1</span></span><br><span class="line">  <span class="keyword">char</span>* hashKey=str;</span><br><span class="line">  <span class="keyword">while</span>(*(hashKey)!=<span class="string">'\0'</span>)</span><br><span class="line">    hashTable[*(hashKey++)] ++;</span><br><span class="line">  <span class="comment">//第二次遍历，找到第一个出现1次的字符</span></span><br><span class="line">  hashKey=str;</span><br><span class="line">  <span class="keyword">while</span>(*(hashKey)!=<span class="string">'\0'</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(hashTable[*hashKey]==<span class="number">1</span>) <span class="keyword">return</span> *hashKey;</span><br><span class="line">    hashKey++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p></p><p id="a36"></p><p></p>
<p><font size="5"><strong>面试题 36：数组中的逆序对</strong></font><br><img src="/images/mianshi.png" alt=""></p>
<p><font color="blue"><strong>解题思路：归并排序时统计</strong></font><br>1.<strong>分解数组</strong>：将数组分解直至长度为1的子数组<br>2.<strong>统计、合并、排序数组</strong>：<br><strong>统计数组：</strong>申明P1、P2指向两个子数组的头部，P3指向归并数组的头部，只有*P1&gt;*P2时需要统计，逆序数统计数增加子数组P1到末尾的元素数量，因为*P1后的元素均大于*P1，于是均与*P2形成逆序对<br><strong>合并数组：</strong>若*P1&gt;*P2，<strong>统计完成</strong>后*P3=*P2，P2++，P3++，继续比较*P1和*P2；若<em>P1&lt;\</em>P2，则<strong>无需统计</strong>，*P3=*P1，P1++，P3++，继续比较*P1和*P2<br><strong>排序数组：</strong>合并完成的数组就是已经排序好的数组，排序数组是因为<strong>避免在下次的统计过程中重复统计</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不要使用count名，因为std空间下也有count变量会指代不明，若要使用则要用::count形式</span></span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="keyword">int</span>* <span class="built_in">array</span>,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//有效性检测</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">array</span>==<span class="literal">NULL</span> || length&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//创建辅助空间</span></span><br><span class="line">  <span class="keyword">int</span>* temp=<span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">  split(<span class="built_in">array</span>,<span class="number">0</span>,length<span class="number">-1</span>,temp);</span><br><span class="line">  <span class="keyword">delete</span>[] temp;</span><br><span class="line">  <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1.分解数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span>* <span class="built_in">array</span>,<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">int</span>* temp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(end-start&lt;<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">int</span> mid=start+(end-start)/<span class="number">2</span>;  <span class="comment">//不要用(start+end)/2溢出风险</span></span><br><span class="line">  split(<span class="built_in">array</span>,start,mid,temp);</span><br><span class="line">  split(<span class="built_in">array</span>,mid+<span class="number">1</span>,end,temp);</span><br><span class="line">  merge(<span class="built_in">array</span>,start,mid,end,temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.统计合并排序数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>* <span class="built_in">array</span>,<span class="keyword">int</span> start,<span class="keyword">int</span> mid,<span class="keyword">int</span> end,<span class="keyword">int</span>* temp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> p1=start,p2=mid+<span class="number">1</span>,p3=start;</span><br><span class="line">  <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">  <span class="comment">//合并数组</span></span><br><span class="line">  <span class="keyword">while</span>(p1&lt;=mid &amp;&amp; p2&lt;=end)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//有等于的情况则不能使用这个方法了</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">array</span>[p1]&lt;<span class="built_in">array</span>[p2]) temp[k++]=<span class="built_in">array</span>[p1++];</span><br><span class="line">    <span class="keyword">else</span> &#123; </span><br><span class="line">      cnt=cnt+mid-p1+<span class="number">1</span>;  <span class="comment">//统计逆序对</span></span><br><span class="line">      temp[k++]=<span class="built_in">array</span>[p++];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(p1&lt;=mid) temp[k++]=<span class="built_in">array</span>[p1++];</span><br><span class="line">  <span class="keyword">while</span>(p2&lt;=end) temp[k++]=<span class="built_in">array</span>[p2++];</span><br><span class="line">  <span class="comment">//排序数组</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">    <span class="built_in">array</span>[start+i]=temp[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p></p><p id="a37"></p><p></p>
<p><font size="5"><strong>面试题 37：两个链表的第一个公共节点</strong></font><br><img src="/images/mianshi37.png" alt=""></p>
<p><font color="blue"><strong>解题思路：公共结点链表特点+栈</strong></font><br>1.若两个链表有公共结点，则它们公共结点后的节点是相同的，<strong>拓扑结构是Y而不是X</strong><br><img src="/images/jiqiao37.png" alt=""><br>2.栈：因为公共结点后的节点是相同的，我们想<strong>从尾遍历两个链表</strong>，直到遍历到的节点不一样时，其后一个结点就是<strong>第一个公共节点</strong>，然而链表只能从前往后遍历，因此我们需要使用<strong>栈存储两个链表来实现从尾遍历链表</strong><br>3.时间复杂度：若两个链表长度为m、n，则暴力破解时间复杂度为O(mn)，栈遍历为O(m+n)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">stack</span>&lt;ListNode*&gt; list1,list2;</span><br><span class="line"><span class="function">ListNode* <span class="title">findFirstCommonNode</span><span class="params">(ListNode* head1,ListNode* head2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ListNode* l1=head1,l2=head2;</span><br><span class="line">  <span class="keyword">while</span>(l1!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    list1.push(l1);</span><br><span class="line">    l1=l1-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(l2!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    list2.push(l2);</span><br><span class="line">    l2=l2-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  ListNode* firstCommonNode=<span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">while</span>(list1.top()==list2.top())</span><br><span class="line">  &#123;</span><br><span class="line">    firstCommonNode=list1.top();</span><br><span class="line">    list1.pop();</span><br><span class="line">    list2.pop();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> firstCommonNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p></p><p id="a38"></p><p></p>
<p><font size="5"><strong>面试题 38：数字在排序数组中出现的次数</strong></font><br><img src="/images/mianshi38.png" alt=""></p>
<p><font color="blue"><strong>解题思路：二分查找法</strong></font><br>1.由于输入数组是<strong>排序的</strong>，我们很自然想到利用二分查找算法<br>2.寻找数组中<strong>第一个数字k和最后一个数字k</strong>，它们的下标作简单的处理就能得出数组中有几个k<br>3.找第一个数字k和最后一个数字k可使用<strong>二分查找法</strong>，第一个k的特点是<strong>上一个数字小于k下一个数字等于k</strong>，最后一个k的特点是<strong>下一个数数字大于k上一个数字等于k</strong><br>4.注意<strong>边界检测(k为第一个和最后一个元素)</strong>和<strong>有效性检测(k不在数组中)</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNumberOfK</span><span class="params">(<span class="keyword">int</span>* <span class="built_in">array</span>, <span class="keyword">int</span> length, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//有效性检测</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">array</span> == <span class="literal">NULL</span> || length &lt;= <span class="number">0</span> || k&lt;<span class="built_in">array</span>[<span class="number">0</span>] || k&gt;<span class="built_in">array</span>[length<span class="number">-1</span>]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> start = <span class="number">0</span>, end = length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> cur = (start+end)/ <span class="number">2</span>;</span><br><span class="line">  <span class="comment">//找第一个k 注意边界检测 k为第一个元素</span></span><br><span class="line">  <span class="keyword">while</span> (cur!=<span class="number">0</span> &amp;&amp; cur!=length<span class="number">-1</span>)</span><br><span class="line">  &#123; </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">array</span>[cur] == k &amp;&amp; <span class="built_in">array</span>[cur - <span class="number">1</span>]&lt;k) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">array</span>[cur]&lt;k) start = cur+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">array</span>[cur]&gt;=k) end = cur<span class="number">-1</span>;</span><br><span class="line">    cur = (start + end) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"cur1:"</span> &lt;&lt; cur &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> startK = cur;</span><br><span class="line">  start = <span class="number">0</span>;</span><br><span class="line">  end = length - <span class="number">1</span>;</span><br><span class="line">  cur = (start + end) / <span class="number">2</span>;</span><br><span class="line">  <span class="comment">//找最后一个k 注意边界检测 k为最后一个元素</span></span><br><span class="line">  <span class="keyword">while</span> (cur!=<span class="number">0</span> &amp;&amp; cur!=length<span class="number">-1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">array</span>[cur] == k &amp;&amp; <span class="built_in">array</span>[cur + <span class="number">1</span>]&gt;k) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">array</span>[cur]&lt;=k) start = cur+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">array</span>[cur]&gt;k) end = cur<span class="number">-1</span>;</span><br><span class="line">    cur = (start + end) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"cur2:"</span> &lt;&lt; cur &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> endK = cur;</span><br><span class="line">  <span class="keyword">return</span> endK - startK + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p></p><p id="a39"></p><p></p>
<p><font size="5"><strong>面试题 39：二叉树的深度</strong></font><br><img src="/images/mianshi39.png" alt=""></p>
<p><font color="blue"><strong>解题思路：递归分治</strong></font><br><strong>递归分治：</strong>：用递归的思想遍历二叉树，用分治的思想理解<strong>二叉树某个节点的深度是max(左子树的深度，右子树的深度)+1</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(BinaryTreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>+max(TreeDepth(root-&gt;left),TreeDepth(root-&gt;right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="/images/mianshi39+.png" alt=""></p>
<p><font color="blue"><strong>解题思路：后续遍历</strong></font><br><strong>后续遍历：</strong>我们在遍历某个节点时，<strong>已经遍历了它的左右子节点了</strong>，这时我们只需要根据它的<strong>左右子节点的深度</strong>判断这个节点是否平衡，并得到这个<strong>节点的深度</strong>，对于判断这个节点的父节点是不是平衡的有关键作用<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsBalancedTree</span><span class="params">(BinaruTreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> depth=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> IsBalanceNode(root,&amp;depth);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsBalanceNode</span><span class="params">(BinaruTreeNode* root,<span class="keyword">int</span>* depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//遍历到叶子节点的子节点时，深度设为0，返回叶子节点</span></span><br><span class="line">  <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    *depth=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//左子树深度和右子树深度</span></span><br><span class="line">  <span class="keyword">int</span> left,right;</span><br><span class="line">  <span class="comment">//若左右子树平衡时，会返回左右子树的深度和true</span></span><br><span class="line">  <span class="keyword">if</span>(IsBalanceNode(root-&gt;left,&amp;left) &amp;&amp; IsBalanceNode(root-&gt;right,&amp;right))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//计算左右子树的深度差</span></span><br><span class="line">    <span class="keyword">int</span> diff=left-right;</span><br><span class="line">    <span class="comment">//深度差的绝对值在1以内 则平衡，返回这个节点的深度和true</span></span><br><span class="line">    <span class="keyword">if</span>(diff&lt;=<span class="number">1</span> &amp;&amp; diff&gt;=<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      *depth=<span class="number">1</span>+(left&gt;right?left:right);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//若左右子树不平衡或者这个节点不平衡，直接返回false</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p></p><p id="a40"></p><p></p>
<p><font size="5"><strong>面试题 40：数组中只出现一次的数字</strong></font><br><img src="/images/mianshi40.png" alt=""></p>
<p><font color="blue"><strong>解题思路：分治+异或运算</strong></font><br><strong>分治：</strong>先考虑数组中<strong>只有一个只出现一次</strong>的数字<br><strong>异或运算：</strong>x不等于y，则x^y等于1；x等于y，则x^y等于0<br><strong>异或求解思路：</strong>将数组的所有元素异或得到的结果为不存在重复的两个元素异或的结果<br><strong>分治思路：</strong>两个不相等的元素在位级表示上必定会有一位存在不同，数组异或的结果为两个只出现一次元素异或的结果，只需要找到<strong>异或结果中最右侧不为0的位</strong>，可利用这一位区分出这两个数(这两个数这一位一定不等),之后将<strong>数组分为两个数组</strong>，分别求解出每个数组中不同的那个数即可<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindNumOnce</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[],<span class="keyword">int</span> length,<span class="keyword">int</span>* num1,<span class="keyword">int</span>* num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//有效性检测</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">array</span>==<span class="literal">NULL</span> || length&lt;<span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">//数组中所有数异或运算，得到只出现一次的两个元素异或的结果</span></span><br><span class="line">  <span class="keyword">int</span> resultOR=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++) resultOR=resultOR^<span class="built_in">array</span>[i];</span><br><span class="line">  <span class="comment">//找到结果中最右侧不为0的位(即最右侧为1的位)</span></span><br><span class="line">  resultOR=resultOR &amp; (-resultOR);</span><br><span class="line">  <span class="comment">//将数组分成两个部分分别进行异或运算</span></span><br><span class="line">  *num1=*num2=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>((<span class="built_in">array</span>[i]&amp;resultOR)==<span class="number">0</span>) num1=num1^<span class="built_in">array</span>[i];</span><br><span class="line">    <span class="keyword">else</span> num2=num2^<span class="built_in">array</span>[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p></p><p id="a41"></p><p></p>
<p><font size="5"><strong>面试题 41：和为S的两个数字/和为S的连续正数序列</strong></font><br><img src="/images/mianshi41.png" alt=""></p>
<p><font color="blue"><strong>解题思路：根据结果修正</strong></font><br><strong>根据结果修正：</strong>由于数组是<strong>排序的</strong>，因此可以根据两个数字的和与S大小比较<strong>调整组成元素的大小</strong><br><strong>具体实现：</strong>申明两个指针start、end指向数组头和尾，若指针所指元素的和下于S，则证明需要增大和，则可以start++，因为数组是排序的，所以array[++start]&gt;array[start]，若和小于S，则需要减小和，可以end–，同理因为array[–end]<array[end] <figure="" class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">FindNumberWithSum</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[],<span class="keyword">int</span> length,<span class="keyword">int</span> sum,<span class="keyword">int</span>* num1,<span class="keyword">int</span>* num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">bool</span> result=<span class="literal">false</span>;</span><br><span class="line">  <span class="comment">//有效性检测</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">array</span>==<span class="literal">NULL</span> || length&lt;<span class="number">2</span> || num1==<span class="literal">NULL</span> || num2==<span class="literal">NULL</span> || sum&gt;<span class="number">2</span>*<span class="built_in">array</span>[length<span class="number">-1</span>] || sum&lt;<span class="number">2</span>*<span class="built_in">array</span>[<span class="number">0</span>]) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> start=<span class="number">0</span>,end=length<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">while</span>(start&lt;end)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">array</span>[start]+<span class="built_in">array</span>[end]&lt;sum) start++;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">array</span>[start]+<span class="built_in">array</span>[end]&gt;sum) end--;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">array</span>[start]+<span class="built_in">array</span>[end]==sum)</span><br><span class="line">    &#123;</span><br><span class="line">      *num1=<span class="built_in">array</span>[start];</span><br><span class="line">      *num2=<span class="built_in">array</span>[end];</span><br><span class="line">      result=<span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table><br><img src="/images/mianshi41+.png" alt=""></array[end]></p>
<p><font color="blue"><strong>解题思路：根据结果修正</strong></font><br><strong>根据结果修正：</strong>由于数组是<strong>排序的</strong>，因此可以根据包含的数字的和与S比大小<strong>调整包含元素多少</strong><br><strong>具体实现：</strong>申明两个指针start、end指向数组第一二个元素，若和小于S，则end++，包含多一个元素增大和，若和大于S，则start++，剔除最小的元素减小和，若和等于S，打印序列并且end++继续遍历<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindSumInSequence</span><span class="params">(<span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(sum&lt;<span class="number">3</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">int</span> start=<span class="number">1</span>,end=<span class="number">2</span>,curSum=<span class="number">3</span>;</span><br><span class="line">  <span class="keyword">int</span> middle=(sum+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">  <span class="keyword">while</span>(start&lt;=middle &amp;&amp; end&lt;sum)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(curSum&gt;sum) </span><br><span class="line">    &#123;</span><br><span class="line">      curSum=curSum-start;  <span class="comment">//和减小</span></span><br><span class="line">      start++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(curSum&lt;sum) </span><br><span class="line">    &#123;</span><br><span class="line">      end++;</span><br><span class="line">      curSum=curSum+end;  <span class="comment">//和增加</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(curSum==sum)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=end;i++) <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;ends;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">      end++;</span><br><span class="line">      curSum=curSum+end;  <span class="comment">//和增加</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p></p><p id="a42"></p><p></p>
<p><font size="5"><strong>面试题 42：反转单词顺序/左旋转字符串</strong></font><br><img src="/images/mianshi42.png" alt=""></p>
<p><font color="blue"><strong>解题思路：反转句子+反转单词</strong></font><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverseStr</span><span class="params">(<span class="keyword">char</span>* str,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(start&lt;end)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="keyword">char</span> temp = str[start];</span><br><span class="line">   str[start] = str[end];</span><br><span class="line">   str[end] = temp;</span><br><span class="line">   start++;</span><br><span class="line">   end--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReverseStentence</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(str==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> end=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(str[end]!=<span class="string">'\0'</span>) end++;</span><br><span class="line">  end--;</span><br><span class="line"></span><br><span class="line">  reverseStr(str,start,end);</span><br><span class="line">  </span><br><span class="line">  start=end=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(str[end]!=<span class="string">' '</span>) end++;</span><br><span class="line">  end--;</span><br><span class="line">  reverseStr(str,start,end);</span><br><span class="line">  <span class="keyword">while</span>(str[start]==<span class="string">'\0'</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span>(str[start]!=<span class="string">' '</span> &amp;&amp; str[start]!=<span class="string">'\0'</span>) start++;</span><br><span class="line">    <span class="keyword">if</span>(str[start]==<span class="string">' '</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      start++;</span><br><span class="line">      end=start;</span><br><span class="line">      <span class="keyword">while</span>(str[end]!=<span class="string">' '</span> &amp;&amp; str[end]!=<span class="string">'\0'</span>) end++;</span><br><span class="line">      end--;</span><br><span class="line">      reverseStr(str,start,end);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="/images/mianshi42+.png" alt=""></p>
<p><font color="blue"><strong>解题思路：三次反转</strong></font><br>上一题加入字符串是”abc def”，翻转后成为了”def abc”，<strong>相当于把前面三个字符串移到后面去了</strong>，类似地，这一题我们也可以如此，如给定”abcxyz”，将K(假设K=3)位左移，变成了”xyzabc”，也可以采取上一题的解法<br><strong>1.字符串分成两部分(前K位和后面位)：</strong>即”abc”和”xyz”<br><strong>2.两部分分别反转：</strong>即”cbazyx”<br><strong>3.整体字符串反转：</strong>即”xyzabc”,前K位就移至后面了<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverseStr</span><span class="params">(<span class="keyword">char</span>* str,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(start&lt;end)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="keyword">char</span> temp = str[start];</span><br><span class="line">   str[start] = str[end];</span><br><span class="line">   str[end] = temp;</span><br><span class="line">   start++;</span><br><span class="line">   end--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LeftRotateStr</span><span class="params">(<span class="keyword">char</span>* str,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (str == <span class="literal">NULL</span> || n &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (str[length] != <span class="string">'\0'</span>) length++;</span><br><span class="line">  <span class="keyword">if</span> (n &gt;= length) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> end = n - <span class="number">1</span>;</span><br><span class="line">  reverseStr(str, start, end);</span><br><span class="line">  start = n;</span><br><span class="line">  end = length - <span class="number">1</span>;</span><br><span class="line">  reverseStr(str, start, end);</span><br><span class="line">  start = <span class="number">0</span>;</span><br><span class="line">  end = length - <span class="number">1</span>;</span><br><span class="line">  reverseStr(str, start, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p></p><p id="a43"></p><p></p>
<p><font size="5"><strong>面试题 43：n个骰子的点数</strong></font><br><img src="/images/mianshi43.png" alt=""></p>
<p><font color="blue"><strong>解题思路：动态规划(递归/迭代)</strong></font><br>动态规划：将问题分为<strong>不同的阶段的问题</strong>，根据<strong>开始阶段已知的问题答案</strong>，逐步推到出最终答案，通常基于<font color="red"><strong>一个递归公式(状态转移方程)和一个或者多个初始状态</strong></font><br><strong>1.确定问题解的表达形式：</strong>用f(n,s)表示n个骰子点数和为s的<strong>排列情况总数</strong><br><strong>2.递归公式：</strong>将骰子分为1个和n-1个，1个骰子的点数为1-6，若n个骰子点数和为s，则根据1个骰子的点数不同，n-1个骰子的点数也不同，因此有状态转移方程：<br>f(n,s)=f(n-1,s-1)+f(n-1,s-2)+f(n-1,s-3)+f(n-1,s-4)+f(n-1,s-5)+f(n-1,s-6) ，0<s<=6n f(n,s)="0" ，s<0="" ||="" s="">6n<br><strong>3.初始状态：</strong>n=1时，f(1,1)=f(1,2)=f(1,3)=f(1,4)=f(1,5)=f(1,6)=1</s<=6n></p>
<p><font color="red"><strong>递归版本：简洁、低效</strong></font><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSumCount</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//有效性检测，骰子至少为1个，点数和在n-6n之间，否则排列情况数量为0</span></span><br><span class="line">  <span class="keyword">if</span>(n&lt;<span class="number">1</span> || sum&lt;n || sum&gt;<span class="number">6</span>*n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//初始状态</span></span><br><span class="line">  <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//状态转移方程</span></span><br><span class="line">  <span class="keyword">int</span> sumCount=<span class="number">0</span>;</span><br><span class="line">  sumCount=getSumCount(n<span class="number">-1</span>,sum<span class="number">-1</span>)+getSumCount(n<span class="number">-1</span>,sum<span class="number">-2</span>)+</span><br><span class="line">           getSumCount(n<span class="number">-1</span>,sum<span class="number">-3</span>)+getSumCount(n<span class="number">-1</span>,sum<span class="number">-4</span>)+</span><br><span class="line">           getSumCount(n<span class="number">-1</span>,sum<span class="number">-5</span>)+getSumCount(n<span class="number">-1</span>,sum<span class="number">-6</span>);</span><br><span class="line">  <span class="keyword">return</span> sumCount;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printAllSumCount</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//i为n个骰子出现点数和s的所有可能</span></span><br><span class="line">  <span class="comment">//若需要打印出概率可将结果除以6^n</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&lt;=<span class="number">6</span>*n;i++) <span class="built_in">cout</span>&lt;&lt;<span class="string">"fn("</span>&lt;&lt;n&lt;&lt;<span class="string">","</span>&lt;&lt;i&lt;&lt;<span class="string">")="</span>&lt;&lt;getSumCount(n,i)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><font color="red"><strong>迭代版本：从底层开始、高效</strong></font><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getSumCount</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span>* count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n&lt;<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">//初始状态</span></span><br><span class="line">  count[<span class="number">0</span>]=count[<span class="number">1</span>]=count[<span class="number">2</span>]=count[<span class="number">3</span>]=count[<span class="number">4</span>]=count[<span class="number">5</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//从骰子数量为2迭代到骰子数量为n</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//针对骰子数量为i，点数和sum有i到6i种排列可能</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> sum=<span class="number">6</span>*i;sum&gt;=i;sum--)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//针对骰子和为sum，将骰子数量i分为1个和i-1个</span></span><br><span class="line">      <span class="comment">//1个骰子点数可以为1、2、3、4、5、6</span></span><br><span class="line">      <span class="comment">//i-1个骰子的点数和在上次迭代的数组中</span></span><br><span class="line">      <span class="keyword">int</span> minus1=(sum<span class="number">-1</span>-(i<span class="number">-1</span>))&gt;=<span class="number">0</span>?count[sum<span class="number">-1</span>-(i<span class="number">-1</span>)]:<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> minus2=(sum<span class="number">-2</span>-(i<span class="number">-1</span>))&gt;=<span class="number">0</span>?count[sum<span class="number">-2</span>-(i<span class="number">-1</span>)]:<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> minus3=(sum<span class="number">-3</span>-(i<span class="number">-1</span>))&gt;=<span class="number">0</span>?count[sum<span class="number">-3</span>-(i<span class="number">-1</span>)]:<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> minus4=(sum<span class="number">-4</span>-(i<span class="number">-1</span>))&gt;=<span class="number">0</span>?count[sum<span class="number">-4</span>-(i<span class="number">-1</span>)]:<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> minus5=(sum<span class="number">-5</span>-(i<span class="number">-1</span>))&gt;=<span class="number">0</span>?count[sum<span class="number">-5</span>-(i<span class="number">-1</span>)]:<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> minus6=(sum<span class="number">-6</span>-(i<span class="number">-1</span>))&gt;=<span class="number">0</span>?count[sum<span class="number">-6</span>-(i<span class="number">-1</span>)]:<span class="number">0</span>;</span><br><span class="line">      count[sum-i]=minus1+minus2+minus3+minus4+minus5+minus6;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printAllSumCount</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//共有n-6n种排列组合可能，用5n+1大小的数组存储</span></span><br><span class="line">  <span class="keyword">int</span>* count=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>*n+<span class="number">1</span>]</span><br><span class="line">  <span class="comment">//将参数1后的参数2大小空间初始化为参数3</span></span><br><span class="line">  <span class="built_in">memset</span>(count,<span class="number">0</span>,(<span class="number">5</span>*n+<span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">  getSumCount(n,count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p></p><p id="a44"></p><p></p>
<p><font size="5"><strong>面试题 44：扑克牌顺子</strong></font><br><img src="/images/mianshi44.png" alt=""></p>
<p><font color="blue"><strong>解题思路：三重处理</strong></font><br>第一重处理：排序<br>第二重处理：统计0个数<br>第三种处理：统计数组是否连续，若不连续统计空缺数，小于等于0的个数则连续<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isContinuous</span><span class="params">(<span class="keyword">int</span>* numbers,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(numbers==<span class="literal">NULL</span> || length!=<span class="number">5</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">//排序</span></span><br><span class="line">  qsort(numbers,length,<span class="keyword">sizeof</span>(<span class="keyword">int</span>),compare);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//统计0的个数</span></span><br><span class="line">  <span class="keyword">int</span> numOfZero=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++) <span class="keyword">if</span>(numbers[i]==<span class="number">0</span>) numOfZero++;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//统计数组是否连续和空缺数</span></span><br><span class="line">  <span class="keyword">int</span> numOfGap=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=numOfZero;i&lt;length;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers[i]+<span class="number">1</span>==numbers[i+<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(numbers[i]+<span class="number">2</span>==numbers[i+<span class="number">1</span>]) numOfGap++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(numbers[i]+<span class="number">3</span>==numbers[i+<span class="number">1</span>]) numOfGap=numOfGap+<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(numOfGap&lt;=numOfZero) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p></p><p id="a45"></p><p></p>
<p><font size="5"><strong>面试题 45：圆圈中最后剩下的数字</strong></font><br><img src="/images/mianshi45.png" alt=""></p>
<p><font color="blue"><strong>解题思路：环形链表模拟圆圈</strong></font><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">	ListNode* next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LastLeftNumber</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n&lt;<span class="number">1</span> || m&lt;<span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(m==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//利用数组构造环形链表(不可用循环定义链表，无法命名)</span></span><br><span class="line">  ListNode* <span class="built_in">array</span>=<span class="keyword">new</span> ListNode[n];</span><br><span class="line">  <span class="built_in">array</span>[n<span class="number">-1</span>]=<span class="keyword">new</span> ListNode;</span><br><span class="line">  <span class="built_in">array</span>[n<span class="number">-1</span>]-&gt;val=n<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">array</span>[i]=<span class="keyword">new</span> ListNode;</span><br><span class="line">    <span class="built_in">array</span>[i]-&gt;val=i;</span><br><span class="line">    <span class="built_in">array</span>[i]-&gt;next=<span class="built_in">array</span>[i+<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">array</span>[n<span class="number">-1</span>]-&gt;next=<span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//开始删除操作(删除结点的前一个结点next删除结点后一个结点即可)</span></span><br><span class="line">  ListNode* cur=<span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n<span class="number">-2</span>;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> jump=m<span class="number">-2</span>;</span><br><span class="line">    <span class="keyword">while</span>(jump!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      cur=cur-&gt;next;</span><br><span class="line">      jump--;</span><br><span class="line">    &#125;</span><br><span class="line">    cur-&gt;next=cur-&gt;next-&gt;next;</span><br><span class="line">    cur=cur-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cur-&gt;val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</typename>
        </div>
        <footer class="article-footer">
            
    <div class="jiathis_style">
    <span class="jiathis_txt">分享到：</span>
    <a class="jiathis_button_qzone">QQ空间</a>
    <a class="jiathis_button_tsina">新浪微博</a>
    <a class="jiathis_button_tqq">腾讯微博</a>
    <a class="jiathis_button_weixin">微信</a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
    <a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<style>
    .jiathis_style div:first-child:not(.jiadiv_01) {
        width: auto !important;
        border: none !important;
    }
    .jiathis_style .jiadiv_01 {
        margin: 10px 0;
        border-radius: 4px;
        border: #e1e1e1 solid 1px;
    }
    .jiathis_style .jiadiv_01 div:first-child {
        display: none;
    }
    .jiathis_style .jiadiv_02 {
        padding: 7px 0 !important;
    }
    .jiathis_style .jiadiv_02 .jiatitle {
        width: 85px;
        border: none;
        height: auto;
        margin: 3px 10px;
        padding: 6px 10px;
        border-radius: 4px;
    }
    .jiathis_style .jiadiv_02 .jiatitle:hover {
        border: none;
    }
    .jiathis_style .jiadiv_02 .jiatitle:nth-child(even) {
        margin-left: 0;
    }
    .jiathis_style .jtico:hover {
        opacity: 1;
    }
    .jiathis_style .ckepopBottom,
    .jiathis_style .centerBottom {
        width: auto !important;
        padding: 5px;
        background: #f7f7f7;
    }
</style>




        </footer>
    </div>
</article>

    <section id="comments">
    
        
    <div id="disqus_thread">
        <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>

    
    </section>


                        </div>
                    </section>
                    <aside id="sidebar">
    <a class="sidebar-toggle" title="Expand Sidebar"><i class="toggle icon"></i></a>
    <div class="sidebar-top">
        <p>关注我 :</p>
        <ul class="social-links">
            
                
                <li>
                    <a class="social-tooltip" title="envelope" href="mailto:707014137@qq.com" target="_blank">
                        <i class="icon fa fa-envelope"></i>
                    </a>
                </li>
                
            
                
                <li>
                    <a class="social-tooltip" title="github" href="https://github.com/harvieAlwaysHere" target="_blank">
                        <i class="icon fa fa-github"></i>
                    </a>
                </li>
                
            
        </ul>
    </div>
    
        
<nav id="article-nav">
    
        <a href="/2018/03/10/offer3/" id="article-nav-newer" class="article-nav-link-wrap">
        <strong class="article-nav-caption">下一篇</strong>
        <p class="article-nav-title">
        
            剑指Offer基础知识(三)高质量代码
        
        </p>
        <i class="icon fa fa-chevron-right" id="icon-chevron-right"></i>
    </a>
    
    
        <a href="/2018/03/06/redis4/" id="article-nav-older" class="article-nav-link-wrap">
        <strong class="article-nav-caption">上一篇</strong>
        <p class="article-nav-title">Redis(四)Redis-PHP实战</p>
        <i class="icon fa fa-chevron-left" id="icon-chevron-left"></i>
        </a>
    
</nav>

    
    <div class="widgets-container">
        
            
                
    <div class="widget-wrap">
        <h3 class="widget-title">最新文章</h3>
        <div class="widget">
            <ul id="recent-post" class="">
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2018/04/25/txmianshi/" class="thumbnail">
    
    
        <span style="background-image:url(/images/txms.png)" alt="腾讯后台开发面试总结" class="thumbnail-image"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/ItEassy/">ItEassy</a></p>
                            <p class="item-title"><a href="/2018/04/25/txmianshi/" class="title">腾讯后台开发面试总结</a></p>
                            <p class="item-date"><time datetime="2018-04-25T13:04:38.000Z" itemprop="datePublished">2018-04-25</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2018/04/24/swtest2/" class="thumbnail">
    
    
        <span style="background-image:url(/images/swt21.png)" alt="软件测试(二) 白盒测试" class="thumbnail-image"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/ItEassy/">ItEassy</a></p>
                            <p class="item-title"><a href="/2018/04/24/swtest2/" class="title">软件测试(二) 白盒测试</a></p>
                            <p class="item-date"><time datetime="2018-04-24T02:02:01.000Z" itemprop="datePublished">2018-04-24</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2018/04/23/swtest1/" class="thumbnail">
    
    
        <span style="background-image:url(/images/swt10.png)" alt="软件测试(一) 黑盒测试" class="thumbnail-image"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/ItEassy/">ItEassy</a></p>
                            <p class="item-title"><a href="/2018/04/23/swtest1/" class="title">软件测试(一) 黑盒测试</a></p>
                            <p class="item-date"><time datetime="2018-04-23T06:43:42.000Z" itemprop="datePublished">2018-04-23</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2018/04/12/androidProject1/" class="thumbnail">
    
    
        <span style="background-image:url(/images/android.jpg)" alt="安卓实战开发(一) GroQuiz" class="thumbnail-image"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/ItEassy/">ItEassy</a></p>
                            <p class="item-title"><a href="/2018/04/12/androidProject1/" class="title">安卓实战开发(一) GroQuiz</a></p>
                            <p class="item-date"><time datetime="2018-04-12T07:12:03.000Z" itemprop="datePublished">2018-04-12</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2018/04/10/android4/" class="thumbnail">
    
    
        <span style="background-image:url(/images/android.jpg)" alt="安卓开发(四) 四大组件—广播" class="thumbnail-image"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2018/04/10/android4/" class="title">安卓开发(四) 四大组件—广播</a></p>
                            <p class="item-date"><time datetime="2018-04-10T01:16:40.000Z" itemprop="datePublished">2018-04-10</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">分类</h3>
        <div class="widget">
            <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/ItEassy/">ItEassy</a><span class="category-list-count">50</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Life/">Life</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Music/">Music</a><span class="category-list-count">1</span></li></ul>
        </div>
    </div>


            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">归档</h3>
        <div class="widget">
            <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a><span class="archive-list-count">18</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a><span class="archive-list-count">21</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a><span class="archive-list-count">5</span></li></ul>
        </div>
    </div>


            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">标签</h3>
        <div class="widget">
            <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C++</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GithubPages/">GithubPages</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/">Hexo</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Plan/">Plan</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/">Redis</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Scrapy爬虫/">Scrapy爬虫</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WEB安全/">WEB安全</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web前端/">Web前端</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/music/">music</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php项目/">php项目</a><span class="tag-list-count">20</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/swoole/">swoole</a><span class="tag-list-count">16</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/代码质量/">代码质量</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/剑指Offer/">剑指Offer</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/后台开发/">后台开发</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/字符/">字符</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/字符串/">字符串</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/安卓开发/">安卓开发</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构/">数据结构</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/校园课程/">校园课程</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/粤语/">粤语</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/解题思路/">解题思路</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/软件测试/">软件测试</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/面试总结/">面试总结</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/黑盒测试/">黑盒测试</a><span class="tag-list-count">2</span></li></ul>
        </div>
    </div>


            
                
    <div class="widget-wrap widget-float">
        <h3 class="widget-title">标签云</h3>
        <div class="widget tagcloud">
            <a href="/tags/C/" style="font-size: 11.43px;">C++</a> <a href="/tags/GithubPages/" style="font-size: 11.43px;">GithubPages</a> <a href="/tags/Hexo/" style="font-size: 11.43px;">Hexo</a> <a href="/tags/JavaScript/" style="font-size: 14.29px;">JavaScript</a> <a href="/tags/Linux/" style="font-size: 11.43px;">Linux</a> <a href="/tags/Plan/" style="font-size: 10px;">Plan</a> <a href="/tags/Python/" style="font-size: 11.43px;">Python</a> <a href="/tags/Redis/" style="font-size: 14.29px;">Redis</a> <a href="/tags/Scrapy爬虫/" style="font-size: 11.43px;">Scrapy爬虫</a> <a href="/tags/WEB安全/" style="font-size: 15.71px;">WEB安全</a> <a href="/tags/Web前端/" style="font-size: 14.29px;">Web前端</a> <a href="/tags/music/" style="font-size: 10px;">music</a> <a href="/tags/php项目/" style="font-size: 20px;">php项目</a> <a href="/tags/swoole/" style="font-size: 18.57px;">swoole</a> <a href="/tags/代码质量/" style="font-size: 10px;">代码质量</a> <a href="/tags/剑指Offer/" style="font-size: 17.14px;">剑指Offer</a> <a href="/tags/后台开发/" style="font-size: 10px;">后台开发</a> <a href="/tags/字符/" style="font-size: 10px;">字符</a> <a href="/tags/字符串/" style="font-size: 10px;">字符串</a> <a href="/tags/安卓开发/" style="font-size: 15.71px;">安卓开发</a> <a href="/tags/数据结构/" style="font-size: 14.29px;">数据结构</a> <a href="/tags/校园课程/" style="font-size: 15.71px;">校园课程</a> <a href="/tags/算法/" style="font-size: 14.29px;">算法</a> <a href="/tags/粤语/" style="font-size: 10px;">粤语</a> <a href="/tags/解题思路/" style="font-size: 12.86px;">解题思路</a> <a href="/tags/软件测试/" style="font-size: 11.43px;">软件测试</a> <a href="/tags/面试总结/" style="font-size: 10px;">面试总结</a> <a href="/tags/黑盒测试/" style="font-size: 11.43px;">黑盒测试</a>
        </div>
    </div>


            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">链接</h3>
        <div class="widget">
            <ul>
                
                    <li>
                        <a href="http://hexo.io">Hexo</a>
                    </li>
                
            </ul>
        </div>
    </div>


            
        
    </div>
</aside>
                </div>
            </div>
        </div>
        <footer id="footer">
    <div class="container">
        <div class="container-inner">
            <a id="back-to-top" href="javascript:;"><i class="icon fa fa-angle-up"></i></a>
            <div class="credit">
                <h1 class="logo-wrap">
                    <a href="/" class="logo"></a>
                </h1>
                <p>&copy; 2018 Harvie Yao</p>
                <p>Powered by <a href="//hexo.io/" target="_blank">Hexo</a>. Theme by <a href="//github.com/ppoffice" target="_blank">PPOffice</a></p>
            </div>
        </div>
    </div>
</footer>
        
    
    <script>
    var disqus_shortname = 'hexo-theme-hueman';
    
    
    var disqus_url = 'https://harviealwayshere.github.io/2018/03/09/offerMianshi/';
    
    (function() {
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>




    
        <script src="/libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="/libs/lightgallery/js/lg-share.min.js"></script>
        <script src="/libs/lightgallery/js/lg-video.min.js"></script>
    
    
        <script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>
    
    



<!-- Custom Scripts -->
<script src="/js/main.js"></script>

    </div>
</body>
</html>
